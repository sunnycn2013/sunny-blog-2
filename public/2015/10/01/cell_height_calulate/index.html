<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    
    <title>
    UITableViewCell 高度计算从混沌初始到天地交泰  | 风之痕 | 风之痕的博客
    </title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="description" content="UITableViewCell 高度计算从混沌初始到天地交泰,本文主要基予iOS UITableViewCell 高度自适应计算问题展开陈述。UITableView控件可能是iOS中大家最常用的控件了滚动视图、cell重用、卡顿优化。今天要讨论的不是这些高大上的话题，今天的话题只是cell高度的计算。如下: frame布局下UITableViewCell 高度计算;AutoLayout下UITab">
    <meta property="og:type" content="article">
    <meta property="og:title" content="UITableViewCell 高度计算从混沌初始到天地交泰  | 风之痕">
    <meta property="og:url" content="http://sunnycn.gitcafe.io/2015/10/01/cell_height_calulate/index.html">
    <meta property="og:site_name" content="风之痕">
    <meta property="og:description" content="UITableViewCell 高度计算从混沌初始到天地交泰,本文主要基予iOS UITableViewCell 高度自适应计算问题展开陈述。UITableView控件可能是iOS中大家最常用的控件了滚动视图、cell重用、卡顿优化。今天要讨论的不是这些高大上的话题，今天的话题只是cell高度的计算。如下: frame布局下UITableViewCell 高度计算;AutoLayout下UITab">
    <meta property="og:image" content="http://upload-images.jianshu.io/upload_images/664426-19cc93a143eb90a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
    <meta property="og:image" content="http://upload-images.jianshu.io/upload_images/664426-aa044ce23390fbd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
    <meta property="og:image" content="http://upload-images.jianshu.io/upload_images/664426-ee5070c8bda9fde3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
    <meta property="og:image" content="http://upload-images.jianshu.io/upload_images/664426-ccb02f28ef3d4049.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
    <meta property="og:image" content="http://upload-images.jianshu.io/upload_images/664426-e302c24c910f4c52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
    <meta property="og:image" content="http://upload-images.jianshu.io/upload_images/664426-fc9ece7dca1b35f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
    <meta property="og:image" content="http://upload-images.jianshu.io/upload_images/664426-8cf78621a8e76fca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
    <meta property="og:image" content="http://upload-images.jianshu.io/upload_images/664426-e53b7982696e9c56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
    <meta property="og:image" content="http://upload-images.jianshu.io/upload_images/664426-f66e121d86e311fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
    <meta property="og:updated_time" content="2016-02-01T06:12:35.000Z">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="UITableViewCell 高度计算从混沌初始到天地交泰  | 风之痕">
    <meta name="twitter:description" content="UITableViewCell 高度计算从混沌初始到天地交泰,本文主要基予iOS UITableViewCell 高度自适应计算问题展开陈述。UITableView控件可能是iOS中大家最常用的控件了滚动视图、cell重用、卡顿优化。今天要讨论的不是这些高大上的话题，今天的话题只是cell高度的计算。如下: frame布局下UITableViewCell 高度计算;AutoLayout下UITab">
    <meta name="author" content="关于前端与iOS、React,ReactNative、黑客与画家 | 如画，Web &amp; Mobile Lover，iOS Engineer,移动端 | 这里是 @风之痕 的个人博客，与你一起发现更大的世界。">
    
    
    <link rel="icon" type="image/x-icon" href="/favicon.png">
    <link rel="stylesheet" href="/css/uno.css" type="text/css">
    <link rel="stylesheet" href="/css/highlight.css" type="text/css">
    <link rel="stylesheet" href="/css/archive.css" type="text/css">
    <meta name="baidu-site-verification" content="dDShp3YniR" />
</head>
<body>
    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>
    
<header class="panel-cover panel-cover--collapsed">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
      <div class="panel-main__content">
          <a href="/" title="link to homepage for 风之痕"><img src="/images/avatar.png" width="80" alt="风之痕 logo" class="panel-cover__logo logo" /></a>
          <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">风之痕</a></h1>
          <span class="panel-cover__subtitle"> 上善若水 人淡如菊... </span>
          <hr class="panel-cover__divider" />
          <p class="panel-cover__description">hello 大家好，我是sunny，目前就职于360buy...</p>
          <hr class="panel-cover__divider panel-cover__divider--secondary" />
          <p class="panel-cover__description">
            <a href="http://sunnycn.gitcafe.io" target="_blank">sunnycn.gitcafe.io - 我维护的 iOS 使用技巧分享网站，每周三更新，欢迎访问..</a>
          </p>
          <div class="navigation-wrapper">
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                  <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
                  <li class="navigation__item"><a href="/archives" title="" class="">归档</a></li>
                  <li class="navigation__item"><a href="/notes" title="" class="">随笔</a></li>
                  <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
                </ul>
            </nav>
            <div>
                <nav class="cover-navigation navigation--social">
                    <ul class="navigation">
                        <li class="navigation__item">
                        <a href="http://weibo.com/sunnycn" title="Huno on weibo">
                        <i class='icon icon-social-weibo'></i>
                        <span class="label">weibo</span>
                        </a>
                        </li>
                        <li class="navigation__item">
                            <a href="https://github.com/sunnyvalue" title="Huno on GitHub">
                            <i class='icon icon-social-github'></i>
                            <span class="label">GitHub</span>
                            </a>
                        </li>
                        <li class="navigation__item">
                            <a href="ccguo" title="Huno on twitter">
                            <i class='icon icon-social-twitter'></i>
                            <span class="label">twitter</span>
                            </a>
                        </li>
                        <li class="navigation__item">
                            <a href="ccguo" title="Huno on stack-overflow">
                            <i class='icon icon-social-stack-overflow'></i>
                            <span class="label">stack-overflow</span>
                            </a>
                        </li>
                        <li class="navigation__item">
                            <a href="389878212@qq.com" title="Huno on mail">
                            <i class='icon icon-mail'></i>
                            <span class="label">mail</span>
                            </a>
                        </li>
                    </ul>
                </nav>
            </div>
          </div>
      </div>
    </div>
    <div class="panel-cover--overlay"></div>
  </div>
</header>
    <div class="content-wrapper">
        <div class="content-wrapper__inner entry"> 
<article class="post-container post-container--single">
  <header class="post-header">
    <h1 class="post-title">UITableViewCell 高度计算从混沌初始到天地交泰 </h1>
    
    <div class="post-meta">
      <time datetime="2015-10-01" class="post-meta__date date">2015-10-01</time>
      <span class="post-meta__tags tags">
           &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/AutoLayout/">AutoLayout</a>, <a class="tags-link" href="/tags/FDTemplateLayoutCell/">FDTemplateLayoutCell</a>, <a class="tags-link" href="/tags/TableViewCell/">TableViewCell</a>, <a class="tags-link" href="/tags/iOS/">iOS</a>, <a class="tags-link" href="/tags/电子商务/">电子商务</a>
            </font>
      </span>
    </div>
    
  </header>
  <section id="post-content" class="article-content post">
    <p>本文主要基予iOS UITableViewCell 高度自适应计算问题展开陈述，废话少说直入正题：</p>
<p>UITableView控件可能是iOS中大家最常用的控件了(滚动视图、cell重用、卡顿优化),今天要讨论的不是这些高大上的话题，今天的话题只是cell高度的计算。</p>
<ul>
<li><p>传统frame布局下UITableViewCell 高度计算</p>
</li>
<li><p>AutoLayout下UITableViewCell高度计算（iOS6、7）</p>
</li>
<li><p>UITableViewCell高度计算之iOS8抽风之旅</p>
</li>
<li><p>UITableViewCell高度计算之大一统</p>
</li>
<li><p>第三方库UITableView-FDTemplateLayoutCell源码抛析</p>
</li>
</ul>
<p>以下demo都是在cell高度可变的基础上进行的</p>
<h2 id="u4E00_u3001_u4F20_u7EDFframe_u5E03_u5C40_u4E0BUITableViewCell__u9AD8_u5EA6_u8BA1_u7B97"><a href="#u4E00_u3001_u4F20_u7EDFframe_u5E03_u5C40_u4E0BUITableViewCell__u9AD8_u5EA6_u8BA1_u7B97" class="headerlink" title="一、传统frame布局下UITableViewCell 高度计算"></a>一、传统frame布局下UITableViewCell 高度计算</h2><pre><code>1、史上最传统的UITableViewCell使用方法(号称又笨又老)，相信大家都用过这种，纯frame布局，cell定制，手动传入数据通过手动计算每一行cell的高度，代码都不好意思上了。
</code></pre><p>还是上下之前的demo吧！</p>
<p>01-UITableViewCell-frame</p>
<p>主要是在UITableViewCell(subCell)中使用一个静态方法传入数据并手动计算内容的高度</p>
<p>说到手动计算内容的高度，其实在cell里面大多是计算一些UILabel具体的宽高，根据内容计算UILabel对应的宽高，看下具体的API：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSString</span>(<span class="title">UIStringDrawing</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Single line, no wrapping. Truncation based on the NSLineBreakMode.</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGSize</span>)sizeWithFont:(<span class="built_in">UIFont</span>*)font<span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">2</span>_0,<span class="number">7</span>_0,<span class="string">"Use -sizeWithAttributes:"</span>);</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGSize</span>)sizeWithFont:(<span class="built_in">UIFont</span>*)font forWidth:(<span class="built_in">CGFloat</span>)width lineBreakMode:(<span class="built_in">NSLineBreakMode</span>)lineBreakMode<span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">2</span>_0,<span class="number">7</span>_0,<span class="string">"Use -boundingRectWithSize:options:attributes:context:"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wrapping to fit horizontal and vertical size. Text will be wrapped and truncated using the NSLineBreakMode. If the height is less than a line of text, it may return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a vertical size that is bigger than the one passed in.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If you size your text using the constrainedToSize: methods below, you should draw the text using the drawInRect: methods using the same line break mode for consistency</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGSize</span>)sizeWithFont:(<span class="built_in">UIFont</span>*)font constrainedToSize:(<span class="built_in">CGSize</span>)size<span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">2</span>_0,<span class="number">7</span>_0,<span class="string">"Use -boundingRectWithSize:options:attributes:context:"</span>);<span class="comment">// Uses NSLineBreakModeWordWrap</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGSize</span>)sizeWithFont:(<span class="built_in">UIFont</span>*)font constrainedToSize:(<span class="built_in">CGSize</span>)size lineBreakMode:(<span class="built_in">NSLineBreakMode</span>)lineBreakMode<span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">2</span>_0,<span class="number">7</span>_0,<span class="string">"Use -boundingRectWithSize:options:attributes:context:"</span>);<span class="comment">// NSTextAlignment is not needed to determine size</span></span><br><span class="line">这个地方Apple提供了一个<span class="built_in">NSString</span>的分类，我们可以通过传入对应的string 计算出label的自适应宽高，说到底就是使用sizeWithFont：系列重载函数根据字符串计算label的content大小。</span><br></pre></td></tr></table></figure>
<p>代码中使用：</p>
<p>（NSString一个传统的方法sizeWithFont：）来计算label新的frame，然后更新布局，之后返回一个预计算的高度值</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">CGFloat</span>)calulateHeightWithtTitle:(<span class="built_in">NSString</span>*)title</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">CGFloatheight</span> =<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGSizelabelSize</span> = [titlesizeWithFont:[<span class="built_in">UIFont</span>   systemFontOfSize:<span class="number">17</span>] constrainedToSize:<span class="built_in">CGSizeMake</span>(<span class="number">300</span>,<span class="number">500</span>)];</span><br><span class="line">height = height + labelSize<span class="variable">.height</span>;</span><br><span class="line"></span><br><span class="line">returnheight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终方法的调用在：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span>*)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span>*)indexPath</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> [HomeCell  calulateHeightWithtTitle:<span class="keyword">self</span><span class="variable">.dataArray</span>[indexPath<span class="variable">.row</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来完成，并且return该float值作为cell的高度。</p>
<h2 id="u4E8C_u3001AutoLayout_u4E0BUITableViewCell_u9AD8_u5EA6_u8BA1_u7B97_uFF08iOS6_u30017_uFF09"><a href="#u4E8C_u3001AutoLayout_u4E0BUITableViewCell_u9AD8_u5EA6_u8BA1_u7B97_uFF08iOS6_u30017_uFF09" class="headerlink" title="二、AutoLayout下UITableViewCell高度计算（iOS6、7）"></a>二、AutoLayout下UITableViewCell高度计算（iOS6、7）</h2><p>1、下面介绍第二种方法，使用自动布局下的cell高度计算，总体来讲，自动布局下 的cell高度计算归功于UILabel的布局，自动布局下默认无需要再指定view的frame，设置完对应的约束，label会自动根据内容的多少来完成布局。废话少说先上体验版demo。</p>
<p>08-AutoLayoutCellHeight_ios7</p>
<p>上面描述到，传统frame布局时间，主要是通过一些列手手动计算cell中label的宽高，然后在针对cell中的subView进行重新布局，最后得出一个整体的高度作为cell真实的高度，那么在自动布局中又该如何实现呢？首先自动布局一改了之前frame的概念，自动布局中不存在所谓的坐标 宽高，只有对应的约束。针对UILabel来说，自动布局下label会根据内容的多少自适应的调整label的大小，显示对应的内容。这一点先看下UILabel在iOS6以后发生的变化：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Support for constraint-based layout (auto layout)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If nonzero, this is used when determining -intrinsicContentSize for multiline labels</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)<span class="built_in">CGFloat</span>  preferredMaxLayoutWidth<span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</span><br><span class="line">看到官方的注视，基本也大概有差不多的意思了，这东西实在autolayout下使用的，大概意思是给多行label设置一个布局时间优先使用的一个宽度。</span><br><span class="line"></span><br><span class="line">在看下<span class="built_in">UIView</span>的变化</span><br><span class="line"></span><br><span class="line">@interface<span class="built_in">UIView</span> (<span class="built_in">UIConstraintBasedLayoutFittingSize</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The size fitting most closely to targetSize in which the receiver's subtree can be laid out while optimally satisfying the constraints. If you want the smallest possible size, pass UILayoutFittingCompressedSize; for the largest possible size, pass UILayoutFittingExpandedSize.</span><br><span class="line"></span><br><span class="line">Also see the comment for UILayoutPriorityFittingSizeLevel.</span><br><span class="line"></span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGSize</span>)systemLayoutSizeFittingSize:(<span class="built_in">CGSize</span>)targetSize<span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Equivalent to sending -systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority: with UILayoutPriorityFittingSizeLevel for both priorities.</span></span><br><span class="line"></span><br><span class="line">意思大概就是说 当前的这个这个尺寸关系能够最佳的适应接收器的子树在满足自适应约束的同时，如果想要一个最下的尺寸就设置为：<span class="built_in">UILayoutFittingCompressedSize</span>；反之设置：<span class="built_in">UILayoutFittingExpandedSize</span>。</span><br></pre></td></tr></table></figure>
<p>实战应用：</p>
<p>自动布局下的自适应cell高度玩转，本教程完全依赖storybord ,依旧在代码UI领域的媛猿们，需要转变一下思维了。</p>
<h3 id="281_29_u3001_u521B_u5EFA_u6545_u4E8B_u677F_u3001_u521D_u59CB_u5316_u597Dtableview_u3001cell_u7684_u8F93_u51FA_u53E3_u7B49_uFF0C_u51C6_u5907cell_u7684_u7EA6_u675F_uFF0C_u5982_u56FE_uFF1A"><a href="#281_29_u3001_u521B_u5EFA_u6545_u4E8B_u677F_u3001_u521D_u59CB_u5316_u597Dtableview_u3001cell_u7684_u8F93_u51FA_u53E3_u7B49_uFF0C_u51C6_u5907cell_u7684_u7EA6_u675F_uFF0C_u5982_u56FE_uFF1A" class="headerlink" title="(1)、创建故事板、初始化好tableview、cell的输出口等，准备cell的约束，如图："></a>(1)、创建故事板、初始化好tableview、cell的输出口等，准备cell的约束，如图：</h3><p>cell上只有一个label，label的约束如下，大体就是具体上下左右各加上一个约束，将来在label中放在对应的内容文字，自适应高度（不要忘了设置cell的identifier）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/664426-19cc93a143eb90a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/664426-aa044ce23390fbd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h3 id="282_29_u3001_u90E8_u5206_u5B9E_u73B0_u5904_u7406_u4EE3_u7801"><a href="#282_29_u3001_u90E8_u5206_u5B9E_u73B0_u5904_u7406_u4EE3_u7801" class="headerlink" title="(2)、部分实现处理代码"></a>(2)、部分实现处理代码</h3><p>ViewController中部分代理方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span>*)tableView</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span>*)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> [<span class="keyword">self</span><span class="variable">.dataArraycount</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">UITableViewCell</span>*)tableView:(<span class="built_in">UITableView</span>*)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span>*)indexPath</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *cellIdentifier = <span class="string">@"HomeCell"</span>;</span><br><span class="line"></span><br><span class="line">HomeCell *cell = [tableView  dequeueReusableCellWithIdentifier:cellIdentifier];</span><br><span class="line"></span><br><span class="line">cell<span class="variable">.content</span><span class="variable">.text</span>= [<span class="keyword">self</span><span class="variable">.dataArray</span>  objectAtIndex:indexPath<span class="variable">.row</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span>  preMaxWaith =[<span class="built_in">UIScreen</span>  mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>-<span class="number">108</span>;</span><br><span class="line"></span><br><span class="line">[cell<span class="variable">.contentset</span>  PreferredMaxLayoutWidth:preMaxWaith];</span><br><span class="line"></span><br><span class="line">[cell<span class="variable">.contentlayout</span>  IfNeeded];</span><br><span class="line"></span><br><span class="line">returncell;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">-(<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span>*)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span>*)indexPath</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">staticHomeCell*cell =<span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">static</span> dispatch_once_  tonceToken;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只会走一次</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line"></span><br><span class="line">cell = (HomeCell*)[tableView  dequeueReusableCellWithIdentifier:<span class="string">@"HomeCell"</span>];</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//calculate</span></span><br><span class="line"><span class="built_in">CGFloatheight</span> = [cell  calulateHeightWithtTitle:[<span class="keyword">self</span><span class="variable">.dataArray</span> objectAtIndex:indexPath<span class="variable">.row</span>]desrip:[<span class="keyword">self</span><span class="variable">.dataArray</span> objectAtIndex:indexPath<span class="variable">.row</span>]];</span><br><span class="line"></span><br><span class="line">returnheight;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HomeCell<span class="variable">.m</span></span><br><span class="line"></span><br><span class="line">-(<span class="built_in">CGFloat</span>)calulateHeightWithtTitle:(<span class="built_in">NSString</span>*)title desrip:(<span class="built_in">NSString</span>*)descrip</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这里非常重要</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> preMaxWaith =[<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>-<span class="number">108</span>;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.contentset</span> PreferredMaxLayoutWidth:preMaxWaith];</span><br><span class="line"></span><br><span class="line"><span class="comment">//[self.titleLabel setText:title];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这也很重要</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.content</span>  layoutIfNeeded];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.content</span>  setText:descrip];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.contentView</span>  layoutIfNeeded];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGSizesize</span> = [<span class="keyword">self</span><span class="variable">.contentView</span>  systemLayoutSizeFittingSize:<span class="built_in">UILayoutFittingCompressedSize</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//加1是关键</span></span><br><span class="line"></span><br><span class="line">returnsize<span class="variable">.height</span>+<span class="number">1.0</span>f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">自动布局版cell高度计算OK！！</span><br></pre></td></tr></table></figure>
<h2 id="u4E09_u3001UITableViewCell_u9AD8_u5EA6_u8BA1_u7B97_u4E4BiOS8_u62BD_u98CE_u4E4B_u65C5"><a href="#u4E09_u3001UITableViewCell_u9AD8_u5EA6_u8BA1_u7B97_u4E4BiOS8_u62BD_u98CE_u4E4B_u65C5" class="headerlink" title="三、UITableViewCell高度计算之iOS8抽风之旅"></a>三、UITableViewCell高度计算之iOS8抽风之旅</h2><p>1、说到iOS8，在iOS8下如果要计算cell的高度，代码越来越少，工作越来越轻松，殊不知表面看起来特别人性的iOS8背地里面也有太多坑的勾当（具体原因见后面解释）。</p>
<p>先上iOS的计算cell高度的体验demo：</p>
<p>02-AutoLayout-iOS8-</p>
<p>iOS8下计算cell高度的工作比起之前的版本更加轻松</p>
<h3 id="281_29_u3001_u6545_u4E8B_u7248_u62D6_u597D_u5BF9_u5E94_u7684VC_u3001cell_uFF0C_u63A5_u4E0B_u6765_u4E0A_u7EA6_u675F_uFF0C_u7EA6_u675F_u5982_u4E0B_uFF1A"><a href="#281_29_u3001_u6545_u4E8B_u7248_u62D6_u597D_u5BF9_u5E94_u7684VC_u3001cell_uFF0C_u63A5_u4E0B_u6765_u4E0A_u7EA6_u675F_uFF0C_u7EA6_u675F_u5982_u4E0B_uFF1A" class="headerlink" title="(1)、故事版拖好对应的VC、cell，接下来上约束，约束如下："></a>(1)、故事版拖好对应的VC、cell，接下来上约束，约束如下：</h3><p><img src="http://upload-images.jianshu.io/upload_images/664426-ee5070c8bda9fde3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>整体来说与2中的约束差不多，分别设置label距离四周的约束情况。（本篇文章要实现的本来就是相同的效果，在不同版本下的的实现方式以及优劣的对比与优化。）</p>
<p>设置好约束后</p>
<h3 id="282_29-_iOS8_u7684cell_u9AD8_u5EA6_u8BA1_u7B97_u4EE3_u7801"><a href="#282_29-_iOS8_u7684cell_u9AD8_u5EA6_u8BA1_u7B97_u4EE3_u7801" class="headerlink" title="(2). iOS8的cell高度计算代码"></a>(2). iOS8的cell高度计算代码</h3><p>设置tableview的属性</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">self</span>.<span class="built_in">table</span>View.estimatedRowHeight=<span class="number">44.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="literal">self</span>.<span class="built_in">table</span>View.rowHeight=UITableViewAutomaticDimension;</span><br></pre></td></tr></table></figure>
<p>至此，iOS8cell高度自适应计算OK！！ 就是这么简单…</p>
<h2 id="u56DB_u3001UITableViewCell_u9AD8_u5EA6_u8BA1_u7B97_u4E4B_u5927_u4E00_u7EDF"><a href="#u56DB_u3001UITableViewCell_u9AD8_u5EA6_u8BA1_u7B97_u4E4B_u5927_u4E00_u7EDF" class="headerlink" title="四、UITableViewCell高度计算之大一统"></a>四、UITableViewCell高度计算之大一统</h2><p>在介绍本栏目之前先上一张表：</p>
<p>heightForRowAtIndexPath：cell高度计算次数<br><img src="http://upload-images.jianshu.io/upload_images/664426-ccb02f28ef3d4049.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>heightForRowAtIndexPath：cell计算对比<br>由于iOS7之后，tableview 提供了estimatedHeightForRowAtIndexPathCount的API，这就对cell高度计算的方法调用次数产生了影响。</p>
<p>下面首先说下estimatedHeightForRowAtIndexPathCount ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// <span class="operator"><span class="keyword">Use</span> the estimatedHeight methods <span class="keyword">to</span> quickly calcuate guessed <span class="keyword">values</span> which will <span class="keyword">allow</span> <span class="keyword">for</span> <span class="keyword">fast</span> <span class="keyword">load</span> times <span class="keyword">of</span> the <span class="keyword">table</span>.</span><br><span class="line"></span><br><span class="line">// <span class="keyword">If</span> these methods <span class="keyword">are</span> implemented, the above -tableView:heightForXXX calls will be <span class="keyword">deferred</span> <span class="keyword">until</span> views <span class="keyword">are</span> ready <span class="keyword">to</span> be displayed, so more expensive logic can be placed there.</span><br><span class="line"></span><br><span class="line">- (CGFloat)tableView:(UITableView*)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath*)indexPathNS_AVAILABLE_IOS(<span class="number">7</span>_0);</span></span><br></pre></td></tr></table></figure>
<p>apple的文档里面说大概意思是estimatedHeight可以快速的预估一个cell的高度值，从而让table的加载速度更快。整体来说就是tableview在渲染的时间，他会首先根据内容计算每个cell的高度，从而计算出tableview的的一个contentsize（tableview继承于scrollview），但是如果有一万行数据，那么这个计算的过程会非常的卡顿，从而影响table的load的速度，我们可以给cell（除了当前需要显示在屏幕上的cell）设置一个预估的高度值，这样就大大节省了计算高度的损耗与开销。</p>
<p>有上图可以看出，iOS7 的tableview对于cell的高度是有缓存功能的，当划到底部，从底部再往顶部滑动时间，heightForRowAtIndexPath：cell的调用次数为0，这说话cell的高度已经换存在了内存。iOS8、iOS9坑爹的一面在于当关闭高度预估方法时间（estimatedHeightForRowAtIndexPathCount），heightForRowAtIndexPath：cell的调用次数非常多(我们一般会在这个地方计算根据内容手动计算cell的高度，或者更新cell内不各种view的约束)，这个过程如果频繁的调用是非常耗损性能的，更悲剧的事造成tableview的卡顿，这个是最容忍不了的。当开启高度预估时间，高度预估之时返回了一个定值，此时heightForRowAtIndexPath：cell的调用次数大大减少，高度计算的工作也就大大减少，此时就是我们想要的效果。</p>
<p>此外，这个地方有一个可能忽略的问题，当我们的工程从原来的iOS7迁移到8再到9的时间，如果这个地方不做进一步的优化，之前的代码在新的系统下跑起来结果就不想而之了，为了能够兼容到所有系统下的cell高度计算，推荐一个新的工具</p>
<p>UITableView-FDTemplateLayoutCell</p>
<p>参考博客：具体教程如</p>
<h3 id="281_29_u3001FDTemplateLayoutCell__u4F7F_u7528_u6559_u7A0B"><a href="#281_29_u3001FDTemplateLayoutCell__u4F7F_u7528_u6559_u7A0B" class="headerlink" title="(1)、FDTemplateLayoutCell 使用教程"></a>(1)、FDTemplateLayoutCell 使用教程</h3><ul>
<li><p>1、下载FDTemplateLayoutCell第三方库，导入工程<br><img src="http://upload-images.jianshu.io/upload_images/664426-e302c24c910f4c52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</li>
<li><p>2、导入头文件<br><img src="http://upload-images.jianshu.io/upload_images/664426-fc9ece7dca1b35f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</li>
<li><p>3、使用FD实现heightForRowAtIndexPath方法</p>
</li>
</ul>
<p>如下：<br><img src="http://upload-images.jianshu.io/upload_images/664426-8cf78621a8e76fca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ul>
<li>4、大功告成，使用fd一次性解决的iOS 6、7、8、9中的cell高度计算问题，FD采用自带的缓存的机制，无需多次调用heightForRowAtIndexPath时间的cell高度计算开销.<br><img src="http://upload-images.jianshu.io/upload_images/664426-e53b7982696e9c56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></li>
</ul>
<h4 id="1_u3001FDTemplateLayoutCell_u4E4B_u6240_u4EE5_u80FD_u591F_u505A_u5230_u517C_u5BB9_u5230_u6240_u6709_u7684_u7CFB_u7EDF_u7248_u672C_u4E0B_u7684tableview_uFF0C_u4E3B_u8981_u5728_u4E8E_u5B83_u7EF4_u62A4_u4E86_u4E00_u5957_u81EA_u5DF1_u7684cell_u9AD8_u5EA6_u7F13_u5B58_uFF0C_u540C_u65F6_u6709_u6548_u7684_u5229_u7528_u4E86tableview_u7684_u9AD8_u5EA6_u9884_u4F30_u7684_u529F_u80FD_u3002_u4ECE_u65B0_u5B9A_u4E49_u65B0_u7684cell_u9AD8_u5EA6_u7F13_u5B58_u7B56_u7565_uFF0C_u8FD9_u4E00_u70B9_u89E3_u51B3_u4E86_u53EA_u6709iOS7_u4E0B_u7CFB_u7EDF_u624D_u4F1A_u4E3B_u52A8_u7F13_u5B58cell_u9AD8_u5EA6_u7684_u8FD9_u4E00_u96BE_u70B9_uFF0C_u6709_u4E86_uFF26_uFF24iOS8_u30019_u4E0B_u4E5F_u80FD_u4F7F_u7528_u7F13_u5B58_u9AD8_u5EA6"><a href="#1_u3001FDTemplateLayoutCell_u4E4B_u6240_u4EE5_u80FD_u591F_u505A_u5230_u517C_u5BB9_u5230_u6240_u6709_u7684_u7CFB_u7EDF_u7248_u672C_u4E0B_u7684tableview_uFF0C_u4E3B_u8981_u5728_u4E8E_u5B83_u7EF4_u62A4_u4E86_u4E00_u5957_u81EA_u5DF1_u7684cell_u9AD8_u5EA6_u7F13_u5B58_uFF0C_u540C_u65F6_u6709_u6548_u7684_u5229_u7528_u4E86tableview_u7684_u9AD8_u5EA6_u9884_u4F30_u7684_u529F_u80FD_u3002_u4ECE_u65B0_u5B9A_u4E49_u65B0_u7684cell_u9AD8_u5EA6_u7F13_u5B58_u7B56_u7565_uFF0C_u8FD9_u4E00_u70B9_u89E3_u51B3_u4E86_u53EA_u6709iOS7_u4E0B_u7CFB_u7EDF_u624D_u4F1A_u4E3B_u52A8_u7F13_u5B58cell_u9AD8_u5EA6_u7684_u8FD9_u4E00_u96BE_u70B9_uFF0C_u6709_u4E86_uFF26_uFF24iOS8_u30019_u4E0B_u4E5F_u80FD_u4F7F_u7528_u7F13_u5B58_u9AD8_u5EA6" class="headerlink" title="1、FDTemplateLayoutCell之所以能够做到兼容到所有的系统版本下的tableview，主要在于它维护了一套自己的cell高度缓存，同时有效的利用了tableview的高度预估的功能。从新定义新的cell高度缓存策略，这一点解决了只有iOS7下系统才会主动缓存cell高度的这一难点，有了ＦＤiOS8、9下也能使用缓存高度"></a>1、FDTemplateLayoutCell之所以能够做到兼容到所有的系统版本下的tableview，主要在于它维护了一套自己的cell高度缓存，同时有效的利用了tableview的高度预估的功能。从新定义新的cell高度缓存策略，这一点解决了只有iOS7下系统才会主动缓存cell高度的这一难点，有了ＦＤiOS8、9下也能使用缓存高度</h4><h4 id="2_u3001_u5F00_u542FUITableView_u9AD8_u5EA6_u9884_u4F30_u529F_u80FD_uFF0C_u4F18_u5316heightForRowAtIndexPath_u7684_u8C03_u7528_u7D2F_u8BA1_u6B21_u6570"><a href="#2_u3001_u5F00_u542FUITableView_u9AD8_u5EA6_u9884_u4F30_u529F_u80FD_uFF0C_u4F18_u5316heightForRowAtIndexPath_u7684_u8C03_u7528_u7D2F_u8BA1_u6B21_u6570" class="headerlink" title="2、开启UITableView高度预估功能，优化heightForRowAtIndexPath的调用累计次数"></a>2、开启UITableView高度预估功能，优化heightForRowAtIndexPath的调用累计次数</h4><p>（tableView:estimatedHeightForRowAtIndexPath: NS_AVAILABLE_IOS(7_0);）</p>
<p>由上可以看出estimatedHeightForRowAtIndexPath是iOS7才有的，iOS6是没有这个代理的，这个时间不仅要问，难道要iOS必须支持iOS7+以上才能使用，答案当然不是，系统的API早已做了优化，estimatedHeightForRowAtIndexPath在iOS6下面默认是可以被忽略的，不会因为版本的问题引起异常。在iOS6下高度计算的策略会跟iOS8、9下有点类似，使用FD自己提供的缓存，也能达到有效的减少计算cell高度带来的开销。</p>
<h2 id="u4E94_u3001FDTemplateLayoutCell_u6E90_u7801_u629B_u6790"><a href="#u4E94_u3001FDTemplateLayoutCell_u6E90_u7801_u629B_u6790" class="headerlink" title="五、FDTemplateLayoutCell源码抛析"></a>五、FDTemplateLayoutCell源码抛析</h2><p>谈到FD，首先熟悉下之前的一个知识点, iOS知识点整理-RunLoop。可能有些老生常谈了，也有可能部分童鞋看到直接晕掉了，其实大多iOS里面大多第三方库的手段无外乎就是runtime(这个东西在java中叫reflact,java里面有AOP , iOS 其实跟这个差不多)、CF这些黑魔法之类的东西来进行偷天换日、移花接木。</p>
<p>小结：iOS 中的runloop</p>
<ul>
<li><p>1、NSRunLoop提供了面向对象的API，但这些API不是线程安全的</p>
</li>
<li><p>2、CFRunLoopRef提供了纯C函数的API，所有这些API都是线程安全的</p>
</li>
</ul>
<p>NSRunLoop是cocoa提供的，这个东西可能大多人还是经常使用的，cell里面更新异步下载成功的图片、启用一个timer追加到当前的应用循环中、启用一个常驻线程等；</p>
<p>CFRunLoopRef可能就相对陌生些，CF开头跟定就是CoreFoundation中定义的，可以暂时理解为每个线程都有一个对应的runloop， 在一个runloop中可以有多种Model(模式),每个Mode又包含若干个source/Timer/Observe .</p>
<p>程序执行的时间当前runloop 只能存在一种Model，如果发生场景切换需要退出当前Model，进入下一个Model</p>
<p>系统一共提供了五种model：</p>
<ul>
<li>NSDefaultRunLoopMode:    App默认Mode,当没有接收到ScrollView滚动是，主线程通常使用这个Mode</li>
<li>NSTrackingRunLoopMode:  到接收到ScroolView或其子类的时候，主线程就会切换到这个模式下运行。</li>
<li>UIInitializationRunLoopMode：当App启动时使用的第一个Mode,当启动完成后不再使用。</li>
<li>NSRunLoopCommonModes，是一个tag,本质上不是一个Mode,默认                    NSDefaultRunLoopMode和NSTrackingRunLoopMode都绑定这个tag。(应用场景：有时候我们需要添加一个NSTimer在RunLoop,在这时需要制定一个Modes，现在的需求是:我们既要在默认模式下要监听，在滚动模式下也要监听，但只能制定一个模式，这是可以制定这个CommonMode)</li>
<li>GSEventReceiveRunLoopMode：接受系统内部的Mode,通常做不到。</li>
</ul>
<p>处理不同事件使用不同的Mode，可以最大限度的把性能的最大化处理不同分类的事件，提高性能。<br>知道了这些，我们可以在此处做文章，我们发现UITableView(继承UIScrollView)不滚动时间是NSDefaultRunLoopMode 模式，滚动时间是NSTrackingRunLoopMode模式，我们可以 通过注册观察者来实现让tableview不滚动的时间再去计算所有的cell的高度，一旦当tableview开始滚动我们再去取得时间着时间缓存池里面已经计算 的差不多了，也就是说尽最大可能让tableview不滚动的时间处理好所有的cell高度，缓存下来，等到滑动tableview的时间优先从缓存取，这个地方尽最大避免了边滑动边计算cell高度卡顿问题。</p>
<p>完成了这个知识点，接下来就是处理好缓存逻辑的事情了。</p>
<h3 id="1_u3001FD_u7F13_u5B58_u6C60"><a href="#1_u3001FD_u7F13_u5B58_u6C60" class="headerlink" title="1、FD缓存池"></a>1、FD缓存池</h3><p>首先对于FD来说，维护cell的高度需要将计算过的cell的高度放进一个二维数组里面(section row)</p>
<p>FD中存在一个可维护的NSMutableArray sections; 可以先理解为一个嵌套起来的数组是一个二位的数组，接下来的时间会把tableview 某个section下的row对应的行对应的高度存在这个位置。</p>
<h3 id="2_u3001_u6E32_u67D3_u7684_u9891_u7387"><a href="#2_u3001_u6E32_u67D3_u7684_u9891_u7387" class="headerlink" title="2、渲染的频率"></a>2、渲染的频率</h3><p>tableView渲染的时间，统一还是会走 heightForRowAtIndexPath方法的，我们只需要在此处直接获取到cache里面的已经存储的高度就行了，在此处避开cell的高度逻辑计算过程就到达了我们的目的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/664426-f66e121d86e311fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>FD组件已经作了很好的封装，在heightForRowAtIndexPath中调用fd计算高度的方法，</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)fd_heightForCellWithIdentifier:(<span class="built_in">NSString</span>*)identifier cacheByIndexPath:(<span class="built_in">NSIndexPath</span>*)indexPath configuration:(<span class="keyword">void</span>(^)(<span class="keyword">id</span>))configuration</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!identifier || !indexPath) &#123;</span><br><span class="line">	return0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enable auto cache invalidation if you use this "cacheByIndexPath" API.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">self</span><span class="variable">.fd_autoCacheInvalidationEnabled</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">self</span><span class="variable">.fd_autoCacheInvalidationEnabled</span>=<span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enable precache if you use this "cacheByIndexPath" API.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">self</span><span class="variable">.fd_precacheEnabled</span>) &#123;</span><br><span class="line">	<span class="keyword">self</span><span class="variable">.fd_precacheEnabled</span>=<span class="literal">YES</span>;</span><br><span class="line">	<span class="comment">// Manually trigger precache only for the first time.</span></span><br><span class="line">	[selffd_precacheIfNeeded];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hit the cache</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>([<span class="keyword">self</span><span class="variable">.fd_cellHeightCachehasCachedHeightAtIndexPath</span>:indexPath]) &#123;</span><br><span class="line"></span><br><span class="line">	[<span class="keyword">self</span> fd_debugLog:[<span class="built_in">NSStringstringWithFormat</span>:</span><br><span class="line">	<span class="string">@"hit cache - [%@:%@] %@"</span>,</span><br><span class="line">	@(indexPath<span class="variable">.section</span>),</span><br><span class="line">	@(indexPath<span class="variable">.row</span>),</span><br><span class="line">	@([<span class="keyword">self</span><span class="variable">.fd_cellHeightCachecachedHeightAtIndexPath</span>:indexPath])]];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span>[<span class="keyword">self</span><span class="variable">.fd_cellHeightCachecachedHeightAtIndexPath</span>:indexPath];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call basic height calculation method.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloatheight</span> =[selffd_heightForCellWithIdentifier:identifierconfiguration:configuration];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> fd_debugLog:[<span class="built_in">NSStringstringWithFormat</span>:</span><br><span class="line">	<span class="string">@"cached - [%@:%@] %@"</span>,</span><br><span class="line">	@(indexPath<span class="variable">.section</span>),</span><br><span class="line">	@(indexPath<span class="variable">.row</span>),</span><br><span class="line">	@(height)]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cache it</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.fd_cellHeightCachecacheHeight</span>:heightbyIndexPath:indexPath];</span><br><span class="line">returnheight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个步骤中，基本可以看出FD的使用策略，首先开启一个[selffd_precacheIfNeeded]的操作（这个过程是做了一个预计算cell高度的操作，稍后详解），接下来的过程就是从缓存池中根据IndexPath(cell高度预存储在一个模拟的二维数组中)去读取cell的高度，如果cache命中就直接返回cell高度，否则执行：</p>
<p>// Call basic height calculation method.</p>
<p>CGFloatheight = [self fd_heightForCellWithIdentifier:identifierconfiguration:configuration];<br>去手动计算一次cell的高度，计算获得后存入缓存池</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cache it</span></span><br><span class="line">[self.<span class="string">fd_cellHeightCachecacheHeight:</span><span class="string">heightbyIndexPath:</span>indexPath];</span><br></pre></td></tr></table></figure>
<p>最后返回高度。</p>
<h3 id="3_u3001_u4ECB_u7ECDFD_u7684_u7F13_u5B58_u6C60"><a href="#3_u3001_u4ECB_u7ECDFD_u7684_u7F13_u5B58_u6C60" class="headerlink" title="3、介绍FD的缓存池"></a>3、介绍FD的缓存池</h3><p>FD在这个地方利用了runloop的黑魔法，通过注册一个观察者，当tableview停止滑动的他会主动去计算当前数据源中的剩余的cell的高度，计算完以后存储在缓存池中，这个调用就是（2）中的</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enable precache if you use this "cacheByIndexPath" API.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">self</span><span class="variable">.fd_precacheEnabled</span>) &#123;</span><br><span class="line">	<span class="keyword">self</span><span class="variable">.fd_precacheEnabled</span>=<span class="literal">YES</span>;</span><br><span class="line">	<span class="comment">// Manually trigger precache only for the first time.</span></span><br><span class="line">	[selffd_precacheIfNeeded];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个开启调用中，通过一些列手段将tableview不滚动时间去计算cell的高度（具体原理此处省略），计算后存入缓存池sections,sections是一个可变数组，笔者显示把这个理解成一个内存存储元素是可变数组的数组(模拟一个二维数组)，FD先是给自己增加了一个属性sections作为缓存池，通过objc_setAssociatedObject给分类增加属性的此处就不介绍了，</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">[<span class="keyword">selfbuildHeightCachesAtIndexPathsIfNeeded:@</span><span class="list">[<span class="keyword">indexPath</span>]]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">self.sections<span class="list">[<span class="keyword">indexPath.section</span>]<span class="list">[<span class="keyword">indexPath.row</span>] =@<span class="list">(<span class="keyword">height</span>)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Build every section array or row array which is smaller than given index path.</span><br><span class="line"></span><br><span class="line"><span class="list">[<span class="keyword">indexPaths</span> enumerateObjectsUsingBlock:^<span class="list">(<span class="keyword">NSIndexPath*indexPath</span>,NSUIntegeridx,BOOL*stop)</span> &#123;</span><br><span class="line"></span><br><span class="line">NSAssert<span class="list">(<span class="keyword">indexPath.section&gt;=0</span>,@<span class="string">"Expect a positive section rather than '%@'."</span>,@<span class="list">(<span class="keyword">indexPath.section</span>)</span>)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	for<span class="list">(<span class="keyword">NSIntegersection</span> =0<span class="comment">; section &lt;= indexPath.section; ++section) &#123;</span></span><br><span class="line"></span><br><span class="line">	if<span class="list">(<span class="keyword">section</span> &gt;=self.sections.count)</span> &#123;</span><br><span class="line"></span><br><span class="line">		self.sections<span class="list">[<span class="keyword">section</span>] =@<span class="list">[].mutableCopy<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSMutableArray*rows =self.sections<span class="list">[<span class="keyword">indexPath.section</span>]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">for<span class="list">(<span class="keyword">NSIntegerrow</span> =0<span class="comment">; row &lt;= indexPath.row; ++row) &#123;</span></span><br><span class="line"></span><br><span class="line">if<span class="list">(<span class="keyword">row</span> &gt;= rows.count)</span> &#123;</span><br><span class="line"></span><br><span class="line">rows<span class="list">[<span class="keyword">row</span>] =@<span class="list">(<span class="keyword">_FDTemplateLayoutCellHeightCacheAbsentValue</span>)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;]<span class="comment">;</span></span></span></span></span></span></span></span></span></span></span></span></span><br></pre></td></tr></table></figure>
<p>此处主要是构造一个缓存池，通过在sections中存储一个NSMutableArray,模拟一个二维的数组</p>
<p>通过indexPath的section 和 row作为下标，构造完成直接将高度存进去：</p>
<p>self.sections[indexPath.section][indexPath.row] =@(height);</p>
<p>至此缓存池结束</p>
<h3 id="4_u3001FD_u5C0F_u7ED3"><a href="#4_u3001FD_u5C0F_u7ED3" class="headerlink" title="4、FD小结"></a>4、FD小结</h3><p>至此FD的核心手段大题已经讲完，接下来就是考虑到tableview的增删改插的时间的处理问题，这一系列的动作都会对缓存池的更新有一定的影响，FD已经做了最大的限度的优化，依旧runtime, swizzling的魔法就不多解释了。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">dispatch_once<span class="list">(<span class="keyword">&amp;onceToken</span>, ^&#123;</span><br><span class="line"></span><br><span class="line">SELselectors[] = &#123;</span><br><span class="line"></span><br><span class="line">@selector<span class="list">(<span class="keyword">reloadData</span>)</span>,</span><br><span class="line"></span><br><span class="line">@selector<span class="list">(<span class="keyword">insertSections</span><span class="keyword">:withRowAnimation</span>:)</span>,</span><br><span class="line"></span><br><span class="line">@selector<span class="list">(<span class="keyword">deleteSections</span><span class="keyword">:withRowAnimation</span>:)</span>,</span><br><span class="line"></span><br><span class="line">@selector<span class="list">(<span class="keyword">reloadSections</span><span class="keyword">:withRowAnimation</span>:)</span>,</span><br><span class="line"></span><br><span class="line">@selector<span class="list">(<span class="keyword">moveSection</span><span class="keyword">:toSection</span>:)</span>,</span><br><span class="line"></span><br><span class="line">@selector<span class="list">(<span class="keyword">insertRowsAtIndexPaths</span><span class="keyword">:withRowAnimation</span>:)</span>,</span><br><span class="line"></span><br><span class="line">@selector<span class="list">(<span class="keyword">deleteRowsAtIndexPaths</span><span class="keyword">:withRowAnimation</span>:)</span>,</span><br><span class="line"></span><br><span class="line">@selector<span class="list">(<span class="keyword">reloadRowsAtIndexPaths</span><span class="keyword">:withRowAnimation</span>:)</span>,</span><br><span class="line"></span><br><span class="line">@selector<span class="list">(<span class="keyword">moveRowAtIndexPath</span><span class="keyword">:toIndexPath</span>:)</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">for<span class="list">(<span class="keyword">NSUIntegerindex</span> =0<span class="comment">; index</span></span><br><span class="line"></span><br><span class="line">SELoriginalSelector = selectors[index]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">SELswizzledSelector =NSSelectorFromString<span class="list">([@<span class="string">"fd_"</span>stringByAppendingString<span class="keyword">:NSStringFromSelector</span><span class="list">(<span class="keyword">originalSelector</span>)</span>])</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">MethodoriginalMethod =class_getInstanceMethod<span class="list">(<span class="keyword">self</span>, originalSelector)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">MethodswizzledMethod =class_getInstanceMethod<span class="list">(<span class="keyword">self</span>, swizzledSelector)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">method_exchangeImplementations<span class="list">(<span class="keyword">originalMethod</span>, swizzledMethod)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><span class="comment">;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="u5C0F_u7ED3_uFF1A"><a href="#u5C0F_u7ED3_uFF1A" class="headerlink" title="小结："></a>小结：</h2><p>FD是一个封装的很完美的库，其实从一开始使用这个库就喜欢上了，作者是百度的sunnyxy,另一方面iOS中runtime仍旧是一个很强大的东西，大多的第三方库无非都是基本objc runtime做的一些便捷优化，但是一个优秀的第三方库需要作者不断的完善和大家的共同努力。</p>

  </section>
  <div class="read-more">
   
   <div class="read-more-item read-more-item-left">
    
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list__post-title post-title">
       <a href="/2015/10/24/aop-ios/" title="link to " class="read-more-link-title"> 漫谈iOS AOP编程之路 
       </a></h2>
       <p class="excerpt">面向切面编程(也叫面向方面)：Aspect Oriented Programming(AOP),是目前软件开发中的一个热点。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。　　AOP是OOP的延续，是（Aspect Oriented Programming）的缩写，意思是面向切面（方面）编程。　　主要的功能是：日志记录， &hellip;</p>
       <div class="post-list__meta">
          <a class="btn-border-small read-more-item-link" href="/2015/10/24/aop-ios/">继续阅读</a>
          <time datetime="{{date format="DD MMM YYYY"}}" class="post-list__meta--date date">
          2015-10-24
          </time> &#8226; 
          <span class="post-list__meta--tags tags">风之痕</span>
       </div>
    
   </div>
   
   <div class="read-more-item read-more-item-right">
    
   </div>
   
</div>

  
<section class="post-comments">
<div id="disqus_thread"></div>
<script>
var disqus_config = function () {
this.page.url = 'http://sunnycn.gitcafe.io'; // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = 'sunnycn21'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = '//sunnycn21.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the 
<a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
</section>





  
</article>
        <footer class="footer">
        <div>
            <div class="footer__copyright">
    	       本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a>
            </div>
            <div class="footer__copyright">
    	       基于 <a href="https://hexo.io/">Hexo</a> 搭建 | - 本站由 <a href="https://github.com/sunnyvalue/">@sunnyvalue</a> 创建，采用 <a href="https://github.com/sunnyvalue/sunny-blog.git">huno</a> 作为主题
            </div>
            <div class="footer__copyright">
                本页点击 
                <span id="busuanzi_value_page_pv"></span> 次| 本站总点击 <span id="busuanzi_value_site_pv"></span> 次| 您是第 <span id="busuanzi_value_site_uv">
                </span> 位访客
	            <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	            </script>
                <span><a href="/sitemap.xml">Google网站地图</a></span>
  	            <span><a href="/baidusitemap.xml">百度网站地图</a></span>
            </div>
        </div>
  	 <script>
		(function(){
    		var bp = document.createElement('script');
    		bp.src = '//push.zhanzhang.baidu.com/push.js';
    		var s = document.getElementsByTagName("script")[0];
    		s.parentNode.insertBefore(bp, s);
		})();
	 </script>
        </footer>

        </div>
    </div>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script> 
    
    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>

    <script>
	var _hmt = _hmt || [];
	(function() {
  	var hm = document.createElement("script");
  	hm.src = "//hm.baidu.com/hm.js?bff0d31b7343635ef2daea623ff5ec14";
  	var s = document.getElementsByTagName("script")[0]; 
  	s.parentNode.insertBefore(hm, s);
	})();
	</script>
     
    <!--kill ie6 --><!--[if IE 6]><script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script><![endif]-->
</body>
</html>
