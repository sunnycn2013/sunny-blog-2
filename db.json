{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1},{"_id":"themes/huno/source/js/scale.fix.js","path":"js/scale.fix.js","modified":1},{"_id":"themes/huno/source/js/main.js","path":"js/main.js","modified":1},{"_id":"themes/huno/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1},{"_id":"themes/huno/source/js/jquery.githubRepoWidget.min.js","path":"js/jquery.githubRepoWidget.min.js","modified":1},{"_id":"themes/huno/source/js/awesome-toc.min.js","path":"js/awesome-toc.min.js","modified":1},{"_id":"themes/huno/source/images/totop.png","path":"images/totop.png","modified":1},{"_id":"themes/huno/source/images/sina-weibo.svg","path":"images/sina-weibo.svg","modified":1},{"_id":"themes/huno/source/images/sina-weibo.png","path":"images/sina-weibo.png","modified":1},{"_id":"themes/huno/source/images/background-cover副本.jpg","path":"images/background-cover副本.jpg","modified":1},{"_id":"themes/huno/source/images/background-cover6.jpg","path":"images/background-cover6.jpg","modified":1},{"_id":"themes/huno/source/images/background-cover5.jpg","path":"images/background-cover5.jpg","modified":1},{"_id":"themes/huno/source/images/background-cover4.jpg","path":"images/background-cover4.jpg","modified":1},{"_id":"themes/huno/source/images/background-cover3.jpg","path":"images/background-cover3.jpg","modified":1},{"_id":"themes/huno/source/images/background-cover222.jpg","path":"images/background-cover222.jpg","modified":1},{"_id":"themes/huno/source/images/background-cover1.jpg","path":"images/background-cover1.jpg","modified":1},{"_id":"themes/huno/source/images/background-cover.jpg","path":"images/background-cover.jpg","modified":1},{"_id":"themes/huno/source/images/avatar.png","path":"images/avatar.png","modified":1},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-uitestdemo.gif","path":"images/2015-12-16/post-xctest-case/xctest-case-uitestdemo.gif","modified":1},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-uitestcode.jpeg","path":"images/2015-12-16/post-xctest-case/xctest-case-uitestcode.jpeg","modified":1},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-uitestStart.jpeg","path":"images/2015-12-16/post-xctest-case/xctest-case-uitestStart.jpeg","modified":1},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-trackDao.png","path":"images/2015-12-16/post-xctest-case/xctest-case-trackDao.png","modified":1},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-testsucc.png","path":"images/2015-12-16/post-xctest-case/xctest-case-testsucc.png","modified":1},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-testlog.png","path":"images/2015-12-16/post-xctest-case/xctest-case-testlog.png","modified":1},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-selectschem.png","path":"images/2015-12-16/post-xctest-case/xctest-case-selectschem.png","modified":1},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-editschem.png","path":"images/2015-12-16/post-xctest-case/xctest-case-editschem.png","modified":1},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-createpro.png","path":"images/2015-12-16/post-xctest-case/xctest-case-createpro.png","modified":1},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-createUITestSelectItem.jpeg","path":"images/2015-12-16/post-xctest-case/xctest-case-createUITestSelectItem.jpeg","modified":1},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-createUITestPro.jpeg","path":"images/2015-12-16/post-xctest-case/xctest-case-createUITestPro.jpeg","modified":1},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-coverageItem.png","path":"images/2015-12-16/post-xctest-case/xctest-case-coverageItem.png","modified":1},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-coverage.png","path":"images/2015-12-16/post-xctest-case/xctest-case-coverage.png","modified":1},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-UItestIB.jpeg","path":"images/2015-12-16/post-xctest-case/xctest-case-UItestIB.jpeg","modified":1},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/end.gif","path":"images/2015-12-16/post-xctest-case/end.gif","modified":1},{"_id":"themes/huno/source/images/2015-12-16/post-react-native-cut/termial.png","path":"images/2015-12-16/post-react-native-cut/termial.png","modified":1},{"_id":"themes/huno/source/images/2015-12-16/post-react-native-cut/react-native-03.png","path":"images/2015-12-16/post-react-native-cut/react-native-03.png","modified":1},{"_id":"themes/huno/source/images/2015-12-16/post-react-native-cut/react-native-02.png","path":"images/2015-12-16/post-react-native-cut/react-native-02.png","modified":1},{"_id":"themes/huno/source/images/2015-12-16/post-react-native-cut/react-native-01.png","path":"images/2015-12-16/post-react-native-cut/react-native-01.png","modified":1},{"_id":"themes/huno/source/images/2015-12-16/post-react-native-cut/react-native-00.png","path":"images/2015-12-16/post-react-native-cut/react-native-00.png","modified":1},{"_id":"themes/huno/source/images/2015-12-16/post-react-native-cut/ReactNative-Starter.png","path":"images/2015-12-16/post-react-native-cut/ReactNative-Starter.png","modified":1},{"_id":"themes/huno/source/images/2015-12-16/hexo/hexo.png","path":"images/2015-12-16/hexo/hexo.png","modified":1},{"_id":"themes/huno/source/images/2015-12-16/MVP/service.png","path":"images/2015-12-16/MVP/service.png","modified":1},{"_id":"themes/huno/source/images/2015-12-16/MVP/mvp.png","path":"images/2015-12-16/MVP/mvp.png","modified":1},{"_id":"themes/huno/source/images/2015-12-16/MVP/mvc.png","path":"images/2015-12-16/MVP/mvc.png","modified":1},{"_id":"themes/huno/source/images/2015-12-16/MVP/ios_mvc.png","path":"images/2015-12-16/MVP/ios_mvc.png","modified":1},{"_id":"themes/huno/source/images/12669076,2560,1600.jpg","path":"images/12669076,2560,1600.jpg","modified":1},{"_id":"themes/huno/source/fonts/foundation-icons/foundation-icons.woff","path":"fonts/foundation-icons/foundation-icons.woff","modified":1},{"_id":"themes/huno/source/fonts/foundation-icons/foundation-icons.ttf","path":"fonts/foundation-icons/foundation-icons.ttf","modified":1},{"_id":"themes/huno/source/fonts/foundation-icons/foundation-icons.svg","path":"fonts/foundation-icons/foundation-icons.svg","modified":1},{"_id":"themes/huno/source/fonts/foundation-icons/foundation-icons.eot","path":"fonts/foundation-icons/foundation-icons.eot","modified":1},{"_id":"themes/huno/source/fonts/foundation-icons/foundation-icons.css","path":"fonts/foundation-icons/foundation-icons.css","modified":1},{"_id":"themes/huno/source/css/uno.css","path":"css/uno.css","modified":1},{"_id":"themes/huno/source/css/highlight.styl","path":"css/highlight.styl","modified":1},{"_id":"themes/huno/source/css/archive.css","path":"css/archive.css","modified":1},{"_id":"themes/huno/source/css/animate.css","path":"css/animate.css","modified":1}],"Cache":[{"_id":"source/CNAME","shasum":"eb48706ab4e6e0bd45a8d3c154be2e94f11390fa","modified":1454567253000},{"_id":"source/_posts/abouts.md","shasum":"8313f0a249c504a3cb87d0fb2eb2d2f62400206e","modified":1454307155000},{"_id":"source/_posts/aop-ios.md","shasum":"8d7af884e9010f5c3c609f45620fe89e1b3ce4ab","modified":1454307155000},{"_id":"source/_posts/cell_height_calulate.md","shasum":"067a753a6168e963156177112709346b88242234","modified":1454307155000},{"_id":"source/_posts/hexo-course.md","shasum":"8f4a1ff3e9879215de5c5b40da7c4b258d4ea7c5","modified":1454307155000},{"_id":"source/_posts/mvp-ios.md","shasum":"427d31ee725338c216ea39398f58fad10a02ef11","modified":1454307155000},{"_id":"source/_posts/qianduan.md","shasum":"00442331beb1095560dc6f3ddcc609c6ea134448","modified":1454307155000},{"_id":"source/_posts/react-native-cut.md","shasum":"1a5a328d9b206acd78b984335d0f0194340b5d43","modified":1454307155000},{"_id":"source/_posts/xcode7-xctest.md","shasum":"9c06fb0726483cafc62d1dbc3fbc18f1d2f06242","modified":1454307155000},{"_id":"source/about/index.md","shasum":"9c7e554533e7b2be02c731914e6f0b8c7b161801","modified":1454307155000},{"_id":"source/_posts/protocol_mvvm.md","shasum":"7f4b2c2b5688b09024047fed900a51c09d12684b","modified":1454307155000},{"_id":"source/notes/index.md","shasum":"96277816fc55e6f623fb286f6466c057b90dab7b","modified":1454307155000},{"_id":"themes/huno/layout/_partials/list-posts.ejs","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1454307155000},{"_id":"themes/huno/README.md","shasum":"69bfcba3e939f48a43ca57ecd1d0019a7c1d9a0d","modified":1454307155000},{"_id":"themes/huno/_config.yml","shasum":"4710d25c21e7a181c84d63b25e0f34f3e68b0164","modified":1454307155000},{"_id":"themes/huno/languages/zh-CN.yml","shasum":"fc0fcc3819c03baeecf2aa51cec08257973288cf","modified":1454307155000},{"_id":"themes/huno/languages/default.yml","shasum":"bddd7fd79412849a52b9a36aae36af111b2db619","modified":1454307155000},{"_id":"themes/huno/layout/_categorys/category.ejs","shasum":"940ecf57e42f5a8eeb1df91cf05de515c3f1936d","modified":1454307155000},{"_id":"themes/huno/layout/_archives/archive.ejs","shasum":"37364bcecae7ece10a77d677d6fcfc4b6117a955","modified":1454569596000},{"_id":"themes/huno/layout/_partials/archive.ejs","shasum":"623dfd767f378a6eb5dde85c3626c20bfbb92bd6","modified":1454307155000},{"_id":"themes/huno/layout/_partials/article.ejs","shasum":"48fc9d13cf35497ada9d15bdd687730664862d99","modified":1454307155000},{"_id":"themes/huno/layout/_partials/duoshuo.ejs","shasum":"7cfe423c088a3bf0565e27a1c17d1b99a260786b","modified":1454307155000},{"_id":"themes/huno/layout/_abouts/about.ejs","shasum":"d2cf666839bb67b7ec9788822c51704e796ef874","modified":1454307155000},{"_id":"themes/huno/layout/_partials/footer.ejs","shasum":"62b030eae0ff08981c0526abbb1be047528e757e","modified":1454307155000},{"_id":"themes/huno/layout/_partials/disqus.ejs","shasum":"bd16a245cde0e999d5a556ede99ba88304f7fe88","modified":1454307155000},{"_id":"themes/huno/layout/_partials/pagination.ejs","shasum":"9944b0a062747a7d80658b73bd07083031b9aa80","modified":1454307155000},{"_id":"themes/huno/layout/_partials/read-more.ejs","shasum":"95072903d7694117d6d68a87a96206c8b2fc6f5b","modified":1454307155000},{"_id":"themes/huno/layout/_partials/social.ejs","shasum":"af096f9e8f9614f01102260311216228ad643958","modified":1454307155000},{"_id":"themes/huno/layout/_partials/side-panel.ejs","shasum":"68dfee19ec6f9c512763fd02896b01f3c4fc86d5","modified":1454307155000},{"_id":"themes/huno/layout/_scripts/awesome-toc.ejs","shasum":"a292a52c25567b33d169aad939e7c25d05585c10","modified":1454307155000},{"_id":"themes/huno/layout/_scripts/github-repo-widget.ejs","shasum":"ee64a8e431318cb8fb25f59cfeec0def95b58912","modified":1454307155000},{"_id":"themes/huno/layout/_scripts/mathjax.ejs","shasum":"63ca0041968446fa4b91e03c06e64a9ac097cf85","modified":1454307155000},{"_id":"themes/huno/layout/_scripts/site-analytics.ejs","shasum":"b5db1bff79ce369638aadda3d0b28605ed160b4c","modified":1454307155000},{"_id":"themes/huno/layout/_scripts/killie6.ejs","shasum":"007a0f03995e5422e7daf010950bf1f548b551aa","modified":1454307155000},{"_id":"themes/huno/layout/about.ejs","shasum":"35fbeda9c9b4dca152c4bf656af1c6903c578b5e","modified":1454307155000},{"_id":"themes/huno/layout/archive.ejs","shasum":"ce5143d21a5bc721fec6f5c9c39d067f35d0985b","modified":1454307155000},{"_id":"themes/huno/layout/layout.ejs","shasum":"2b36fb8f12fc06e8977860fbda1ccd8b9c4c64a7","modified":1454307155000},{"_id":"themes/huno/layout/index.ejs","shasum":"12c817a875f353c03d8795c2a7b653e4da22c17e","modified":1454307155000},{"_id":"themes/huno/layout/page-archive.ejs","shasum":"ce5523d829c0fdd6a79984fcf15e33572a220df9","modified":1454307155000},{"_id":"themes/huno/layout/page.ejs","shasum":"70a50ecf7e1aa9c658212f1e77783dcb287d56a6","modified":1454307155000},{"_id":"themes/huno/layout/post.ejs","shasum":"86c9d13e8abdcff4d368e34595e2d2f11f37e9d4","modified":1454307155000},{"_id":"themes/huno/layout/category.ejs","shasum":"5d22fede82b457882753128fa34d5c0d4fb627b8","modified":1454307155000},{"_id":"themes/huno/layout/tag.ejs","shasum":"fefa03bed577cae2e1aac19bd5d30c5034f453a0","modified":1454307155000},{"_id":"themes/huno/source/css/uno.css","shasum":"a6434ee57df1740b4bac1dab31f7872489654182","modified":1454307155000},{"_id":"themes/huno/source/css/archive.css","shasum":"21e6270e87c44c5ed8f00e164b8ab0177272c3fe","modified":1454307155000},{"_id":"themes/huno/source/css/animate.css","shasum":"651fcf046b1bd2bff3ab4cb8947ff7fe058de373","modified":1454307155000},{"_id":"themes/huno/source/css/highlight.styl","shasum":"92eabbf94e7a06e968c356bedf4adb04700f1c2e","modified":1454307155000},{"_id":"themes/huno/source/fonts/foundation-icons/foundation-icons.css","shasum":"426036f1d554b9dffae8b38acc36cade40d9521a","modified":1454307155000},{"_id":"themes/huno/source/fonts/foundation-icons/foundation-icons.eot","shasum":"d584172686583fd510d8f04cf21e6e77fce51435","modified":1454307155000},{"_id":"themes/huno/source/fonts/foundation-icons/foundation-icons.ttf","shasum":"4b2bce6c792493a4a5716b6fec2dbefe89492c3f","modified":1454307155000},{"_id":"themes/huno/source/images/2015-12-16/MVP/ios_mvc.png","shasum":"cac3906e94f0918f9c864b576b4957abdcce7e0a","modified":1454307156000},{"_id":"themes/huno/source/images/2015-12-16/MVP/mvp.png","shasum":"0dc7fbb3bd0bfce5460c0a88bfa6c2e4e7205d81","modified":1454307156000},{"_id":"themes/huno/source/images/2015-12-16/MVP/mvc.png","shasum":"1926fdb104019d4798b50a6cd3c7609a2773ed25","modified":1454307156000},{"_id":"themes/huno/source/images/2015-12-16/MVP/service.png","shasum":"f5364f7526bb63de768d3b0cc3d43fc27bbb801f","modified":1454307156000},{"_id":"themes/huno/source/images/2015-12-16/post-react-native-cut/ReactNative-Starter.png","shasum":"2d45af23feb1e6c25fccb7ac9f66dd6c75842f6e","modified":1454307156000},{"_id":"themes/huno/source/images/2015-12-16/post-react-native-cut/react-native-00.png","shasum":"66011aafb8807ab1bd4d40fdda5ba1e60df624b3","modified":1454307156000},{"_id":"themes/huno/source/images/2015-12-16/post-react-native-cut/react-native-03.png","shasum":"9e50d4bd7ac6450bd65f7c4d024e7185719d1092","modified":1454307156000},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/end.gif","shasum":"9520790e18107ce2e1f29a502f4e01f592e1459f","modified":1454307156000},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-UItestIB.jpeg","shasum":"ae17be7b0bc873fd4cb60bf68f712793470f6dc5","modified":1454307156000},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-createUITestPro.jpeg","shasum":"ba2569e1be50d4fdff21133cc73b877bddbac68e","modified":1454307156000},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-createUITestSelectItem.jpeg","shasum":"daa94af49c0c0b86ec02abaff4b1be7a3eb036ca","modified":1454307156000},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-testsucc.png","shasum":"a04d44973df83a2ba494ddafbf7b3415b6060554","modified":1454307156000},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-uitestdemo.gif","shasum":"097da9782f72b13ad41d7a20e82dc8a7bff72022","modified":1454307156000},{"_id":"themes/huno/source/images/avatar.png","shasum":"0905fd7f284e43fbaaefd54fdc6ed3041f4f5558","modified":1454307156000},{"_id":"themes/huno/source/images/sina-weibo.svg","shasum":"55239d0f2f4ad805f281f8ba0a2b79cd92cbfb64","modified":1454307156000},{"_id":"themes/huno/source/images/sina-weibo.png","shasum":"2a7ec82e69f6ed291a923196140168517c1a4016","modified":1454307156000},{"_id":"themes/huno/source/images/totop.png","shasum":"4f6cb11941e5a72b03cb00cf9d9d55671b4310eb","modified":1454307156000},{"_id":"themes/huno/source/js/jquery.githubRepoWidget.min.js","shasum":"94a141fa474ec5022f7c397b4fd3ff92405ab755","modified":1454307156000},{"_id":"themes/huno/source/js/main.js","shasum":"ea5c7e6f0b3afeb54503e7e5f8186817835fcbbe","modified":1454307156000},{"_id":"themes/huno/source/js/awesome-toc.min.js","shasum":"b4d0f2a33f8340eb2543e8b2cee0dfd745cfb54a","modified":1454307156000},{"_id":"themes/huno/source/js/scale.fix.js","shasum":"ce593f56728cc1cedf2e513cb20b926de3b05e07","modified":1454307156000},{"_id":"themes/huno/source/fonts/foundation-icons/foundation-icons.woff","shasum":"7f2f3c55c2de192387c351b995115f6b79e09173","modified":1454307155000},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-coverage.png","shasum":"cb9b2346e0abc06b44b3957eff06ce8354b4dcaa","modified":1454307156000},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-coverageItem.png","shasum":"1910308040547aac5b4246adf8f296b9bba8db94","modified":1454307156000},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-editschem.png","shasum":"1a7d16ce4e2c1a437ebea46c2c57457c94f6c67a","modified":1454307156000},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-testlog.png","shasum":"98ea34fdf17d02087bf3c16626662932164eda10","modified":1454307156000},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-selectschem.png","shasum":"957b6a500ef742ab70c78d3ff3c7ca8dbe98b11c","modified":1454307156000},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-createpro.png","shasum":"6e416e0f299bbf480220ac57af4d01256bdd5adc","modified":1454307156000},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-uitestStart.jpeg","shasum":"fb81eb8ac0efdb491fa24e6c908f056f4510f556","modified":1454307156000},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-uitestcode.jpeg","shasum":"cf5a6a50fcce88689f23748c1d67e9c34968e7a4","modified":1454307156000},{"_id":"themes/huno/source/js/jquery.min.js","shasum":"8b6babff47b8a9793f37036fd1b1a3ad41d38423","modified":1454307156000},{"_id":"themes/huno/source/fonts/foundation-icons/foundation-icons.svg","shasum":"bdca38f453f9935203fe8cd071e97d7f8576e0be","modified":1454307155000},{"_id":"themes/huno/source/images/2015-12-16/post-react-native-cut/react-native-01.png","shasum":"b527bbbda4e1a59c94be479ec674d263269f697c","modified":1454307156000},{"_id":"themes/huno/source/images/2015-12-16/post-react-native-cut/termial.png","shasum":"941b59d4f656d63fa709e82d58c4af7b4315ec98","modified":1454307156000},{"_id":"themes/huno/source/images/2015-12-16/post-xctest-case/xctest-case-trackDao.png","shasum":"33f2e60cf7d702263783457f024e6ebf9dbe4a7e","modified":1454307156000},{"_id":"themes/huno/source/images/background-cover.jpg","shasum":"25acccd9451cf55ab0c49c13f680eee7bf664736","modified":1454307156000},{"_id":"themes/huno/source/images/background-cover3.jpg","shasum":"c1940198940e09aed4f472f0098c1ab881b7e5ab","modified":1454307156000},{"_id":"themes/huno/source/images/background-cover4.jpg","shasum":"28865960920decf12045640ba22ab9a173c35f26","modified":1454307156000},{"_id":"themes/huno/source/images/2015-12-16/post-react-native-cut/react-native-02.png","shasum":"7d97c507db9afd46af2d9134e05fdf7d79957dd0","modified":1454307156000},{"_id":"themes/huno/source/images/2015-12-16/hexo/hexo.png","shasum":"675d956ff8c24c220d183ed956623f6cf622cbd1","modified":1454307156000},{"_id":"themes/huno/source/images/background-cover1.jpg","shasum":"a60030ca18f6937c08fab948344c1c5202556579","modified":1454307156000},{"_id":"themes/huno/source/images/12669076,2560,1600.jpg","shasum":"6d5603fed3eeb2c207894e4fb5d0a89bc2388198","modified":1454307156000},{"_id":"themes/huno/source/images/background-cover222.jpg","shasum":"08162d5ddd6c081f2713bfd10261e62f0752a600","modified":1454307156000},{"_id":"themes/huno/source/images/background-cover副本.jpg","shasum":"08162d5ddd6c081f2713bfd10261e62f0752a600","modified":1454307156000},{"_id":"themes/huno/source/images/background-cover5.jpg","shasum":"6af57089e3f07b85981548192855cc85e0386753","modified":1454307156000},{"_id":"themes/huno/source/images/background-cover6.jpg","shasum":"123fc36c05ca5362a2ab9dfc052781094fbbfab3","modified":1454307156000},{"_id":"themes/huno/demo.gif","shasum":"cf6121b4aa0f3b07a2f919099942d97206202aa8","modified":1454307155000}],"Category":[],"Data":[],"Page":[{"title":"notes","date":"2016-01-03T12:40:19.000Z","_content":"\n\n<div>\n          <script type=\"text/javascript\">\n          (function(){document.write(unescape('%3Cdiv id=\"bdcs\"%3E%3C/div%3E'));var bdcs = document.createElement('script');bdcs.type = 'text/javascript';bdcs.async = true;bdcs.src = 'http://znsv.baidu.com/customer_search/api/js?sid=11069060846184447107' + '&plate_url=' + encodeURIComponent(window.location.href) + '&t=' + Math.ceil(new Date()/3600000);var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(bdcs, s);})();\n          </script>\n</div>","source":"notes/index.md","raw":"title: notes\ndate: 2016-01-03 20:40:19\n---\n\n\n<div>\n          <script type=\"text/javascript\">\n          (function(){document.write(unescape('%3Cdiv id=\"bdcs\"%3E%3C/div%3E'));var bdcs = document.createElement('script');bdcs.type = 'text/javascript';bdcs.async = true;bdcs.src = 'http://znsv.baidu.com/customer_search/api/js?sid=11069060846184447107' + '&plate_url=' + encodeURIComponent(window.location.href) + '&t=' + Math.ceil(new Date()/3600000);var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(bdcs, s);})();\n          </script>\n</div>","updated":"2016-02-01T06:12:35.000Z","path":"notes/index.html","comments":1,"layout":"page","_id":"cik7x6pl00000ivc3yn7g611z"},{"title":"about","date":"2016-01-03T12:39:28.000Z","_content":"","source":"about/index.md","raw":"title: about\ndate: 2016-01-03 20:39:28\n---\n","updated":"2016-02-01T06:12:35.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cik7x6plu0001ivc3xr5b3hkh"}],"Post":[{"layout":"post","title":"Xcode 7智能测试化工具XCTest学习","subtitle":"Xcode 7智能测试化工具XCTest学习","date":"2015-11-28T16:00:00.000Z","header-img":"img/post-bg-alitrip.jpg","description":"单元测试在程序里面可以理解一个模块一个方法，在每个可能存在的模块都进行测试，确保每个模块都没有问题，从而提高整体程序的质量 谈的单元测试此处不免要聊起一个新的概念，代码覆盖率，最早最一次听到这个词的时间觉得很可笑(难道这个也需要统计)，故名思义 代码覆盖率 ＝ 实际执行的代码行数 / 整个工程总代码行数，直白来讲就是这样一个数值，上述谈过，单元测试的目的除了讲程序分成各个最小的单元独立去测试确保正确以外，还有一个就是代码覆盖率问题，如果说发到线上的产品有相当一部分代码从来都没有执行过，这个问题是相当危险的下面说下Xcode中代码覆盖率的问题，Xcode7以前代码覆盖率统计比较麻烦，Xcode7以后Apple推出了更为人性化的工具","_content":"\n\n\n## 1. 单元测试简介\n\n####  1.1、Unit Testing: 单元测试\n\n 测试这个词很容易理解，那么什么是单元(Unit)呢？一个单元指的就是应用程序中可以测试的最小单元。一组源代码可以测试，一般要求有明确的输入与输出。因此一般来说源代码中明确的包含输入输出的每一个方法被认为一个测试的单元(一个case)。注意，这里的输出并不局限于方法的返回值对输入参数的改变，也包括方法在执行过程中改变的任何数据。\n\n单元测试在程序里面可以理解一个模块一个方法，在每个可能存在的模块都进行测试，确保每个模块都没有问题，从而提高整体程序的质量。\n\n####  1.2、单元测试的目的\n单元测试的目的是将程序中所有的源代码，隔离成最小的可测试单元，以确保每个单元的正确性，如果每个单元都能保证正确，就能保证应用程序整体相当程度的正确性。另一方面测试脚本本身就是被测试代码的实际使用代码，这对于开发者理解被测试单元的使用是用帮助的。\n\n测试是分黑盒测试和白盒测试(概念此处不在解释)，单元测试其实就是一种白盒测试，开发者对现有已经实现的模块自己写对应测试脚本进行测试，这中间还包含测试用例的设计。相对来说还是由开发者自己来完成白盒测试，然后在交由测试团队进行黑盒测试，这样也更加有助于提升测试流程的完整性，最终提高产品的质量。\n\n 单元测试的内容：\n \n> * 单元测试的测试目的\n> * 模块接口测试\n> * 局部数据结构测试\n> * 路径测试\n> * 错误处理测试\n> * 边界测试\n\n在现有的开发工作中，我们一般都会忽略掉单元测试的重要性，功能开发完成以后开发者拿到现有的测试用例，直接针对每条用例进行手工的测试，测试通过就进行提测，之后测试人员还是重复手工测试的流程、数据的mock、专项测试等，这样以来白盒测试的流程有时间份量会变的很低，开发人员不知道自己模块代码的覆盖路问题，更多的时间可能某些代码一直到到上线都从来没有跑过，以至于到了真实环境下会产生一些意想不到的问题，这样以来风险极高，整体来说单元测试还是至关重要的。\n\n下面介绍一下Xcode7 中现有的一些测试工具：\n\n\n## 2. Xcode7中的UnitTest\n\n####  2.1、XCTest介绍\n\n本文主要基本Xcode7来讲解，至于xcode 新功能的历史各位自己去趴去，此处只讲解如何使用，废话少说，下面直接入正题。\n\n最新的Xcode7中是包含了UITest  UnitTest工具的，这个可以在你创建工程的时间勾选对应的选项，也可以直接通过addTarget的形式来完成，\n\n#####  2.1、XCTestCase简介\n如果项目创建的时间勾选了UnitTest(从名字上看就是Apple提供的官方的一个单元测试工具) ，我们可以看到工程里面是多了一个目录，默认多了一个类， 如图：\n\n![选择XCTest](/images/2015-12-16/post-xctest-case/xctest-case-createpro.png)\n\n\nXCTest时Apple官方提供一个测试工具，一个内置的测试框架，从工程里面可以看到，一个“应用名称”的group，我们直接可以使用commond+R 来远行，一个测试的target我们可以使用commond+U来远行测试target,在测试target的目录下会有一个默认的“应用名称”＋Test的类，这个类只有.m没有.h,继承于XCTestCase，使用commond+U即可运行。\n\n默认测试类里面有以下方法：\n\n```\n//方法在XCTestCase的测试方法调用之前调用，可以在测试之前创建在test case方法中需要用到的一些对象等\n- (void)setUp ;\n//当测试全部结束之后调用tearDown方法，法则在全部的test case执行结束之后清理测试现场，释放资源删除不用的对象等\n- (void)tearDown ;\n//测试代码执行性能\n- (void)testPerformanceExample \n\n```\n\n####  2.2、XCTestCase使用\n\nXCTestCase的初始化不是用户控制的,开发者无需手动针对XCTestCase的subclass进行 alloc 、init或者调用静态方法初始化的操作，针对一个功能块的单元测试(针对某个class)，只需要单独给为这个类创建一个继承于XCTestCase，在这个文件内实现上述基本函数以后(一半系统会默认创建这三个函数)，其实的逻辑只需要开发者自行定义以“test\"开头的函数，然后在内部实现自己针对某个函数、返回数值结果、操作等的测试脚本即可，commond+U执行的时间，单元测试会自动执行这些test打头的函数，当函数头上出现蓝色的标记则表明测试通过，否则直接报红色错误。\n\nXCTest测试范畴：\n\n> * 基本逻辑测试处理测试\n> * 异步加载数据测试\n> * 数据mock测试\n\n##### XCTest常用基本测试工具\nXCTest常用的一些判断工具都是以XCT开头的，如：\n\n```\n  //断言,最基本的测试，如果expression为true则通过，否则打印后面格式化字符串\n  XCTAssert(expression, format...)\n  \n  //Bool测试:  \n  XCTAssertTrue(expression, format...)\n  XCTAssertFalse(expression, format...)\n  \n  //相等测试\n  XCTAssertEqual(expression1, expression2, format...)\n  XCTAssertNotEqual(expression1, expression2, format...)\n  \n  //double float 对比数据测试使用\n  XCTAssertEqualWithAccuracy(expression1, expression2, accuracy, format...)\n  XCTAssertNotEqualWithAccuracy(expression1, expression2, accuracy, format...)\n  \n  //Nil测试，XCTAssert[Not]Nil断言判断给定的表达式值是否为nil\n  XCTAssertNil(expression, format...)\n  XCTAssertNotNil(expression, format...)\n  \n  //失败断言     \n  XCTFail(format...)\n  \n```\n\n##### XCTest异步测试\n\nXcode单元测试中加入的最令人兴奋的功能也许就是类XCTestExpression类带入的异步测试了。现在测试可以等待指定长度的时间，一直到某些条件符合的时候在开始测试。而不用再写很多的GCD代码控制。\n\n要使用异步测试，首先用方法expectationWithDescription创建一个expection\n\n```\nlet expectation = expectationWithDescription(\"...\")\n```\n\n之后，在方法的最后添加方法waitForExpectationsWithTimeout，指定等待超时的时间和指定时间内条件无法满足时执行的closure。\n\n```\nwaitForExpectationsWithTimeout(10) { (error) in\n    // ...\n}\n```\n\n剩下的就是在异步测试剩下的回调函数中告诉expectation条件已经满足。\n\nexpectation.fulfill()\n如果在测试中有多个expectation，则每个expectation都必须fulfill，否则测试不通过。\n\n```\n- (void)testFetchRequestWithMockedManagedObjectContext\n{\n    MockNSManagedObjectContext *mockContext = [[MockNSManagedObjectContext alloc] initWithConcurrencyType:0x00];\n    \n    let mockContext = MockNSManagedObjectContext()\n    NSFetchRequest * fetchRequest = [[NSFetchRequest alloc] initWithEntityName:@\"User\"];\n    let fetchRequest = NSFetchRequest(entityName: \"User\")\n    fetchRequest.predicate = [NSPredicate predicateWithFormat:@\"email ENDSWITH[cd] apple.com\"];\n    fetchRequest.predicate = NSPredicate(format: \"email ENDSWITH[cd] %@\", \"apple.com\")\n    fetchRequest.resultType = NSDictionaryResultType;\n    fetchRequest.resultType = NSFetchRequestResultType.DictionaryResultType\n    var error: NSError?\n    NSError *error = nil;\n    NSArray *results = [mockContext executeFetchRequest:fetchRequest error:&error];\n    let results = mockContext.executeFetchRequest(fetchRequest, error: &error)\n    XCTAssertNil(error, @\"error应该为nil\");\n    XCTAssertEqual(results.count, 2, @\"fetch request应该只返回一个结构\");\n    NSDictionary * result = results[0];\n    XCTAssertEqual(result[@\"name\"], @\"张三\", @\"name应该是张三\");\n    NSLog(@\"email : %@\",result[@\"email\"]);\n    XCTAssertEqual(result[@\"email\"], @\"zhangsaan@apple.com\", @\"email应该是zhangsan@apple.com\");\n    \n}\n\n\n```\n\n##### XCTest Mock\n数据mock\n\n####  2.3、Xcode7 Code Coverage介绍\n\n谈的单元测试此处不免要聊起一个新的概念，代码覆盖率，最早最一次听到这个词的时间觉得很可笑(难道这个也需要统计)，故名思义 代码覆盖率 ＝ 实际执行的代码行数 / 整个工程总代码行数，直白来讲就是这样一个数值，上述谈过，单元测试的目的除了讲程序分成各个最小的单元独立去测试确保正确以外，还有一个就是代码覆盖率问题，如果说发到线上的产品有相当一部分代码从来都没有执行过，这个问题是相当危险的(问题大家可以各自猜测，相信这个问题不是很陌生)。\n\n##### Code Coverage工具使用\n下面说下Xcode中代码覆盖率的问题，Xcode7以前代码覆盖率统计比较麻烦，Xcode7以后Apple推出了更为人性化的工具，既然学习就学习最为流行的，过去的麻烦就当随之过去吧，何必留在痛苦回忆里(有兴趣的可以参考 [Apple DOC](https://developer.apple.com/library/ios/qa/qa1514/_index.html)  [Xcode代码覆盖率测试工具](http://www.cocoachina.com/ios/20150915/13163.html))\n\n\n**注： 传统统计覆盖率的方法会做一部分Xcode配置，最终打出一个叫“插庄包”的包，这个包仅为做统计使用，如果要上生产环境，切忌将配置一定要关掉在从新打包上传，否则后患无穷...**\n\nXcode7 提供了一个内置的Code Coverage工具组件，废话不说，下面看使用方法：\n\n1、首先需要在product->scheme->Edit Scheme里面将Code Coverage模式打开，选中为debug模式，如图:\n\n![Edit Scheme](/images/2015-12-16/post-xctest-case/xctest-case-selectschem.png)\n\n![Edit Scheme](/images/2015-12-16/post-xctest-case/xctest-case-editschem.png)\n\n2、打开Code Coverage模式之后，打开某个测试类，commond+U 运行，如果测试通过，测试脚本的函数头上会出现一个绿色的标志(相反如何哪一个方法测试没有通过，则会提示一个红色错误)，如下:\n\n![Edit Scheme](/images/2015-12-16/post-xctest-case/xctest-case-testsucc.png)\n\n3、打开Xcode左边窗口的Report Navigator，找到 Project Log,选择最近一次的log选项，最近一次是刚才的一个Test Log,选择中这个Log实例，可以看到一下界面,\n如图:\n\n![Edit Scheme](/images/2015-12-16/post-xctest-case/xctest-case-testlog.png)\n\n然后在tab中选中 Coverage，此时你可以看到大致的代码执行覆盖情况，如果指示条是满的则代表该类代码全部跑过一遍。\n\n![xctest-case-coverage.png](/images/2015-12-16/post-xctest-case/xctest-case-coverage.png)\n\n4、双击你想要查看的类，此处选择查看UATrackDao，打开后既可以看到刚刚的测试中有哪些代码是执行过的，那些代码时未执行的，橘黄色的代表还未执行的，执行过的每一行后面会有一个序号代表这行代码在刚才的测试过程中执行的次数。如果有未执行的，可根据具体的情况调整对应的测试脚本，继续测试，最终确保每一行代码都能正确执行,如图:\n\n![Edit Scheme](http://ccguo.gitcafe.io/blog/2015-12-16/post-xctest-case/xctest-case-coverageItem.png)\n\n![Edit Scheme](/images/2015-12-16/post-xctest-case/xctest-case-trackDao.png)\n\n## 3. Xcode7中的UITest\n\n#### UnitTest简介\n\n任何软件开发中，自动化UI测试都是很重要的(UI自动化测试的好处此处就不再多说了),iOS平台在以往是通过UIAutomation来完成自动化UI测试的，它的测试用例是javascript写的(Instruments中提供了该功能)，这个过程深奥繁琐，需要自行编写对应的测试脚本，速度慢，学习成本高(关于Automation自动化测试概念大家可以查看相关的资料，Automation自动化测试在各大平台都有应用，在大型的软件开发测试过程的确的确可以节省大量的手工测试人员，大大提高软件测试的成本与效率，在最新Xcode7本文推荐使用Apple提供的最新的工具UITest)。\n\nApple在Xcode 6中又新增了UnitTest之外，到了Xcode 7 Apple从新提供了一个新的框架UITest，这个主要是用来测试UI的，UnitTest涌来测试功能逻辑代码，UITest专门用来测试UI。\n\nXcode 7已经集成了UITest，UITest允许你找到UI元素并与之交户，还能检查UI的属性和状态，并且UITest也已经集成在Xcode 的测试报告了，可以和单元测试一起执行，和UnitTest一样我们可以在检查UI的时间执行断言。\n\n创建UITest target，同样会生成一个“项目名称”＋UITest的group，UITest target可以在创建工程的时间勾选，也可以在工程中手动添加，在 “项目名称”＋UITest 分组下，我们可以看到系统会帮我们默认生成一个UI测试类，这个类也同样是继承于XCTestCase的。由此可见，在iOS中无论是单元测试还是UI测试，都是基于XCTestCase的。\n\n#### UnitTest UI测试\n\n创建模态视图，我们选择从第一个VC通过点击按钮的形式push到第二个VC\n\n![Edit Scheme](/images/2015-12-16/post-xctest-case/xctest-case-UItestIB.jpeg)\n\n创建UITest target，我们对上述UI进行测试 如图选项:\n\n![Edit Scheme](/images/2015-12-16/post-xctest-case/xctest-case-createUITestSelectItem.jpeg)\n\n![Edit Scheme](/images/2015-12-16/post-xctest-case/xctest-case-createUITestPro.jpeg)\n\n\n打开UATrackDemoUiTest.m,创建 - (void)testUI,同时将光标留在函数内\n\n![Edit Scheme](/images/2015-12-16/post-xctest-case/xctest-case-uitestStart.jpeg)\n\n点击下面的红色按钮，开始recorder操作，程序运行起来后，点击界面上的按钮，程序会push到一个新的页面，这个时间会看到到刚才的鼠标光标处自动生成了一部分代码，重复操作，每次都会生成新的代码,如图：\n\n![Edit Scheme](/images/2015-12-16/post-xctest-case/xctest-case-uitestcode.jpeg)\n\n\n从新点击小红点按钮，此时结束recorder操作，commond+U 运行测试，此时刚才的一连串动作会一步一步连续执行下来:\n\n![Edit Scheme](/images/2015-12-16/post-xctest-case/end.gif)\n\n此处声明: 第一次点击红色的recorder按钮，然后手动操作会自动生成测试脚本，第二次commond+U是进行测试UI\n\n##### UnitTest工具拓展\n\nXCTest一共提供了三种UI测试对象\n\n> * XCUIApplication   当前测试应用target\n> * XCUIElementQuery   定位查询当前UI中xctuielement的一个类\n> * XCUIElement   UI测试中任何一个item项都被抽象成一个XCUIElement类型\n\n当我们获取了录制生成的代码以后，根据UITest提供的三种对象，我可以在此来对测试代码进行修改，调试\nUITest中同样适用以下断言等：\n\n```\n\n  XCTAssert(expression, format...)\n  \n  //Bool测试:  \n  XCTAssertTrue(expression, format...)\n  XCTAssertFalse(expression, format...)\n  \n  //相等测试\n  XCTAssertEqual(expression1, expression2, format...)\n  XCTAssertNotEqual(expression1, expression2, format...)\n  \n  //double float 对比数据测试使用\n  XCTAssertEqualWithAccuracy(expression1, expression2, accuracy, format...)\n  XCTAssertNotEqualWithAccuracy(expression1, expression2, accuracy, format...)\n  \n  //Nil测试，XCTAssert[Not]Nil断言判断给定的表达式值是否为nil\n  XCTAssertNil(expression, format...)\n  XCTAssertNotNil(expression, format...)\n  \n  //失败断言     \n  XCTFail(format...)\n.....\n\n\n```\n\n关于Xcode 7 UnitTest的问题就讲到此处，希望有兴趣的同学大家共同交流...\n\n\n## 4. 小结\n\n#### 1.总结现有问题，分享心得\nXcode6的内置工具终于足够的好了。也就是说即使是很大的APP也没有必要为了单元测试的代码覆盖率而排斥Xcode内置的测试工具。无论什么样的测试，XCTest的各种断言、expectation和性能测试都足够应对。但是无论多好的工具，都需要用好才行。\n\n如果你在测试iOS或者OS X的APP，开始为自动添加的测试类添加一些断言并按下Command+U。你一定会发现感觉这些工具让你的测试方便不少 。\n\n\n\n\n\n[WWDC2015 What's New in Xcode ](https://developer.apple.com/videos/play/wwdc2015-104/)\n[WWDC2015 UI Testing in Xcode ](https://developer.apple.com/videos/play/wwdc2015-406/)\n[WWDC2015 Testing in Xcode 6 ](https://developer.apple.com/videos/play/wwdc2014-414/)\n[Mattt Thompson Blog](http://nshipster.com/xctestcase)\n[使用Xcode自带的单元测试](http://www.mincoder.com/article/3650.shtml)\n[method-swizzling](http://nshipster.com/method-swizzling/)\n[Parse 开源代码](https://github.com/ParsePlatform/Parse-SDK-iOS-OSX)","source":"_posts/xcode7-xctest.md","raw":"---\nlayout:     post\ntitle:      \"Xcode 7智能测试化工具XCTest学习\"\nsubtitle:   \"Xcode 7智能测试化工具XCTest学习\"\ndate:       2015-11-29\nheader-img: \"img/post-bg-alitrip.jpg\"\ndescription: \"单元测试在程序里面可以理解一个模块一个方法，在每个可能存在的模块都进行测试，确保每个模块都没有问题，从而提高整体程序的质量\n谈的单元测试此处不免要聊起一个新的概念，代码覆盖率，最早最一次听到这个词的时间觉得很可笑(难道这个也需要统计)，故名思义 代码覆盖率 ＝ 实际执行的代码行数 / 整个工程总代码行数，直白来讲就是这样一个数值，上述谈过，单元测试的目的除了讲程序分成各个最小的单元独立去测试确保正确以外，还有一个就是代码覆盖率问题，如果说发到线上的产品有相当一部分代码从来都没有执行过，这个问题是相当危险的下面说下Xcode中代码覆盖率的问题，Xcode7以前代码覆盖率统计比较麻烦，Xcode7以后Apple推出了更为人性化的工具\"\ntags:\n    - iOS\n    - 电子商务\n    - XCTestCase\n---\n\n\n\n## 1. 单元测试简介\n\n####  1.1、Unit Testing: 单元测试\n\n 测试这个词很容易理解，那么什么是单元(Unit)呢？一个单元指的就是应用程序中可以测试的最小单元。一组源代码可以测试，一般要求有明确的输入与输出。因此一般来说源代码中明确的包含输入输出的每一个方法被认为一个测试的单元(一个case)。注意，这里的输出并不局限于方法的返回值对输入参数的改变，也包括方法在执行过程中改变的任何数据。\n\n单元测试在程序里面可以理解一个模块一个方法，在每个可能存在的模块都进行测试，确保每个模块都没有问题，从而提高整体程序的质量。\n\n####  1.2、单元测试的目的\n单元测试的目的是将程序中所有的源代码，隔离成最小的可测试单元，以确保每个单元的正确性，如果每个单元都能保证正确，就能保证应用程序整体相当程度的正确性。另一方面测试脚本本身就是被测试代码的实际使用代码，这对于开发者理解被测试单元的使用是用帮助的。\n\n测试是分黑盒测试和白盒测试(概念此处不在解释)，单元测试其实就是一种白盒测试，开发者对现有已经实现的模块自己写对应测试脚本进行测试，这中间还包含测试用例的设计。相对来说还是由开发者自己来完成白盒测试，然后在交由测试团队进行黑盒测试，这样也更加有助于提升测试流程的完整性，最终提高产品的质量。\n\n 单元测试的内容：\n \n> * 单元测试的测试目的\n> * 模块接口测试\n> * 局部数据结构测试\n> * 路径测试\n> * 错误处理测试\n> * 边界测试\n\n在现有的开发工作中，我们一般都会忽略掉单元测试的重要性，功能开发完成以后开发者拿到现有的测试用例，直接针对每条用例进行手工的测试，测试通过就进行提测，之后测试人员还是重复手工测试的流程、数据的mock、专项测试等，这样以来白盒测试的流程有时间份量会变的很低，开发人员不知道自己模块代码的覆盖路问题，更多的时间可能某些代码一直到到上线都从来没有跑过，以至于到了真实环境下会产生一些意想不到的问题，这样以来风险极高，整体来说单元测试还是至关重要的。\n\n下面介绍一下Xcode7 中现有的一些测试工具：\n\n\n## 2. Xcode7中的UnitTest\n\n####  2.1、XCTest介绍\n\n本文主要基本Xcode7来讲解，至于xcode 新功能的历史各位自己去趴去，此处只讲解如何使用，废话少说，下面直接入正题。\n\n最新的Xcode7中是包含了UITest  UnitTest工具的，这个可以在你创建工程的时间勾选对应的选项，也可以直接通过addTarget的形式来完成，\n\n#####  2.1、XCTestCase简介\n如果项目创建的时间勾选了UnitTest(从名字上看就是Apple提供的官方的一个单元测试工具) ，我们可以看到工程里面是多了一个目录，默认多了一个类， 如图：\n\n![选择XCTest](/images/2015-12-16/post-xctest-case/xctest-case-createpro.png)\n\n\nXCTest时Apple官方提供一个测试工具，一个内置的测试框架，从工程里面可以看到，一个“应用名称”的group，我们直接可以使用commond+R 来远行，一个测试的target我们可以使用commond+U来远行测试target,在测试target的目录下会有一个默认的“应用名称”＋Test的类，这个类只有.m没有.h,继承于XCTestCase，使用commond+U即可运行。\n\n默认测试类里面有以下方法：\n\n```\n//方法在XCTestCase的测试方法调用之前调用，可以在测试之前创建在test case方法中需要用到的一些对象等\n- (void)setUp ;\n//当测试全部结束之后调用tearDown方法，法则在全部的test case执行结束之后清理测试现场，释放资源删除不用的对象等\n- (void)tearDown ;\n//测试代码执行性能\n- (void)testPerformanceExample \n\n```\n\n####  2.2、XCTestCase使用\n\nXCTestCase的初始化不是用户控制的,开发者无需手动针对XCTestCase的subclass进行 alloc 、init或者调用静态方法初始化的操作，针对一个功能块的单元测试(针对某个class)，只需要单独给为这个类创建一个继承于XCTestCase，在这个文件内实现上述基本函数以后(一半系统会默认创建这三个函数)，其实的逻辑只需要开发者自行定义以“test\"开头的函数，然后在内部实现自己针对某个函数、返回数值结果、操作等的测试脚本即可，commond+U执行的时间，单元测试会自动执行这些test打头的函数，当函数头上出现蓝色的标记则表明测试通过，否则直接报红色错误。\n\nXCTest测试范畴：\n\n> * 基本逻辑测试处理测试\n> * 异步加载数据测试\n> * 数据mock测试\n\n##### XCTest常用基本测试工具\nXCTest常用的一些判断工具都是以XCT开头的，如：\n\n```\n  //断言,最基本的测试，如果expression为true则通过，否则打印后面格式化字符串\n  XCTAssert(expression, format...)\n  \n  //Bool测试:  \n  XCTAssertTrue(expression, format...)\n  XCTAssertFalse(expression, format...)\n  \n  //相等测试\n  XCTAssertEqual(expression1, expression2, format...)\n  XCTAssertNotEqual(expression1, expression2, format...)\n  \n  //double float 对比数据测试使用\n  XCTAssertEqualWithAccuracy(expression1, expression2, accuracy, format...)\n  XCTAssertNotEqualWithAccuracy(expression1, expression2, accuracy, format...)\n  \n  //Nil测试，XCTAssert[Not]Nil断言判断给定的表达式值是否为nil\n  XCTAssertNil(expression, format...)\n  XCTAssertNotNil(expression, format...)\n  \n  //失败断言     \n  XCTFail(format...)\n  \n```\n\n##### XCTest异步测试\n\nXcode单元测试中加入的最令人兴奋的功能也许就是类XCTestExpression类带入的异步测试了。现在测试可以等待指定长度的时间，一直到某些条件符合的时候在开始测试。而不用再写很多的GCD代码控制。\n\n要使用异步测试，首先用方法expectationWithDescription创建一个expection\n\n```\nlet expectation = expectationWithDescription(\"...\")\n```\n\n之后，在方法的最后添加方法waitForExpectationsWithTimeout，指定等待超时的时间和指定时间内条件无法满足时执行的closure。\n\n```\nwaitForExpectationsWithTimeout(10) { (error) in\n    // ...\n}\n```\n\n剩下的就是在异步测试剩下的回调函数中告诉expectation条件已经满足。\n\nexpectation.fulfill()\n如果在测试中有多个expectation，则每个expectation都必须fulfill，否则测试不通过。\n\n```\n- (void)testFetchRequestWithMockedManagedObjectContext\n{\n    MockNSManagedObjectContext *mockContext = [[MockNSManagedObjectContext alloc] initWithConcurrencyType:0x00];\n    \n    let mockContext = MockNSManagedObjectContext()\n    NSFetchRequest * fetchRequest = [[NSFetchRequest alloc] initWithEntityName:@\"User\"];\n    let fetchRequest = NSFetchRequest(entityName: \"User\")\n    fetchRequest.predicate = [NSPredicate predicateWithFormat:@\"email ENDSWITH[cd] apple.com\"];\n    fetchRequest.predicate = NSPredicate(format: \"email ENDSWITH[cd] %@\", \"apple.com\")\n    fetchRequest.resultType = NSDictionaryResultType;\n    fetchRequest.resultType = NSFetchRequestResultType.DictionaryResultType\n    var error: NSError?\n    NSError *error = nil;\n    NSArray *results = [mockContext executeFetchRequest:fetchRequest error:&error];\n    let results = mockContext.executeFetchRequest(fetchRequest, error: &error)\n    XCTAssertNil(error, @\"error应该为nil\");\n    XCTAssertEqual(results.count, 2, @\"fetch request应该只返回一个结构\");\n    NSDictionary * result = results[0];\n    XCTAssertEqual(result[@\"name\"], @\"张三\", @\"name应该是张三\");\n    NSLog(@\"email : %@\",result[@\"email\"]);\n    XCTAssertEqual(result[@\"email\"], @\"zhangsaan@apple.com\", @\"email应该是zhangsan@apple.com\");\n    \n}\n\n\n```\n\n##### XCTest Mock\n数据mock\n\n####  2.3、Xcode7 Code Coverage介绍\n\n谈的单元测试此处不免要聊起一个新的概念，代码覆盖率，最早最一次听到这个词的时间觉得很可笑(难道这个也需要统计)，故名思义 代码覆盖率 ＝ 实际执行的代码行数 / 整个工程总代码行数，直白来讲就是这样一个数值，上述谈过，单元测试的目的除了讲程序分成各个最小的单元独立去测试确保正确以外，还有一个就是代码覆盖率问题，如果说发到线上的产品有相当一部分代码从来都没有执行过，这个问题是相当危险的(问题大家可以各自猜测，相信这个问题不是很陌生)。\n\n##### Code Coverage工具使用\n下面说下Xcode中代码覆盖率的问题，Xcode7以前代码覆盖率统计比较麻烦，Xcode7以后Apple推出了更为人性化的工具，既然学习就学习最为流行的，过去的麻烦就当随之过去吧，何必留在痛苦回忆里(有兴趣的可以参考 [Apple DOC](https://developer.apple.com/library/ios/qa/qa1514/_index.html)  [Xcode代码覆盖率测试工具](http://www.cocoachina.com/ios/20150915/13163.html))\n\n\n**注： 传统统计覆盖率的方法会做一部分Xcode配置，最终打出一个叫“插庄包”的包，这个包仅为做统计使用，如果要上生产环境，切忌将配置一定要关掉在从新打包上传，否则后患无穷...**\n\nXcode7 提供了一个内置的Code Coverage工具组件，废话不说，下面看使用方法：\n\n1、首先需要在product->scheme->Edit Scheme里面将Code Coverage模式打开，选中为debug模式，如图:\n\n![Edit Scheme](/images/2015-12-16/post-xctest-case/xctest-case-selectschem.png)\n\n![Edit Scheme](/images/2015-12-16/post-xctest-case/xctest-case-editschem.png)\n\n2、打开Code Coverage模式之后，打开某个测试类，commond+U 运行，如果测试通过，测试脚本的函数头上会出现一个绿色的标志(相反如何哪一个方法测试没有通过，则会提示一个红色错误)，如下:\n\n![Edit Scheme](/images/2015-12-16/post-xctest-case/xctest-case-testsucc.png)\n\n3、打开Xcode左边窗口的Report Navigator，找到 Project Log,选择最近一次的log选项，最近一次是刚才的一个Test Log,选择中这个Log实例，可以看到一下界面,\n如图:\n\n![Edit Scheme](/images/2015-12-16/post-xctest-case/xctest-case-testlog.png)\n\n然后在tab中选中 Coverage，此时你可以看到大致的代码执行覆盖情况，如果指示条是满的则代表该类代码全部跑过一遍。\n\n![xctest-case-coverage.png](/images/2015-12-16/post-xctest-case/xctest-case-coverage.png)\n\n4、双击你想要查看的类，此处选择查看UATrackDao，打开后既可以看到刚刚的测试中有哪些代码是执行过的，那些代码时未执行的，橘黄色的代表还未执行的，执行过的每一行后面会有一个序号代表这行代码在刚才的测试过程中执行的次数。如果有未执行的，可根据具体的情况调整对应的测试脚本，继续测试，最终确保每一行代码都能正确执行,如图:\n\n![Edit Scheme](http://ccguo.gitcafe.io/blog/2015-12-16/post-xctest-case/xctest-case-coverageItem.png)\n\n![Edit Scheme](/images/2015-12-16/post-xctest-case/xctest-case-trackDao.png)\n\n## 3. Xcode7中的UITest\n\n#### UnitTest简介\n\n任何软件开发中，自动化UI测试都是很重要的(UI自动化测试的好处此处就不再多说了),iOS平台在以往是通过UIAutomation来完成自动化UI测试的，它的测试用例是javascript写的(Instruments中提供了该功能)，这个过程深奥繁琐，需要自行编写对应的测试脚本，速度慢，学习成本高(关于Automation自动化测试概念大家可以查看相关的资料，Automation自动化测试在各大平台都有应用，在大型的软件开发测试过程的确的确可以节省大量的手工测试人员，大大提高软件测试的成本与效率，在最新Xcode7本文推荐使用Apple提供的最新的工具UITest)。\n\nApple在Xcode 6中又新增了UnitTest之外，到了Xcode 7 Apple从新提供了一个新的框架UITest，这个主要是用来测试UI的，UnitTest涌来测试功能逻辑代码，UITest专门用来测试UI。\n\nXcode 7已经集成了UITest，UITest允许你找到UI元素并与之交户，还能检查UI的属性和状态，并且UITest也已经集成在Xcode 的测试报告了，可以和单元测试一起执行，和UnitTest一样我们可以在检查UI的时间执行断言。\n\n创建UITest target，同样会生成一个“项目名称”＋UITest的group，UITest target可以在创建工程的时间勾选，也可以在工程中手动添加，在 “项目名称”＋UITest 分组下，我们可以看到系统会帮我们默认生成一个UI测试类，这个类也同样是继承于XCTestCase的。由此可见，在iOS中无论是单元测试还是UI测试，都是基于XCTestCase的。\n\n#### UnitTest UI测试\n\n创建模态视图，我们选择从第一个VC通过点击按钮的形式push到第二个VC\n\n![Edit Scheme](/images/2015-12-16/post-xctest-case/xctest-case-UItestIB.jpeg)\n\n创建UITest target，我们对上述UI进行测试 如图选项:\n\n![Edit Scheme](/images/2015-12-16/post-xctest-case/xctest-case-createUITestSelectItem.jpeg)\n\n![Edit Scheme](/images/2015-12-16/post-xctest-case/xctest-case-createUITestPro.jpeg)\n\n\n打开UATrackDemoUiTest.m,创建 - (void)testUI,同时将光标留在函数内\n\n![Edit Scheme](/images/2015-12-16/post-xctest-case/xctest-case-uitestStart.jpeg)\n\n点击下面的红色按钮，开始recorder操作，程序运行起来后，点击界面上的按钮，程序会push到一个新的页面，这个时间会看到到刚才的鼠标光标处自动生成了一部分代码，重复操作，每次都会生成新的代码,如图：\n\n![Edit Scheme](/images/2015-12-16/post-xctest-case/xctest-case-uitestcode.jpeg)\n\n\n从新点击小红点按钮，此时结束recorder操作，commond+U 运行测试，此时刚才的一连串动作会一步一步连续执行下来:\n\n![Edit Scheme](/images/2015-12-16/post-xctest-case/end.gif)\n\n此处声明: 第一次点击红色的recorder按钮，然后手动操作会自动生成测试脚本，第二次commond+U是进行测试UI\n\n##### UnitTest工具拓展\n\nXCTest一共提供了三种UI测试对象\n\n> * XCUIApplication   当前测试应用target\n> * XCUIElementQuery   定位查询当前UI中xctuielement的一个类\n> * XCUIElement   UI测试中任何一个item项都被抽象成一个XCUIElement类型\n\n当我们获取了录制生成的代码以后，根据UITest提供的三种对象，我可以在此来对测试代码进行修改，调试\nUITest中同样适用以下断言等：\n\n```\n\n  XCTAssert(expression, format...)\n  \n  //Bool测试:  \n  XCTAssertTrue(expression, format...)\n  XCTAssertFalse(expression, format...)\n  \n  //相等测试\n  XCTAssertEqual(expression1, expression2, format...)\n  XCTAssertNotEqual(expression1, expression2, format...)\n  \n  //double float 对比数据测试使用\n  XCTAssertEqualWithAccuracy(expression1, expression2, accuracy, format...)\n  XCTAssertNotEqualWithAccuracy(expression1, expression2, accuracy, format...)\n  \n  //Nil测试，XCTAssert[Not]Nil断言判断给定的表达式值是否为nil\n  XCTAssertNil(expression, format...)\n  XCTAssertNotNil(expression, format...)\n  \n  //失败断言     \n  XCTFail(format...)\n.....\n\n\n```\n\n关于Xcode 7 UnitTest的问题就讲到此处，希望有兴趣的同学大家共同交流...\n\n\n## 4. 小结\n\n#### 1.总结现有问题，分享心得\nXcode6的内置工具终于足够的好了。也就是说即使是很大的APP也没有必要为了单元测试的代码覆盖率而排斥Xcode内置的测试工具。无论什么样的测试，XCTest的各种断言、expectation和性能测试都足够应对。但是无论多好的工具，都需要用好才行。\n\n如果你在测试iOS或者OS X的APP，开始为自动添加的测试类添加一些断言并按下Command+U。你一定会发现感觉这些工具让你的测试方便不少 。\n\n\n\n\n\n[WWDC2015 What's New in Xcode ](https://developer.apple.com/videos/play/wwdc2015-104/)\n[WWDC2015 UI Testing in Xcode ](https://developer.apple.com/videos/play/wwdc2015-406/)\n[WWDC2015 Testing in Xcode 6 ](https://developer.apple.com/videos/play/wwdc2014-414/)\n[Mattt Thompson Blog](http://nshipster.com/xctestcase)\n[使用Xcode自带的单元测试](http://www.mincoder.com/article/3650.shtml)\n[method-swizzling](http://nshipster.com/method-swizzling/)\n[Parse 开源代码](https://github.com/ParsePlatform/Parse-SDK-iOS-OSX)","slug":"xcode7-xctest","published":1,"updated":"2016-02-01T06:12:35.000Z","comments":1,"photos":[],"link":"","_id":"cik7x6pm10002ivc3yw4248l5"},{"title":"React-Native牛刀小试仿京东砍啊砍砍到你手软 ","keywords":"React-Native仿京东砍啊砍 React-Native React iOS facebook推出了ReactNative框架 ","description":"几个月前facebook推出了ReactNative框架，允许开发着使用javascript代码来实现iOS原生的应用，随后十月份安卓版的也相继问世，从此我们可以优雅的Learn once write anywhere,早在几年前开发者就开始使用javascript＋html和PhoneGap来编写各式各样的app了，开发者可以优雅的完成一套js的shell，然后分别在不同的平台下进行打包，最终生成不同平台的app，知识app的最终的展现形式都是html类型的。一度曾经出现webapp是否要取代native，这么多年过去，结果大家也不言而知了。但是reactnative的确是一个很了不起的东西，开发者们都不禁为之欢呼，react native所展现出来的应用实质上是native应用，开发者完成同一套js代码，分别在iOS和安卓平台下分别打包最终分别能映射生成分属不同的安卓原生应用与iOS原生应用，这个优势可能是目前为止被广大开发最为喜欢的地方，一直以来webapp最为大家所诟病的可能就是html的页面永远无法与原生页面的体验相比拟","date":"2015-11-08T16:00:00.000Z","author":"Scenery","_content":"\n\n\n\n### React-Native基础教程\n\n\n*[React-Native基础篇](http://www.cnblogs.com/vczero/p/react-native.html)[作者git](https://github.com/vczero/react-native-lession)\n\n*[React-Native官方文档](http://facebook.github.io/react-native/docs/getting-started.html#content)\n\n*[下载本教程demo](https://github.com/ccguo/HelloWorld)\n\n\n 几个月前facebook推出了React Native框架，允许开发着使用javascript代码来实现iOS原生的应用，随后十月份安卓版的也相继问世，从此我们可以优雅的Learn once, write anywhere...\n\n 早在几年前开发者就开始使用javascript＋html和PhoneGap来编写各式各样的app了，开发者可以优雅的完成一套js的shell，然后分别在不同的平台下进行打包，最终生成不同平台的app，知识app的最终的展现形式都是html类型的。一度曾经出现webapp 是否要取代native ，这么多年过去，结果大家也不言而知了。\n\n 但是react native的确是一个很了不起的东西，开发者们都不禁为之欢呼，react native所展现出来的应用实质上是native应用，开发者完成同一套js代码，分别在iOS和安卓平台下分别打包最终分别能映射生成分属不同的安卓原生应用与iOS原生应用，这个优势可能是目前为止被广大开发最为喜欢的地方，一直以来web app最为大家所诟病的可能就是html的页面永远无法与原生页面的体验相比拟。\n\n\n* 通过react native框架，你可以用JavaScript来编写和运行应用程序逻辑，而UI却可以是真正的本地代码编写的，因此，你完全不需要一个HTML5编写的UI。\n\n* React框架采用了一种新颖的、激进的和高度函数式的方式来构建UI。简单说，应用程序的UI可以简单地用一个函数来表示应用程序当前的状态\n\n    React Native的重点是把React编程模型引进到移动App的开发中去。它的目的并不是跨平台，一次编写到处运行。它真正的目标是“一次学习多处编写”。这是一个重大的区别。本教程只涉及iOS，但一旦你学会了它的思想，你就可以快速将同样的知识应用到Android App的编写上。\n\n    React Native的编写模式更加友好于从事于js的前端开发者，它本身采用了React js的模式，尤其是从事React js的开发人员，只需要熟悉下基本的文档就能瞬间变成一个iOS＋安卓双向通吃的移动专家，React内部引入可一些新的概念，如 DOM和reconciliation，React直接将函数式编程的理念用到了UI层面。\n不过相对来说，OC的开发人员只要熟悉一下基本demo看上几个例子应该就不会有太多问题了，如果之前有过web端开发经验的话相信上手会更快一些。\n\n下面介绍一个简单的demo操作，这个教程一起带你去体验一下京东促销砍啊砍页面的OC->React 移植过程，通过本教程你就可以了解React Native的一些基本开发流程了。\n效果：\n\n![react-native-01.png](/images/2015-12-16/post-react-native-cut/react-native-01.png)\n如果你之前从未写过任何 JavaScript ，别担心；这篇教程带着你一点一点编写代码。React 使用 CSS 属性来定义样式，这些样式通常都很易于阅读和理解，但是如果你想进一步了解，可以参考:。\n要想学习更多内容，请往下看\n\n### 开始\nReact native 关于环境搭建问题此处就不多说了，详情请见[React native基础教程](http://www.cnblogs.com/vczero/p/react-native.html),此处就从我们已经准备好一切前序工作开始，万事具备只欠东风，下面开始:\n\n首先React Native 启动画面开始，创建helloworld工程，启动画面如下：\n\n\n![ReactNative-Starter.png](/images/2015-12-16/post-react-native-cut/ReactNative-Starter.png)\n\n与此同时Xcode还会打开一个终端窗口，并显示如下信息：\n\n\n![termial.png](/images/2015-12-16/post-react-native-cut/termial.png)\n\n这是React Navtive Packager，它在node容器中运行。你待会就会发现它的用处。\n千万不要关闭这个窗口，让它一直运行在后面。如果你意外关闭它，可以在Xcode中先停止程序，再重新运行程序。\n\n>注意:\n>在开始接触具体的代码之前（在本教程中，主要是js代码），我们将推荐 Sublime\n>Text这个文本编辑工具，因为Xcode并不适合用于编写js代码的。当然，你也可以使用 atom, brackets\n>等其他轻量级的工具来替代。\n\nReact Native完成的js完成的代码其实是跑在本地的node下面的，从appdelegate里面可以看到React Native工程会从一个本机地址“http://localhost:8081/index.ios.bundle?platform=ios&dev=true\"读取一个对应的文件，这个文件中就是系统已经自动帮你打包压缩整合过以后的一个js 代码库，接下来React Native引擎会将这个库中的js代码完全的解析、翻译成对应的iOS原生内容，最终以iOS原生UI的形式渲染到桌面上，这个就是React Native整个工作流程。\n\n\n### 你好， React Native\n\n\n在开始编写这个demo之前我们先创建一个简单的Hello World项目，用你喜欢的文本编辑器（例如Sublime Text）打开index.ios.js ，删除所有内容。然后加入以下语句：\n\n```\n'use strict';\n\nvar React = require('react-native');\nvar {\n  AppRegistry,\n  Text,\n  View,\n} = React;\n\nvar HelloWorld = React.createClass({\n  render: function() {\n    return (\n      <View>\n        <View><Text>你好， React Native</Text></View> \n      </View>\n    );\n  }\n});\n\nAppRegistry.registerComponent('HelloWorld', () => HelloWorld);\n\n```\n好了，“Hello World” 的演示就到此为止；接下来我们要编写一个真正的React App了！\n\n### 创建一个导航\n\n这个demo使用了标准的UIKit中的导航控制器来提供”栈式导航体验“。接下来我们就来实现这个功能。\n\n在 index.ios.js, 添加以下代码:\n\n```\nvar Home = require('./cut/Home');\n\nvar HelloWorld = React.createClass(//{\n  render: function() //{\n    return (\n      <NavigatorIOS \n             initialRoute=//{//{title:'首页',\n                        component:Home,\n                      //}//}//>\n    );\n  //}\n//});\n\n```\n\nNavigatorIOS就是React Native中对应的导航视图，我们再次暂时可以理解就是iOS中的UINavigationController,我们在此处创建了一个基于导航的视图控制器，rootViewController对应的页面就是Home。\n\n### 创建rootView Home，添加Home.js 文件，添加代码如下：\n\n\n```\nvar cutList = require('./CutList');\nvar Home = React.createClass({\n\n\trender:function (){\n\t\treturn (\n\t\t\t<TouchableHighlight onPress={()=> this.goToNext()}>\n\t\t\t<View>\n\t\t\t\t<Text}>go to cut</Text>\n\t\t\t</View>\n\t\t\t</TouchableHighlight>\n          );\n\t},\n\n\tgoToNext:function(){\n\t\tthis.props.navigator.push({\n      \t\tcomponent: cutList,\n    });\n\t},\n});\n\n```\n\nHome 我们只放了一个按钮，按钮文字“go to cut”，另外添加了一个点击触摸事件，事件相应题是goToNext:function();   在函数处理事件内部，我们只做了页面的push跳转，目标页面是cutList页面，运行效果如下：\n\n![react-native-00.png](/images/2015-12-16/post-react-native-cut/react-native-00.png)\n### 构建砍啊砍List页面，从网络获取数据，绘制table绑定事件\n\n#### 构造顶部bunner动画图\n\n\n轮播图这个地方采用了React Native的一个第三方库swiper(偷懒了)，\n\n```\nvar Swiper = require('react-native-swiper');\n初始化数据\nvar sliderImgs = [\n    'http://m.360buyimg.com/mobile/s725x175_jfs/t2332/80/701506039/111191/37a1273/5624850bN2469d61f.jpg',\n    'http://m.360buyimg.com/mobile/s725x175_jfs/t2401/354/694665708/117887/3a283185/56248ee2N58518e76.jpg',\n    'http://m.360buyimg.com/mobile/s725x175_jfs/t2506/269/651438394/152836/cf430d42/561f6b3aN80cb83f4.jpg',\n    'http://m.360buyimg.com/mobilecms/s750x410_jfs/t2326/263/687562306/170970/c3f92c7/5620cbddNaa6a2cda.jpg!q70.jpg',\n    'http://m.360buyimg.com/mobilecms/s750x410_jfs/t1891/237/637408747/193879/1acee0f7/5620be19N801621e4.jpg!q70.jpg'\n];\n\n```\n\n```\n//初始化UI\nrender:function () \\\\{\n\t\treturn (\n\t\t\t<View>\n\t\t\t\t<View>\n\t\t\t\t\t<Swiper style=\\\\{styles.wrapper\\\\} showsButtons=\\\\{false\\\\} autoplay=\\\\{true\\\\} height=\\\\{150\\\\} showsPagination={true}>\n        \t\t\t\t<Image style={[styles.slide,]} source={{uri: sliderImgs[0]}}></Image>\n        \t\t\t\t<Image style={[styles.slide,]} source={{uri: sliderImgs[1]}}></Image>\n        \t\t\t\t<Image style={[styles.slide,]} source={{uri: sliderImgs[2]}}></Image>\n        \t\t\t\t<Image style={[styles.slide,]} source={{uri: sliderImgs[3]}}></Image>\n        \t\t\t\t<Image style={[styles.slide,]} source={{uri: sliderImgs[4]}}></Image>\n      \t\t\t\t</Swiper>\n\t\t\t\t</View>\n\n\t\t\t\t<View style={styles.listViewSuper}>\n\t\t\t\t\t<ListView style={styles.tableStyle}\n          \t\t\t\tdataSource = {this.state.dataSource}\n          \t\t\t\trenderRow={this._renderRow.bind(this)}\n                  pageSize={5}\n                  automaticallyAdjustContentInsets={false}//>\n\t\t\t\t</View>\n\t\t\t</View>\n\t\t\t);\n\t},\n\n```\n再次看到render:function()这个函数，应该没那么陌生了吧，暂时可以理解render相当于ViewController中的ViewDidLoad：，我们一般在render里面做一些初始化UI视图的工作，此处我们初始化了swiper和ListView\n\n> swiper\n> * showsButtons        (bool)   是否显示左右切换按钮(显示两个按钮左切 友切)\n> * autoplay                (bool)   是否开启自动播放\n> * height                    (bool)    高度(不解释)\n> * showsPagination  (bool)   是否显示pageControl\n\n\n> ListView\n> * dataSource  绑定数据源\n> * renderRow   cell绑定函数事件(等价于tableView:cellForRowAtIndexPath:)\n> * automaticallyAdjustContentInsets UI布局相关的\n\n#### 初始化数据源\n\n\n```\n\ngetInitialState:function(){\n      var ds = new ListView.DataSource({rowHasChanged: (r1, r2) => r1 !== r2});\n      return {\n        dataSource: new ListView.DataSource({\n        \trowHasChanged: (r1, r2) => r1 !== r2\n        }),\n        loaded:false,\n        currentPage:0,\n      };\n  \t},\n\n```\n\ngetInitialState:function()类似于OC中的init函数，我们一般的习惯喜欢在init函数初始化一个变量等数据，在React Native依旧是这样。\n\n#### 发起网络请求，获取数据，缓存在全局变量List中\n\n\n```\n//定义request url \nvar urlPath = 'http://ccguo.gitcafe.io/cut.json';\nvar CACHE = [];\n\n//componentDidMount:function  系统方法\ncomponentDidMount:function(){\n  \t\tthis.fetchData();\n  \t},\n//自定义函数处理网络获取数据，将数据放入全局变量CACHE\n  \tcache:function(items){\n      for (var i in items) {\n        CACHE.push(items[i]);\n      }\n      this.setState({\n               dataSource: this.state.dataSource.cloneWithRows(CACHE),\n        });\n    },\n\n```\n\n\n```\n//发起 网络请求，获得json\n  \tfetchData:function(){\n      console.log('hello world');\n  \t\tfetch(urlPath)\n  \t\t  .then((response) => response.json())\n        .then((responseText) => {\n          console.log(responseText.cutList);\n          this.cache(responseText.cutList);\n        })\n        .catch((error) => {\n          console.log(error);\n        });\n  \t},\n\n```\n\n\n这个过程模拟了在iOS原生应用里面，初始化网络request，发起网络请求，得到数据，解析数据，然后将数据存入list这一些列操作，其实在js中，js脚本处理json的能力还是很强的，我们再也不需要像OC中哪些objectForKey:的操作了，我们不需要任何MJExtension、JSONModel、 Mantle等一些潜在的工具了，省去了很多的麻烦，我们直接拿到一个json对象，直接对对象进行操作。\n\n另外React的网络请求此处我们只是使用了fetch API[脸谱官方的api](http://facebook.github.io/react-native/docs/network.html#content)(脸谱对于网络请求提供了多种API，如：fetch WebSocket XMLHttpRequest等，具体可参照API)\n\n从代码上看js的链式编程刚看上去有点不太习惯，不过整体使用起来还是比OC中快捷多了，foreach遍历、消息队列进出栈，总之脚步里面省去了以往还不得不在意的好多麻烦，其实这块相对swift而言，新的版本中渐渐的已经得到了部分提升，不过还是要感谢脸谱团队，没有他们，可能还见识不到React的强大。\n\n\n#### 构建cell\n\n\n```\n\t_renderRow:function(data,sectionID,rowID){\n    return (\n      <TouchableHighlight onPress={() => this._pressRow(data,rowID)}>\n      <View style={{backgroundColor:'white'}}>\n        <View style={{width:375,height:150,flexDirection:'row'}}>\n          <View style={{flex:2,borderColor:'green',borderWidth:0.5}}>\n              <Image style={{width:125,height:125,margin:10,borderWidth:0.5,borderColor:'#97979A',borderRadius:2}} source={{uri:data.img}}></Image>\n          </View>\n          <View style={styles.row,{flex:3,borderColor:'blue',borderWidth:0.5}}>\n            <Text style={{marginLeft:20,fontSize:18,color:'black',height:84}}>\n              {rowID+'-'+data.wname}\n            </Text>\n            <Text style={{marginLeft:20,fontSize:14,color:'black',marginTop:10}}>京东价318.00</Text>\n            <View style={{marginLeft:20,width:100,borderWidth:0.5,borderColor:'red',borderRadius:1}}>\n            <Text style={{fontSize:12,color:'red'}}>已有256人砍价</Text>\n            <Text style={{fontSize:17,color:'white',backgroundColor:'red',textAlign:'center'}}>马上砍</Text>\n            </View>\n          </View>\n        </View>\n          <View style={styles.separator} />\n      </View>  \n      </TouchableHighlight>\n      );\n  },\n  _pressRow: function(data,rowID) {\n    this.props.navigator.push({\n      component: detail,\n      passProps: {data: data}\n    });\n  },\n\n```\n\n在上述初始化ListView UI的时间，我们指定了renderRow 对应的action事件，此处我们可以直接在_renderRow:function中构建自己的cell模版，至于React Native中UI的标签基本用法，大家可以去头部基础教程里面找，有点类似于html标签，总之我们在_renderRow:function纯碎是构造cell的代码，这个类似于tableViewCell subClass, cell点击事件我们使用一个TouchableHighlight来代替\n\n```\n <TouchableHighlight onPress={() => this._pressRow(data,rowID)}>\n ....\n </TouchableHighlight>\n```\n\nTouchableHighlight事件处理action同样是一个函数（不解释），在_pressRow事件中我们处理自己的cell点击跳转，顺便插一句下一步的操作，_pressRow（data,rowID）是带有形参的\n另外 ListView renderRow 事件的重载函数，形参类型这个具体参照[脸谱官方的api](http://facebook.github.io/react-native/docs/listview.html#content)\n\n_renderRow:function(data,sectionID,rowID)。\n\n整体运行效果如下：\n\n![react-native-02.png](/images/2015-12-16/post-react-native-cut/react-native-02.png)\n\n#### 处理cell跳转事件\n\n\n```\nvar detail = require('./Detail');\n\n _pressRow: function(data,rowID) {\n    this.props.navigator.push({\n      component: detail,\n      passProps: {data: data}\n    });\n  },\n\n```\n\nReact在处理事件跳转的时间，仍旧采用进栈出栈的形式，这一点和Apple的理念还是类似的。\n\n> * component:     参数对应将要跳转的目标页面，\n> * passProps:     传参字典，内部为key-val形式，相当于一个容器，到了目标页面后可以根据key从容器中取出传递的值。\n\n#### 获取页面跳转时间容器中的值\n\n```\n<Text style={styles.view}>{this.props.data.wname}</Text>\n```\n到了目标页面后，我们直接从props容器直接根据key就能将传递的参数去处，此处我们传递参数的本身是一个json,我们只是讲wname显示到detail页面。\n效果如下：\n\n![react-native-01.png](/images/2015-12-16/post-react-native-cut/react-native-01.png)\n\n### 接下来做什么\n\n\n恭喜你，你的第一个React Native App终于完成了！你可以在GitHub上找到每一个”可运行的“步骤的项目源文件，如果你搞不定的时候它们会非常有用的 :]\n\n如果你来自Web领域，你可能觉得在代码中用JS和React框架建立基于本地化UI的App的界面并实现导航不过是小菜一碟。但如果你主要开发的是本地App，我希望你能从中感受到React Native的优点：快速的App迭代，现代JavaScript语法的支持和清晰的CSS样式规则。\n\n在你的下一个App中，你是会使用这个框架，还是会继续顽固不化地使用Swift和O-C呢？\n\n无论你怎么选择，我都希望你能从本文的介绍中学习到一些有趣的新东西，并把其中一些原理应用到你的下一个项目中。\n\n如果你有任何问题及建议，请参与到下面的讨论中来！","source":"_posts/react-native-cut.md","raw":"---\ntitle:      \"React-Native牛刀小试仿京东砍啊砍砍到你手软 \"\nkeywords : \"React-Native仿京东砍啊砍 React-Native React iOS facebook推出了ReactNative框架 \"\ndescription: \"几个月前facebook推出了ReactNative框架，允许开发着使用javascript代码来实现iOS原生的应用，随后十月份安卓版的也相继问世，从此我们可以优雅的Learn once write anywhere,早在几年前开发者就开始使用javascript＋html和PhoneGap来编写各式各样的app了，开发者可以优雅的完成一套js的shell，然后分别在不同的平台下进行打包，最终生成不同平台的app，知识app的最终的展现形式都是html类型的。一度曾经出现webapp是否要取代native，这么多年过去，结果大家也不言而知了。但是reactnative的确是一个很了不起的东西，开发者们都不禁为之欢呼，react native所展现出来的应用实质上是native应用，开发者完成同一套js代码，分别在iOS和安卓平台下分别打包最终分别能映射生成分属不同的安卓原生应用与iOS原生应用，这个优势可能是目前为止被广大开发最为喜欢的地方，一直以来webapp最为大家所诟病的可能就是html的页面永远无法与原生页面的体验相比拟\"\ndate:       2015-11-9\nauthor:     \"Scenery\"\ntags:\n    - iOS\n    - React-Native\n    - 电子商务\n---\n\n\n\n\n### React-Native基础教程\n\n\n*[React-Native基础篇](http://www.cnblogs.com/vczero/p/react-native.html)[作者git](https://github.com/vczero/react-native-lession)\n\n*[React-Native官方文档](http://facebook.github.io/react-native/docs/getting-started.html#content)\n\n*[下载本教程demo](https://github.com/ccguo/HelloWorld)\n\n\n 几个月前facebook推出了React Native框架，允许开发着使用javascript代码来实现iOS原生的应用，随后十月份安卓版的也相继问世，从此我们可以优雅的Learn once, write anywhere...\n\n 早在几年前开发者就开始使用javascript＋html和PhoneGap来编写各式各样的app了，开发者可以优雅的完成一套js的shell，然后分别在不同的平台下进行打包，最终生成不同平台的app，知识app的最终的展现形式都是html类型的。一度曾经出现webapp 是否要取代native ，这么多年过去，结果大家也不言而知了。\n\n 但是react native的确是一个很了不起的东西，开发者们都不禁为之欢呼，react native所展现出来的应用实质上是native应用，开发者完成同一套js代码，分别在iOS和安卓平台下分别打包最终分别能映射生成分属不同的安卓原生应用与iOS原生应用，这个优势可能是目前为止被广大开发最为喜欢的地方，一直以来web app最为大家所诟病的可能就是html的页面永远无法与原生页面的体验相比拟。\n\n\n* 通过react native框架，你可以用JavaScript来编写和运行应用程序逻辑，而UI却可以是真正的本地代码编写的，因此，你完全不需要一个HTML5编写的UI。\n\n* React框架采用了一种新颖的、激进的和高度函数式的方式来构建UI。简单说，应用程序的UI可以简单地用一个函数来表示应用程序当前的状态\n\n    React Native的重点是把React编程模型引进到移动App的开发中去。它的目的并不是跨平台，一次编写到处运行。它真正的目标是“一次学习多处编写”。这是一个重大的区别。本教程只涉及iOS，但一旦你学会了它的思想，你就可以快速将同样的知识应用到Android App的编写上。\n\n    React Native的编写模式更加友好于从事于js的前端开发者，它本身采用了React js的模式，尤其是从事React js的开发人员，只需要熟悉下基本的文档就能瞬间变成一个iOS＋安卓双向通吃的移动专家，React内部引入可一些新的概念，如 DOM和reconciliation，React直接将函数式编程的理念用到了UI层面。\n不过相对来说，OC的开发人员只要熟悉一下基本demo看上几个例子应该就不会有太多问题了，如果之前有过web端开发经验的话相信上手会更快一些。\n\n下面介绍一个简单的demo操作，这个教程一起带你去体验一下京东促销砍啊砍页面的OC->React 移植过程，通过本教程你就可以了解React Native的一些基本开发流程了。\n效果：\n\n![react-native-01.png](/images/2015-12-16/post-react-native-cut/react-native-01.png)\n如果你之前从未写过任何 JavaScript ，别担心；这篇教程带着你一点一点编写代码。React 使用 CSS 属性来定义样式，这些样式通常都很易于阅读和理解，但是如果你想进一步了解，可以参考:。\n要想学习更多内容，请往下看\n\n### 开始\nReact native 关于环境搭建问题此处就不多说了，详情请见[React native基础教程](http://www.cnblogs.com/vczero/p/react-native.html),此处就从我们已经准备好一切前序工作开始，万事具备只欠东风，下面开始:\n\n首先React Native 启动画面开始，创建helloworld工程，启动画面如下：\n\n\n![ReactNative-Starter.png](/images/2015-12-16/post-react-native-cut/ReactNative-Starter.png)\n\n与此同时Xcode还会打开一个终端窗口，并显示如下信息：\n\n\n![termial.png](/images/2015-12-16/post-react-native-cut/termial.png)\n\n这是React Navtive Packager，它在node容器中运行。你待会就会发现它的用处。\n千万不要关闭这个窗口，让它一直运行在后面。如果你意外关闭它，可以在Xcode中先停止程序，再重新运行程序。\n\n>注意:\n>在开始接触具体的代码之前（在本教程中，主要是js代码），我们将推荐 Sublime\n>Text这个文本编辑工具，因为Xcode并不适合用于编写js代码的。当然，你也可以使用 atom, brackets\n>等其他轻量级的工具来替代。\n\nReact Native完成的js完成的代码其实是跑在本地的node下面的，从appdelegate里面可以看到React Native工程会从一个本机地址“http://localhost:8081/index.ios.bundle?platform=ios&dev=true\"读取一个对应的文件，这个文件中就是系统已经自动帮你打包压缩整合过以后的一个js 代码库，接下来React Native引擎会将这个库中的js代码完全的解析、翻译成对应的iOS原生内容，最终以iOS原生UI的形式渲染到桌面上，这个就是React Native整个工作流程。\n\n\n### 你好， React Native\n\n\n在开始编写这个demo之前我们先创建一个简单的Hello World项目，用你喜欢的文本编辑器（例如Sublime Text）打开index.ios.js ，删除所有内容。然后加入以下语句：\n\n```\n'use strict';\n\nvar React = require('react-native');\nvar {\n  AppRegistry,\n  Text,\n  View,\n} = React;\n\nvar HelloWorld = React.createClass({\n  render: function() {\n    return (\n      <View>\n        <View><Text>你好， React Native</Text></View> \n      </View>\n    );\n  }\n});\n\nAppRegistry.registerComponent('HelloWorld', () => HelloWorld);\n\n```\n好了，“Hello World” 的演示就到此为止；接下来我们要编写一个真正的React App了！\n\n### 创建一个导航\n\n这个demo使用了标准的UIKit中的导航控制器来提供”栈式导航体验“。接下来我们就来实现这个功能。\n\n在 index.ios.js, 添加以下代码:\n\n```\nvar Home = require('./cut/Home');\n\nvar HelloWorld = React.createClass(//{\n  render: function() //{\n    return (\n      <NavigatorIOS \n             initialRoute=//{//{title:'首页',\n                        component:Home,\n                      //}//}//>\n    );\n  //}\n//});\n\n```\n\nNavigatorIOS就是React Native中对应的导航视图，我们再次暂时可以理解就是iOS中的UINavigationController,我们在此处创建了一个基于导航的视图控制器，rootViewController对应的页面就是Home。\n\n### 创建rootView Home，添加Home.js 文件，添加代码如下：\n\n\n```\nvar cutList = require('./CutList');\nvar Home = React.createClass({\n\n\trender:function (){\n\t\treturn (\n\t\t\t<TouchableHighlight onPress={()=> this.goToNext()}>\n\t\t\t<View>\n\t\t\t\t<Text}>go to cut</Text>\n\t\t\t</View>\n\t\t\t</TouchableHighlight>\n          );\n\t},\n\n\tgoToNext:function(){\n\t\tthis.props.navigator.push({\n      \t\tcomponent: cutList,\n    });\n\t},\n});\n\n```\n\nHome 我们只放了一个按钮，按钮文字“go to cut”，另外添加了一个点击触摸事件，事件相应题是goToNext:function();   在函数处理事件内部，我们只做了页面的push跳转，目标页面是cutList页面，运行效果如下：\n\n![react-native-00.png](/images/2015-12-16/post-react-native-cut/react-native-00.png)\n### 构建砍啊砍List页面，从网络获取数据，绘制table绑定事件\n\n#### 构造顶部bunner动画图\n\n\n轮播图这个地方采用了React Native的一个第三方库swiper(偷懒了)，\n\n```\nvar Swiper = require('react-native-swiper');\n初始化数据\nvar sliderImgs = [\n    'http://m.360buyimg.com/mobile/s725x175_jfs/t2332/80/701506039/111191/37a1273/5624850bN2469d61f.jpg',\n    'http://m.360buyimg.com/mobile/s725x175_jfs/t2401/354/694665708/117887/3a283185/56248ee2N58518e76.jpg',\n    'http://m.360buyimg.com/mobile/s725x175_jfs/t2506/269/651438394/152836/cf430d42/561f6b3aN80cb83f4.jpg',\n    'http://m.360buyimg.com/mobilecms/s750x410_jfs/t2326/263/687562306/170970/c3f92c7/5620cbddNaa6a2cda.jpg!q70.jpg',\n    'http://m.360buyimg.com/mobilecms/s750x410_jfs/t1891/237/637408747/193879/1acee0f7/5620be19N801621e4.jpg!q70.jpg'\n];\n\n```\n\n```\n//初始化UI\nrender:function () \\\\{\n\t\treturn (\n\t\t\t<View>\n\t\t\t\t<View>\n\t\t\t\t\t<Swiper style=\\\\{styles.wrapper\\\\} showsButtons=\\\\{false\\\\} autoplay=\\\\{true\\\\} height=\\\\{150\\\\} showsPagination={true}>\n        \t\t\t\t<Image style={[styles.slide,]} source={{uri: sliderImgs[0]}}></Image>\n        \t\t\t\t<Image style={[styles.slide,]} source={{uri: sliderImgs[1]}}></Image>\n        \t\t\t\t<Image style={[styles.slide,]} source={{uri: sliderImgs[2]}}></Image>\n        \t\t\t\t<Image style={[styles.slide,]} source={{uri: sliderImgs[3]}}></Image>\n        \t\t\t\t<Image style={[styles.slide,]} source={{uri: sliderImgs[4]}}></Image>\n      \t\t\t\t</Swiper>\n\t\t\t\t</View>\n\n\t\t\t\t<View style={styles.listViewSuper}>\n\t\t\t\t\t<ListView style={styles.tableStyle}\n          \t\t\t\tdataSource = {this.state.dataSource}\n          \t\t\t\trenderRow={this._renderRow.bind(this)}\n                  pageSize={5}\n                  automaticallyAdjustContentInsets={false}//>\n\t\t\t\t</View>\n\t\t\t</View>\n\t\t\t);\n\t},\n\n```\n再次看到render:function()这个函数，应该没那么陌生了吧，暂时可以理解render相当于ViewController中的ViewDidLoad：，我们一般在render里面做一些初始化UI视图的工作，此处我们初始化了swiper和ListView\n\n> swiper\n> * showsButtons        (bool)   是否显示左右切换按钮(显示两个按钮左切 友切)\n> * autoplay                (bool)   是否开启自动播放\n> * height                    (bool)    高度(不解释)\n> * showsPagination  (bool)   是否显示pageControl\n\n\n> ListView\n> * dataSource  绑定数据源\n> * renderRow   cell绑定函数事件(等价于tableView:cellForRowAtIndexPath:)\n> * automaticallyAdjustContentInsets UI布局相关的\n\n#### 初始化数据源\n\n\n```\n\ngetInitialState:function(){\n      var ds = new ListView.DataSource({rowHasChanged: (r1, r2) => r1 !== r2});\n      return {\n        dataSource: new ListView.DataSource({\n        \trowHasChanged: (r1, r2) => r1 !== r2\n        }),\n        loaded:false,\n        currentPage:0,\n      };\n  \t},\n\n```\n\ngetInitialState:function()类似于OC中的init函数，我们一般的习惯喜欢在init函数初始化一个变量等数据，在React Native依旧是这样。\n\n#### 发起网络请求，获取数据，缓存在全局变量List中\n\n\n```\n//定义request url \nvar urlPath = 'http://ccguo.gitcafe.io/cut.json';\nvar CACHE = [];\n\n//componentDidMount:function  系统方法\ncomponentDidMount:function(){\n  \t\tthis.fetchData();\n  \t},\n//自定义函数处理网络获取数据，将数据放入全局变量CACHE\n  \tcache:function(items){\n      for (var i in items) {\n        CACHE.push(items[i]);\n      }\n      this.setState({\n               dataSource: this.state.dataSource.cloneWithRows(CACHE),\n        });\n    },\n\n```\n\n\n```\n//发起 网络请求，获得json\n  \tfetchData:function(){\n      console.log('hello world');\n  \t\tfetch(urlPath)\n  \t\t  .then((response) => response.json())\n        .then((responseText) => {\n          console.log(responseText.cutList);\n          this.cache(responseText.cutList);\n        })\n        .catch((error) => {\n          console.log(error);\n        });\n  \t},\n\n```\n\n\n这个过程模拟了在iOS原生应用里面，初始化网络request，发起网络请求，得到数据，解析数据，然后将数据存入list这一些列操作，其实在js中，js脚本处理json的能力还是很强的，我们再也不需要像OC中哪些objectForKey:的操作了，我们不需要任何MJExtension、JSONModel、 Mantle等一些潜在的工具了，省去了很多的麻烦，我们直接拿到一个json对象，直接对对象进行操作。\n\n另外React的网络请求此处我们只是使用了fetch API[脸谱官方的api](http://facebook.github.io/react-native/docs/network.html#content)(脸谱对于网络请求提供了多种API，如：fetch WebSocket XMLHttpRequest等，具体可参照API)\n\n从代码上看js的链式编程刚看上去有点不太习惯，不过整体使用起来还是比OC中快捷多了，foreach遍历、消息队列进出栈，总之脚步里面省去了以往还不得不在意的好多麻烦，其实这块相对swift而言，新的版本中渐渐的已经得到了部分提升，不过还是要感谢脸谱团队，没有他们，可能还见识不到React的强大。\n\n\n#### 构建cell\n\n\n```\n\t_renderRow:function(data,sectionID,rowID){\n    return (\n      <TouchableHighlight onPress={() => this._pressRow(data,rowID)}>\n      <View style={{backgroundColor:'white'}}>\n        <View style={{width:375,height:150,flexDirection:'row'}}>\n          <View style={{flex:2,borderColor:'green',borderWidth:0.5}}>\n              <Image style={{width:125,height:125,margin:10,borderWidth:0.5,borderColor:'#97979A',borderRadius:2}} source={{uri:data.img}}></Image>\n          </View>\n          <View style={styles.row,{flex:3,borderColor:'blue',borderWidth:0.5}}>\n            <Text style={{marginLeft:20,fontSize:18,color:'black',height:84}}>\n              {rowID+'-'+data.wname}\n            </Text>\n            <Text style={{marginLeft:20,fontSize:14,color:'black',marginTop:10}}>京东价318.00</Text>\n            <View style={{marginLeft:20,width:100,borderWidth:0.5,borderColor:'red',borderRadius:1}}>\n            <Text style={{fontSize:12,color:'red'}}>已有256人砍价</Text>\n            <Text style={{fontSize:17,color:'white',backgroundColor:'red',textAlign:'center'}}>马上砍</Text>\n            </View>\n          </View>\n        </View>\n          <View style={styles.separator} />\n      </View>  \n      </TouchableHighlight>\n      );\n  },\n  _pressRow: function(data,rowID) {\n    this.props.navigator.push({\n      component: detail,\n      passProps: {data: data}\n    });\n  },\n\n```\n\n在上述初始化ListView UI的时间，我们指定了renderRow 对应的action事件，此处我们可以直接在_renderRow:function中构建自己的cell模版，至于React Native中UI的标签基本用法，大家可以去头部基础教程里面找，有点类似于html标签，总之我们在_renderRow:function纯碎是构造cell的代码，这个类似于tableViewCell subClass, cell点击事件我们使用一个TouchableHighlight来代替\n\n```\n <TouchableHighlight onPress={() => this._pressRow(data,rowID)}>\n ....\n </TouchableHighlight>\n```\n\nTouchableHighlight事件处理action同样是一个函数（不解释），在_pressRow事件中我们处理自己的cell点击跳转，顺便插一句下一步的操作，_pressRow（data,rowID）是带有形参的\n另外 ListView renderRow 事件的重载函数，形参类型这个具体参照[脸谱官方的api](http://facebook.github.io/react-native/docs/listview.html#content)\n\n_renderRow:function(data,sectionID,rowID)。\n\n整体运行效果如下：\n\n![react-native-02.png](/images/2015-12-16/post-react-native-cut/react-native-02.png)\n\n#### 处理cell跳转事件\n\n\n```\nvar detail = require('./Detail');\n\n _pressRow: function(data,rowID) {\n    this.props.navigator.push({\n      component: detail,\n      passProps: {data: data}\n    });\n  },\n\n```\n\nReact在处理事件跳转的时间，仍旧采用进栈出栈的形式，这一点和Apple的理念还是类似的。\n\n> * component:     参数对应将要跳转的目标页面，\n> * passProps:     传参字典，内部为key-val形式，相当于一个容器，到了目标页面后可以根据key从容器中取出传递的值。\n\n#### 获取页面跳转时间容器中的值\n\n```\n<Text style={styles.view}>{this.props.data.wname}</Text>\n```\n到了目标页面后，我们直接从props容器直接根据key就能将传递的参数去处，此处我们传递参数的本身是一个json,我们只是讲wname显示到detail页面。\n效果如下：\n\n![react-native-01.png](/images/2015-12-16/post-react-native-cut/react-native-01.png)\n\n### 接下来做什么\n\n\n恭喜你，你的第一个React Native App终于完成了！你可以在GitHub上找到每一个”可运行的“步骤的项目源文件，如果你搞不定的时候它们会非常有用的 :]\n\n如果你来自Web领域，你可能觉得在代码中用JS和React框架建立基于本地化UI的App的界面并实现导航不过是小菜一碟。但如果你主要开发的是本地App，我希望你能从中感受到React Native的优点：快速的App迭代，现代JavaScript语法的支持和清晰的CSS样式规则。\n\n在你的下一个App中，你是会使用这个框架，还是会继续顽固不化地使用Swift和O-C呢？\n\n无论你怎么选择，我都希望你能从本文的介绍中学习到一些有趣的新东西，并把其中一些原理应用到你的下一个项目中。\n\n如果你有任何问题及建议，请参与到下面的讨论中来！","slug":"react-native-cut","published":1,"updated":"2016-02-01T06:12:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cik7x6pmd0009ivc39osif5ry"},{"title":"做一个不可替代的架构师","subtitle":"做一个不可替代的架构师","keywords":"转发一份来自前端大神的博文绪言 ","author":"司徒正美","date":"2016-01-11T16:00:00.000Z","description":"古人说——“人无远虑，必有近忧”。你平时有这么多空闲时间，为何不努力提升一下自己的水平呢。不去认真阅读一下大师们的框架，不自己写一个框架。记得当初我在博客宣传我的框架，被某个嫉妒的人骂个狗血喷头，两年过去，他消声匿迹，而我，从一个公司的核心前端变为另一个公司的核心前端，现在是去哪儿网的前端架构师。因此要相信自己!不要怕这怕那，有努 力就有回报!","_content":"\n##  做一个不可替代的架构师\n\n历时两年多，《JavaScript 框架设计》终于付梓出版了。应各方面的要求，特写一篇序，隆重介绍一下此书对各位程序员的钱途有什么帮助及阅读顺序等疑问。作为国内第一本讲述前端框架构的书，它里面充斥着许多大家前所未闻的知识，这些知识有50%只见于github的issue，讲述各种隐秘的浏览器兼容性问题及各种神奇的修复方案，或者是某些危险但美丽的黑魔法，另外50%我深夜梦游般在外国某些大牛（不局限于英语，有日语、俄语、韩语等，不同的语言的人，受制了他们的语法结构，他们的思考回路是与我们不同的，给出的答案有时真的是拍案叫绝）的博客或网站寻觅的神奇东东。在我通过编写domFramework、mass、Framework这两大框架（domFramework是老式的金字塔式的基于类的大框架，massFramework 是拥有 AMD 加载器的开放式 框架，再到后来的 avalon，是鬼怪式的分层构架的 MVVM 框架，黑魔法满满的），建立完整的知识树后，狂热的心情如征服六国后的秦王，热衷于收集各种奇珍异宝于我的博客——你们看的部分，只是我未公开的十分之一而已，本书将额外开恩公布另外的十分之二。\n\n其实这世界很奇妙，当你水平上去后，就算你不想继续，这世界也推动着你前进。就像 jQuery1.3 通过 Sizzle 大获成功后，成为世界的明星，就算 John Resig 想撒手，但这么多pullrequest，它也只能从更好变成更加好!三年前，当我写了三百多篇的博文时，出版社已经找上门来了约稿了。在那半年内，总共有三四家来找我，让我看到前端的希望。于是我的重心由ruby慢慢转向JavaScript。待到我加入盛大创新院后，我已经确保我能 hold 住《javascript 框架设计》这个大题目，于是签约写书。不过，在最初我提交给出版社的目录里，我有着更为恢宏的目标，包含拖放 组件、路由系统，及各式 UI 组件，但最后由于篇幅的问题，只好说声抱歉了。\n\n愿望总是被现实所掣肘，亚历山大想证明世界，可他的 HP 也是这么短，经不起长途跋涉。实体书与博客是不同的，它必须要形成一个体系，文体也有要求，不能太口语化，什么喜乐哀痛必须收起来，板着脸正正经经地对大家宣讲。错别字也要收殓一下，虽然我找了许多高手审稿。可惜个个都开写轮眼，自动过滤掉错别字，最终还是让出版社的张涛编辑帮忙处理了大部分错别字与病句，太专业的东西他也无能为力，但愿不影响阅读。幸好各位大侠贡献了不少冷癖有用的知识点，让本书充实了不少，因此才一改再改，三番四次，导致两年多才交稿。在盛大创新院时，不断有人（同事或群友）问我的书什么时候出来，人家半年就搞出一本了。我今天终于不为这问 题烦恼了。\n\n在继续这篇软文时，我脑海真的是闪现许多词汇，什么大教堂与集市、造轮子与DRY、公司利益与个人成长....一个个来吧!\n\n大教堂与集市说的是如何构建一个软件工程，是大教堂式的专制主义还是开放式的以众包方式让大家贡献源码。前者，缓和一点地说，是英雄主义，jQuery之于JohnResig，Node。JS之于RyanDahl，他们单枪匹马开创了一个新天地。后者，最杰出的代表是Linux。但在这个互相浸透学习的世界，绝对的东西是不存在的。jQuery 与 Node.JS 现在也是在众多的项献者的努力下前进，原作者向新目的地进发了。在国内，你懂的，每个人都自命不凡，一开始只能是你一个踽踽独行。只有你真正成为明灯式的人物后，才有人追随。\n\n造轮子与 DRY 这问题在新浪微博上也吵过许多次了。有个软件设计原则叫 DRY，防止组员们随意克隆代码，或在不知情的情况下重复发明相似的功能模块。公司出于利益的考虑，也不愿给出更多时间造轮子，上网找一个 jQuery 插件了事。因此，中小公司的页面非常恐怖，允斥着大量第三方插件，而相对而言，大阿狸能用的基本自己做，这正是游击队与正规军的区别。从国内看，最重视JavaSript的公司也恰恰是大阿狸，他们拥有国内最庞大优秀的前端团队（700多人），小公司还是一个前端对20个后端的节奏。招这么多高手干嘛呢?造轮子!当然，这不是一个轮子所代表的，这涉及一整套的工具链，目的是实现前端自动化集成布署。写框架与 UI组件是其中一个很少环节，这也是一般人能理解的东西，更多高大上的东西，大公司也不会公开出来。但你起码拥有创造UI组件这样的能力，你才能有使用更底层的工具的能力。\n\n公司利益与个人成长，这个更不用说。只有目光短浅的公司，才会用杂牌的组件写程序。大公司早已为你准备一整套东西了。而你的任务就是成长到具有写UI组件的地步，进入架构师，为公司的未来挑战做好更多准备(工具)。HTML5 对于一般人而言，好像是非常遥远的事，但大公司早已有一帮人用它做出许多好东西，为公司产品的用户体验添砖加瓦。为了积聚这实力，你必须自己暗暗发力，偷偷自己写一套东西。之前人家写过的弹出层、富文本编辑器、语法高亮插件„„你一套也不能少，这样你才能接触到之前碰不到的原生 API 与知识点。如弹出层有关 垂直居中的CSS知识点、select穿透问题、富文本编辑器用到的 iframe 知识点、Range 与 Selection对象的知识点，语法高亮则是你正则的大检验!如果写业务代码，你写十年，水平还是那样。因 此有句话说——“用一年的经验混十年”。\n\n最近在微博看到一件可怕的事:\n\n<strong>\n我所了解的一个精神失常的程序员 : 不久前我们公司有个程序员精神失常.他走进经理办公室开始大喊大叫，说着一些奇怪的事情.如果不是了解他,就会以为他磕了药.但是事实上他 简直就是精神失常了.\n\n他是我在编程行业见过的最勤奋员工.他经常在下班后加班,周末的时候,当管理人员需要人手去处理紧急工作时,他总是随叫随到.在这个阶段公司并不赚钱，老板需要尽可能快的完成项目,所以任何被客户急催的软件开发都会自动分配给他.他很乐意地全心投入把工作做完整是老板喜欢的地方.\n</strong>\n\n“我能力强，我效率高，我应该是公司的关键人物”，其实那是错的，不可替代性才是最重要的。如果靠“卖力”增加不可替代性，作用是微乎其微的，还是得靠“高门槛”。我认识的工程师里，越是技术好的工程师越会意识到这个问题，然后去做一些“深度”的发展，这也算是工程 师的自我保护吧。说什么做 IT 没前途，30 岁要转行，这只是无能者的藉口。\n\n古人说——“人无远虑，必有近忧”。你平时有这么多空闲时间，为何不努力提升一下自己的水平呢。不去认真阅读一下大师们的框架，不自己写一个框架。记得当初我在博客宣传我的框架，被某个嫉妒的人骂个狗血喷头，两年过去，他消声匿迹，而我，从一个公司的核心前端变为另一个公司的核心前端，现在是去哪儿网的前端架构师。因此要相信自己!不要怕这怕那，有努 力就有回报!\n\n再回来说本书，前端的知识点是非常庞杂的。但知识只有串起来，形成知识树才是你自己的。现在市面上的书，还是依照老旧的方法教人，一开始总是历史回顾，然后是各种数据类型介绍，然后是语法（条件分支、循环分支）什么的，最后再来几个“真实案例”。这对于90%半路出家的前端来说，未免太闷了。而且前端不单单是 JavaScript，JavaScript 只是水泥，或者说储如化学分子这东西，而我们工作是为了构建一整座大厦!只有肉眼看到的物理级别的东西才是主角。它们就是本书的重点，DOM与BOM。JavaScript 通过特性侦测或传参等，进入不同的分支，来解决前端兼容性问题。本书介绍了大量这样的黑魔法，如何知道当前浏览器是支持这个事件呢?为何在这里要劫持this呢?怎么样让选择器引擎跑得更快。于是这一个个疑问，便化解成本书所介 绍的知识点，什么 AMD加载器、选择器引擎、批量生成一堆元素节点„„\n所有前端框架面对的问题都是一样，不同的是解决手段的高下程度。于是 Prototype 死了， jQuery 火了。angular 爆发了，jQuery 沉寂了!本书的章节就是按照编写一个多文件框架的顺序来写。最开始肯定是种子模块，定义框架的名字与版本号，与一些最核心的方法，还有加载器。然后通过加载器，添加一些常用的工具模块，对 JavaScript 语言进行扩张与修复。之后是数据缓存什么的，再之后是主菜，各种DOM问题，节点啊，样式啊，事件啊，动画啊„„最后是MVVM，当前最强大的前端解决方案。通过引入双向绑定与分层架构，完全脱离 DOM 进行前端开发。\n\n你或者有过激情，你或者有过梦想，但当你的 KIP 考核点是 PM 那些荒唐的改来改去的功能点，多炽热的火焰也会被浇灭。因此，你必须要搞出一点东西出来，努力爬上去。是废命于加班，天天写业务，还是专注于底层框架的研发，为某个难题而苦恼，完全在于你一念之差。“是金子总会发光的”，或“是石头到哪都不会发光的”，也完全在于你一念之差。本书将为你提供了一个可能性及一大堆技能点，打开了一个美丽的新世界，提供了一个 X 年不遇的机会，准备了 一个迅速上升的渠道。\n可能有些人会嫌它贵，也有些人怕自己看不明白这么“高大上”的东西。我说一个故事吧。一个特别喜爱昆虫的人做了这样一个实验:他将跳蚤放进敞口的瓶子里，它立刻便跳了出来。\n当把瓶子盖上时，跳蚤还是会竭力跳出瓶子，它不停地撞击着瓶盖的内侧。一个多小时后，他还在那样跳着。差不多三个小时后，它依然在跳，只是它不再撞着瓶盖了，此时它跳的高度离瓶盖大约1厘米左右，而且每一次都是如此。这时，瓶盖被拿掉了，但是跳蚤并没有跳出瓶口，它依然保持着有瓶盖时的高度，再也跳不出瓶口。\n\n同理，如果你总嫌这个贵那个贵，你又不努力改变现状，过了一段时间，你就会习惯了，就 会安于贫困了。就像瓶子的跳蚤那样安于天命，永远困死在瓶子里。\n\n怕自己理解不了这东西，这虽然是一个理智的考量，但只要是人就会遇到瓶颈，但问题是如 何突破瓶颈。瓶盖又不是总是盖上的，有机遇你得抓住!\n\n我也曾毕业找不到工作，潦倒到当了一年保安。但我相信“是金子总会发光的”，我终会一 鸣惊人，我现在只是一只受伤的野狼，我不会被命运所屈服驯化。因此，跟我咆哮吧...\n\n\n>无名的生命之花 \n>已惨遭摧残践踏 \n>一度坠地的飞鸟 \n>正焦急以待风起 \n>一味埋头祈祷\n>却不会有任何改变 \n>若想有所改变 \n>就请起而奋战吧 \n>踏过尸体前行的我们 \n>嘲笑这进击意志的猪猡啊 \n>家畜般的安宁 \n>那虚伪的繁荣 \n>请赐予誓死之饿狼以自由!\n>...\n>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——进击的巨人 OP《红莲の弓矢》\n\n","source":"_posts/qianduan.md","raw":"---\ntitle: 做一个不可替代的架构师\nsubtitle: \"做一个不可替代的架构师\"\nkeywords: \"转发一份来自前端大神的博文绪言 \"\nauthor:     \"司徒正美\"\ndate: 2016-01-12\ndescription: \"古人说——“人无远虑，必有近忧”。你平时有这么多空闲时间，为何不努力提升一下自己的水平呢。不去认真阅读一下大师们的框架，不自己写一个框架。记得当初我在博客宣传我的框架，被某个嫉妒的人骂个狗血喷头，两年过去，他消声匿迹，而我，从一个公司的核心前端变为另一个公司的核心前端，现在是去哪儿网的前端架构师。因此要相信自己!不要怕这怕那，有努 力就有回报!\"\ntags:\n\t- 前端\n\t- js\n\t- 做一个不可替代的架构师\n---\n\n##  做一个不可替代的架构师\n\n历时两年多，《JavaScript 框架设计》终于付梓出版了。应各方面的要求，特写一篇序，隆重介绍一下此书对各位程序员的钱途有什么帮助及阅读顺序等疑问。作为国内第一本讲述前端框架构的书，它里面充斥着许多大家前所未闻的知识，这些知识有50%只见于github的issue，讲述各种隐秘的浏览器兼容性问题及各种神奇的修复方案，或者是某些危险但美丽的黑魔法，另外50%我深夜梦游般在外国某些大牛（不局限于英语，有日语、俄语、韩语等，不同的语言的人，受制了他们的语法结构，他们的思考回路是与我们不同的，给出的答案有时真的是拍案叫绝）的博客或网站寻觅的神奇东东。在我通过编写domFramework、mass、Framework这两大框架（domFramework是老式的金字塔式的基于类的大框架，massFramework 是拥有 AMD 加载器的开放式 框架，再到后来的 avalon，是鬼怪式的分层构架的 MVVM 框架，黑魔法满满的），建立完整的知识树后，狂热的心情如征服六国后的秦王，热衷于收集各种奇珍异宝于我的博客——你们看的部分，只是我未公开的十分之一而已，本书将额外开恩公布另外的十分之二。\n\n其实这世界很奇妙，当你水平上去后，就算你不想继续，这世界也推动着你前进。就像 jQuery1.3 通过 Sizzle 大获成功后，成为世界的明星，就算 John Resig 想撒手，但这么多pullrequest，它也只能从更好变成更加好!三年前，当我写了三百多篇的博文时，出版社已经找上门来了约稿了。在那半年内，总共有三四家来找我，让我看到前端的希望。于是我的重心由ruby慢慢转向JavaScript。待到我加入盛大创新院后，我已经确保我能 hold 住《javascript 框架设计》这个大题目，于是签约写书。不过，在最初我提交给出版社的目录里，我有着更为恢宏的目标，包含拖放 组件、路由系统，及各式 UI 组件，但最后由于篇幅的问题，只好说声抱歉了。\n\n愿望总是被现实所掣肘，亚历山大想证明世界，可他的 HP 也是这么短，经不起长途跋涉。实体书与博客是不同的，它必须要形成一个体系，文体也有要求，不能太口语化，什么喜乐哀痛必须收起来，板着脸正正经经地对大家宣讲。错别字也要收殓一下，虽然我找了许多高手审稿。可惜个个都开写轮眼，自动过滤掉错别字，最终还是让出版社的张涛编辑帮忙处理了大部分错别字与病句，太专业的东西他也无能为力，但愿不影响阅读。幸好各位大侠贡献了不少冷癖有用的知识点，让本书充实了不少，因此才一改再改，三番四次，导致两年多才交稿。在盛大创新院时，不断有人（同事或群友）问我的书什么时候出来，人家半年就搞出一本了。我今天终于不为这问 题烦恼了。\n\n在继续这篇软文时，我脑海真的是闪现许多词汇，什么大教堂与集市、造轮子与DRY、公司利益与个人成长....一个个来吧!\n\n大教堂与集市说的是如何构建一个软件工程，是大教堂式的专制主义还是开放式的以众包方式让大家贡献源码。前者，缓和一点地说，是英雄主义，jQuery之于JohnResig，Node。JS之于RyanDahl，他们单枪匹马开创了一个新天地。后者，最杰出的代表是Linux。但在这个互相浸透学习的世界，绝对的东西是不存在的。jQuery 与 Node.JS 现在也是在众多的项献者的努力下前进，原作者向新目的地进发了。在国内，你懂的，每个人都自命不凡，一开始只能是你一个踽踽独行。只有你真正成为明灯式的人物后，才有人追随。\n\n造轮子与 DRY 这问题在新浪微博上也吵过许多次了。有个软件设计原则叫 DRY，防止组员们随意克隆代码，或在不知情的情况下重复发明相似的功能模块。公司出于利益的考虑，也不愿给出更多时间造轮子，上网找一个 jQuery 插件了事。因此，中小公司的页面非常恐怖，允斥着大量第三方插件，而相对而言，大阿狸能用的基本自己做，这正是游击队与正规军的区别。从国内看，最重视JavaSript的公司也恰恰是大阿狸，他们拥有国内最庞大优秀的前端团队（700多人），小公司还是一个前端对20个后端的节奏。招这么多高手干嘛呢?造轮子!当然，这不是一个轮子所代表的，这涉及一整套的工具链，目的是实现前端自动化集成布署。写框架与 UI组件是其中一个很少环节，这也是一般人能理解的东西，更多高大上的东西，大公司也不会公开出来。但你起码拥有创造UI组件这样的能力，你才能有使用更底层的工具的能力。\n\n公司利益与个人成长，这个更不用说。只有目光短浅的公司，才会用杂牌的组件写程序。大公司早已为你准备一整套东西了。而你的任务就是成长到具有写UI组件的地步，进入架构师，为公司的未来挑战做好更多准备(工具)。HTML5 对于一般人而言，好像是非常遥远的事，但大公司早已有一帮人用它做出许多好东西，为公司产品的用户体验添砖加瓦。为了积聚这实力，你必须自己暗暗发力，偷偷自己写一套东西。之前人家写过的弹出层、富文本编辑器、语法高亮插件„„你一套也不能少，这样你才能接触到之前碰不到的原生 API 与知识点。如弹出层有关 垂直居中的CSS知识点、select穿透问题、富文本编辑器用到的 iframe 知识点、Range 与 Selection对象的知识点，语法高亮则是你正则的大检验!如果写业务代码，你写十年，水平还是那样。因 此有句话说——“用一年的经验混十年”。\n\n最近在微博看到一件可怕的事:\n\n<strong>\n我所了解的一个精神失常的程序员 : 不久前我们公司有个程序员精神失常.他走进经理办公室开始大喊大叫，说着一些奇怪的事情.如果不是了解他,就会以为他磕了药.但是事实上他 简直就是精神失常了.\n\n他是我在编程行业见过的最勤奋员工.他经常在下班后加班,周末的时候,当管理人员需要人手去处理紧急工作时,他总是随叫随到.在这个阶段公司并不赚钱，老板需要尽可能快的完成项目,所以任何被客户急催的软件开发都会自动分配给他.他很乐意地全心投入把工作做完整是老板喜欢的地方.\n</strong>\n\n“我能力强，我效率高，我应该是公司的关键人物”，其实那是错的，不可替代性才是最重要的。如果靠“卖力”增加不可替代性，作用是微乎其微的，还是得靠“高门槛”。我认识的工程师里，越是技术好的工程师越会意识到这个问题，然后去做一些“深度”的发展，这也算是工程 师的自我保护吧。说什么做 IT 没前途，30 岁要转行，这只是无能者的藉口。\n\n古人说——“人无远虑，必有近忧”。你平时有这么多空闲时间，为何不努力提升一下自己的水平呢。不去认真阅读一下大师们的框架，不自己写一个框架。记得当初我在博客宣传我的框架，被某个嫉妒的人骂个狗血喷头，两年过去，他消声匿迹，而我，从一个公司的核心前端变为另一个公司的核心前端，现在是去哪儿网的前端架构师。因此要相信自己!不要怕这怕那，有努 力就有回报!\n\n再回来说本书，前端的知识点是非常庞杂的。但知识只有串起来，形成知识树才是你自己的。现在市面上的书，还是依照老旧的方法教人，一开始总是历史回顾，然后是各种数据类型介绍，然后是语法（条件分支、循环分支）什么的，最后再来几个“真实案例”。这对于90%半路出家的前端来说，未免太闷了。而且前端不单单是 JavaScript，JavaScript 只是水泥，或者说储如化学分子这东西，而我们工作是为了构建一整座大厦!只有肉眼看到的物理级别的东西才是主角。它们就是本书的重点，DOM与BOM。JavaScript 通过特性侦测或传参等，进入不同的分支，来解决前端兼容性问题。本书介绍了大量这样的黑魔法，如何知道当前浏览器是支持这个事件呢?为何在这里要劫持this呢?怎么样让选择器引擎跑得更快。于是这一个个疑问，便化解成本书所介 绍的知识点，什么 AMD加载器、选择器引擎、批量生成一堆元素节点„„\n所有前端框架面对的问题都是一样，不同的是解决手段的高下程度。于是 Prototype 死了， jQuery 火了。angular 爆发了，jQuery 沉寂了!本书的章节就是按照编写一个多文件框架的顺序来写。最开始肯定是种子模块，定义框架的名字与版本号，与一些最核心的方法，还有加载器。然后通过加载器，添加一些常用的工具模块，对 JavaScript 语言进行扩张与修复。之后是数据缓存什么的，再之后是主菜，各种DOM问题，节点啊，样式啊，事件啊，动画啊„„最后是MVVM，当前最强大的前端解决方案。通过引入双向绑定与分层架构，完全脱离 DOM 进行前端开发。\n\n你或者有过激情，你或者有过梦想，但当你的 KIP 考核点是 PM 那些荒唐的改来改去的功能点，多炽热的火焰也会被浇灭。因此，你必须要搞出一点东西出来，努力爬上去。是废命于加班，天天写业务，还是专注于底层框架的研发，为某个难题而苦恼，完全在于你一念之差。“是金子总会发光的”，或“是石头到哪都不会发光的”，也完全在于你一念之差。本书将为你提供了一个可能性及一大堆技能点，打开了一个美丽的新世界，提供了一个 X 年不遇的机会，准备了 一个迅速上升的渠道。\n可能有些人会嫌它贵，也有些人怕自己看不明白这么“高大上”的东西。我说一个故事吧。一个特别喜爱昆虫的人做了这样一个实验:他将跳蚤放进敞口的瓶子里，它立刻便跳了出来。\n当把瓶子盖上时，跳蚤还是会竭力跳出瓶子，它不停地撞击着瓶盖的内侧。一个多小时后，他还在那样跳着。差不多三个小时后，它依然在跳，只是它不再撞着瓶盖了，此时它跳的高度离瓶盖大约1厘米左右，而且每一次都是如此。这时，瓶盖被拿掉了，但是跳蚤并没有跳出瓶口，它依然保持着有瓶盖时的高度，再也跳不出瓶口。\n\n同理，如果你总嫌这个贵那个贵，你又不努力改变现状，过了一段时间，你就会习惯了，就 会安于贫困了。就像瓶子的跳蚤那样安于天命，永远困死在瓶子里。\n\n怕自己理解不了这东西，这虽然是一个理智的考量，但只要是人就会遇到瓶颈，但问题是如 何突破瓶颈。瓶盖又不是总是盖上的，有机遇你得抓住!\n\n我也曾毕业找不到工作，潦倒到当了一年保安。但我相信“是金子总会发光的”，我终会一 鸣惊人，我现在只是一只受伤的野狼，我不会被命运所屈服驯化。因此，跟我咆哮吧...\n\n\n>无名的生命之花 \n>已惨遭摧残践踏 \n>一度坠地的飞鸟 \n>正焦急以待风起 \n>一味埋头祈祷\n>却不会有任何改变 \n>若想有所改变 \n>就请起而奋战吧 \n>踏过尸体前行的我们 \n>嘲笑这进击意志的猪猡啊 \n>家畜般的安宁 \n>那虚伪的繁荣 \n>请赐予誓死之饿狼以自由!\n>...\n>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——进击的巨人 OP《红莲の弓矢》\n\n","slug":"qianduan","published":1,"updated":"2016-02-01T06:12:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cik7x6pmj000eivc3urf5c6hp"},{"title":"一种基于面相协议的MVVM设计思路","subtitle":"一种基于面相协议的MVVM设计思路","keywords":"一种基于面相协议的MVVM设计思路 ","author":"Scenery","date":"2016-01-16T16:00:00.000Z","description":"其实关于iOS设计架构的文章最近已经很多了，我之前也曾经发表过一篇草稿基于面相协议MVP的软件设计。在这之前其实已经有不少的博主对于各种思路进行了大量的阐述，之所以写这遍文章的原因，是因为之前的一篇文章MVVM没你想象的那么的好,这遍文章从侧面描述了MVVM本质，但是不乏也缺少一些针对性的理解，在此我想真正的阐述一下自己的一些看法与见解，希望能与大家多多交流，一谈到MVVM可能好多人都认为又是一片关于架构的文章，也有一些人基本上就不厌其烦了(脱胎与MVC，将控制器剥离，轻量级控制器等)。","_content":"\n* 作者: sunnycn\n* 原创: 一种基于面相协议的MVVM设计思路\n* 出处: 风之痕的博客(中文原创精品)\n\n### 导语\n\n> 其实关于iOS设计架构的文章最近已经很多了，我之前也曾经发表过一篇草稿[基于面相协议MVP的软件设计](www.baidu.com)。在这之前其实已经有不少的博主对于各种思路进行了大量的阐述，之所以写这遍文章的原因，是因为之前的一篇文章[MVVM没你想象的那么的好](http://www.cocoachina.com/ios/20160112/14949.html),这遍文章从侧面描述了MVVM本质，但是不乏也缺少一些针对性的理解，在此我想真正的阐述一下自己的一些看法与见解，希望能与大家多多交流。\n\n### 一、绪言\n\n一谈到MVVM可能好多人都认为又是一片关于架构的文章，也有一些人基本上就不厌其烦了(脱胎与MVC，控制器剥离，轻量级控制器等)。在一大片的嘈杂声过后，不少人对于这个名词甚至都觉得危言耸听，至此有了文章说MVVM没你想象中的那么神往，更有甚至对其使用理解也是各有千秋。\n\n一个成熟的设计思维是在提出思想以后，然后在经历不断的使用、操作并最终得到验证后从新升华出的新的思维总结。任何一套理论思维都是如此，不经历生产的实际验证，无法证明其可靠性，人类工业革命每次大规模的进步都是如此。MVVM这个思维其实不算是一个新的构思了，大量资料显示它出自C#,最终被应用到iOS。说到此处，我个人觉得MVVM可能在其他平台中的使用已经渐进成熟，但是在iOS中大家对于MVVM的理解运用确实各有异同。\n\n谈到C#,其实我本人一直很钦佩这个平台的开创者。虽然说现有的service平台技术各有千秋，但是千遍一律，万变不离其宗。在服务端开发平台里，基础的三大平台的一些逻辑思维是值得每一个人去深思的。谈到处理业务逻辑服务端首档其冲。iOS之所以出现越来越多的设计思维方面的争议，究其原因无非是业务逻辑的处理越来越偏向于客户端、前端也需要担当一部分处理业务的责任，在这之前客户端是从不考虑逻辑处理的。我们在设计这一块区域的时间可以去借鉴一下服务端的一些基本的模式。无论是MVVM、MVP这些思维在上述平台中最早都曾出现过，学以致用，刨根揭底、物尽其用、极尽升华...\n\n### 二、百家争鸣中MVVM\n\n#### 2.1 ViewModel究其何物\n\nMVVM新增了一个叫ViewModel的东东，其实最早看到iOS中使用MVVM，我自己也很模糊。ViewModel这个东西看起来很重，但是里面究竟要做什么、怎么做；它到底扮演了一个什么样的角色、到底该如何使用？这一点仍有争议。在不少文章以及使用中，可能最多看到的仍旧是在Bundle文件设计目录上一定要多出一个叫 *ViewModel的东西，然后将Controller中一部分逻辑直接玻璃出来放到这个class中，这样的文件结构决定了这是一种叫MVVM的设计架构。\n\n曾经有一段关于ViewModel的解释：ViewModel是一种介于Model和Controller之间的一个抽象模型，他能帮助控制器起到一个协调Model的作用，从而将一部分逻辑从控制器中剥离进而达到解耦合目的。\n\n可能就是这句解释最终产生了臆想不到的结果，从此以后ViewModel担起了处理数据显示、网络请求获取数据、表单验证更甚之可以放到这里面的任务全部放进来。ViewModel成了万金油，最终MVVM比起MVC只不过是多了一个class文件，然后拖进去一部分代码而已。\n\n#### 2.2 ViewModel承担了更多的责任\n\nViewModel用于存放用户输入的逻辑、视图的表示逻辑、网络请求、以及其他不确定的各种代码逻辑。就是这样的一系列胶浊物，让人不禁对这种新的设计方式产生疑问。这样的结构能否满足并需求并达到彻底解耦合的目的，不同的逻辑分支的胶浊物从新被分配到一个新的类文件中是否真的解决了问题。太过于模糊的ViewModel是否真的可好；如果业务场景在增加一倍ViewModel中的逻辑是否仍旧清晰、是否会混淆等等。\n\nViewModel现有的这种理解并没有真的改变之前的一些问题，单独的从文件结构上来划分原有的逻辑，不禁让人产生深思。[MVVM没你想象的那么的好](http://www.cocoachina.com/ios／20160112/14949.html)中这遍文章的确也谈到了这一点。ViewModel最终的臃肿无法最终解决问题，这一点与Controller臃肿无非是五十步笑百步的问题。\n\n### 三、个人理解的MVVM解耦\n\n#### 3.1 传统业务模型的解决之道\n\n谈到此处，我们暂时先抛开iOS 、抛开前端。让我们从新回到原始的软件设计模型中去...\n\n最初的最初，我们开始使用文件来存储数据，之后慢慢有了数据库，到后来关系型数据库。我们开始存储时代的来临。大量的数据开始存储在数据库中。随着业务的持续增长，我们渐渐的逐步开始将一部分逻辑最终以抽象关系模型数据的方式存储在DB，从此以后渐渐诞生了业务模型这个概念。\n\n随着业务模型的深入，我们不得不开始处理大量的逻辑，同时软件开发的最终的目的都是为了一个所谓的呈递、操作、处理业务的目的。我们将可操作、可使用的一个可执行程序呈递给用户，于是有了软件的使用、商业化软件市场的诞生。\n\n随着业务模型的进一步拓展，业务愈加复杂，我们发现在开发、使用过程中难免遇见一些业务层次的变更，可能是存储层变更，会影响到我们的软件，逻辑层的变更、用户交互层的改变等都会影响到我们的软件的维护、升级。\n\n于是我们在开发的模型中渐渐考虑到了软件的设计思维的剥离、抽取。这一点主要从两个方面来完成入手，一是从业务逻辑模型这条渠道进行分离(最终暂时理解为基本三层架构)；二是从软件操作界面上进行逻辑抽取玻璃(最终诞生了基本的MVC模型)，这些设计思维的前身都是从传统的模型中一步步走过来的。\n\n随着时间的与日增场，为了满足业务对接式的需求。满满诞生了webservice、service这些服务型的应用来满足互联网网络传输过程的各种数据对接。\n\n以上大概就是传统软件进阶之路...\n\n#### 3.2 MVVM究竟该如何安置\n\nMVVM无非是因为原有的MVC无法满足现有的开发以及维护产生的一个临时做法，我们只是想到抽离了这个东西，但是没有具体的定义该如何去使用。为此大量的文章并没有具体的谈到这一点。这一点还要归咎于app这个概念。如果我们暂且仍旧理解app只是一个展示性的界面，压根从不处理各种业务逻辑就不会有上述问题了。关键是事实并非如此，我们面临的关于处理业务逻辑的问题只能说是越来越多。\n\n业务逻辑大量的在客户度中开始追加，我们暂且考虑ViewModel是一个业务处理模块，viewModel只处理业务数据逻辑，视图显示一概不要。ViewModel处理的数据究竟从哪里来；我们需要一个对应的数据获取层。ViewModel只有通过某种工具拿到数据才能对数据进行加工、逻辑处理，反过来如果说客户端要写入什么类型的数据，ViewMode作为数据逻辑处理工具需要提供对应的工具入口，数据有进有出，这才符合业务逻辑处理层次的概念。\n\nViewModel只负责数据处理，数据交付谁来处理。我们想到了数据传输层(DAL),ViewModel不会管理Http Request对象，它需要一个专门的工具来完成这个工作。我们开创了数据传输层，这一点根server端有区别。传统的DAL层负责支持从数据库端的增删改查操作，我们客户端的数据传输层（下文API层）则需要负责与网络service的访问对接，因为网络service才是客户度真正的数据存储源。\n\n传统业务逻辑处理：\n\n```\n三层\n    - Model    －－\n    - DAL         ｜\n    - BLL         ｜\n    -             ｜\nMVC :             ｜\n    - Model    - -\n    - View\n    - Controller\n    \n```\n\n谈到数据Model，此处我们仍旧坚持不会抛弃传统模式下的Model设计，只不过Model层我们做了一点点改动，对应的每个属性Model我们在此追加了协议层这一概念，暂时可以认为楼层中的每一个对象都是一个Model，我们针对这些数据设计了一个协议，Model具体由哪个对应的View显示绘制，由Model自身实现的协议决定。这一点大家可以参照我之前发表的文章[基于面向协议MVP模式下的软件设计－iOS篇\n](http://www.cocoachina.com/ios/20151223/14768.html)\n这样做的好处就是在控制器胶水层面，我们针对处理tableview各种代理的的时候，我们统一认为所有的数据模型都是id<xxxProtocol>类型统一去做粘合处理。此处的设计规范采用抽取公共属性，然后抽象到协议，再由具体的对象实现对应的协议去完成。成功的避开了继承，这一点与最近几天swift开发大会中喵神王巍提到的观念相吻合。\n\n#### 3.3 页面层如何安置\n\n解决了ViewModel的问题，我们来看页面展示层的概念，这一点我们要严格遵守MVC的通知界面、更新数据的策略。View永远不要直接通知Model，Model数据发生变化绝对禁止直接通知View进行显示。\n\n谈到这一点可能ReactiveCocoa做的很好，但是其实一直以来好归好，我们本人不太喜欢整个工程完全抛弃Apple原有的代码编程规范，去采用一种新的编程模式。这一点我个人更青睐于Apple自身。\n\nReactiveCocoa在处理View－>Model，Model－>View已经封装慌的很好了；你可以直接在控制器内将需要通过信号型变量关联的Model和View链接起来，控制器仍旧起到链接Model和View的胶水作用，但是Model和View并没有直接交互，通过发送信号间接的进行交互。\n\n在MVVM中，如有类似需求，我本人更倾向于KVO来完成,具体参照([Let’s discuss MVVM for iOS](https://medium.com/@ramshandilya/lets-discuss-mvvm-for-ios-a7960c2f04c7#.qkjcbjnpr))。在页面级别，仍旧采用控制器持有ViewModel的惯例，这一点根大家一观的做法相同。控制器的交互数据获取都从ViewModel来获取，我们暂时理解ViewModel就是一代工厂，既不拥有数据、也不具体使用数据，只负责加工处理数据。我们在控制器层可以针对数据来源的某些属性采用KVO增加观察者的形式做数据监听，当数据来源的这些属性发生变化时间，控制器能及时的收到通知并更新UI。这个过程中数据变化直接通知控制器然后由控制器直接通知View更新界面，完全符合MVC观念。\n\n当UI界面上通过某个点击事件发生回传，我们仍旧采用事件回调首先传递回到控制器，然后由控制器拿到响应的数据源交付ViewModel去处理加工数据，最终拿到处理结果。此时KVO生效，控制器中直接感应到通知的回调去更新对应的UI界面。整个工作流程完全负责MVC的原始观念。\n\n整个设计思路如下：\n![MVVM](http://7xkmox.com1.z0.glb.clouddn.com/mvvm.png)\n#### 3.4 购物车设计规范\n\n一种基于面相协议的MVVM\n```\n- API                       与serve端API对接工具\t(相当于客户端的数据访问层)\n\t- BaseAPI               提供基础的服务\n\t- CartAPI               基于购物车的API集合，提供相关的API服务\n- Protocol                  基础协议层\n\t- CartProbeProtocol    探针器 主要为所有的cell提供计算cell高度、呈递数据、传入事件处理\n\t- CartRenderProtocol   渲染协议 主要为Model提供渲染目标视图\n\t- CartFloorProtocol    通用Model楼层协议，为大楼层的提供公共属性\n- Model                    实体层 Entity  (数据实体层)\n\t- CartModel            购物车基础实体集合\n\t- CartSkuModel         商品Model\n\t- CartHeaderModel      分类title Model\n- View                     基础UI层 主要提供基础的视图 (基础View层)\n\t- view\t               自定义View\n- Cell                     Cell (cell集合)\n\t- CartTableViewCell    公共集合\n\t- CartHeaderTableCell  头视图cell\n- ViewModel                ViewModel 主要完成针对控制器的拆分 (相当于业务；逻辑层)\n\t- CartViewModel        内部封装了购物车相关的各种业务逻辑（数据拉取、数据更新、数据删除）\n- Controller \t\t       控制器胶水层  (控制器层)\n```\n###### API层\n客户端API层职能类似于传统的数据访问层，这里封装了基本的网络请求对象、service地址以及，回调处理等，等操作。API层主要用于ViewModel层的调用，关于客户端请求交互的模块全部都是由API层来完成，此处完主要成了业务模块针对网络请求层次的剥离抽取。\n\n```\n@class RequestModel;\n@interface BaseAPI : NSObject\n{\n    AFHTTPSessionManager *_manager;\n    RequestModel         *_requestModel;\n}\n\n@property (nonatomic,strong,readonly) RequestModel *requestModel;\n\n- (NSString *)serverURL;\n- (NSString *)functionID;\n- (NSDictionary *)params;\n\n- (void)startWithCompletionBlockWithSuccess:(void (^)(NSDictionary *content))success\n                                    failure:(void (^)(NSError *error))failure;\n- (void)stop;\n\n@end\n\n@interface RequestModel : NSObject\n\n@property (nonatomic,strong) NSString *serverURL;\n@property (nonatomic,strong) NSString *functionID;\n@property (nonatomic,strong) NSDictionary *params;\n\n@end\n\n```\n\n##### 基础协议层\n这个地方主要提供了三个对应的协议，之所以使用抽象协议，此处省略了继承。\n\nCartProbeProtocol   主要交付TableViewCell来实现\nCartRenderProtocol  主要交付具体要绘制的Model来实现\nCartFloorProtocol   主要交付大楼层符合Model来实现\n\n此处使用协议的形式，主要是为了能够完成对象的协作性调用，在粘合剂控制器中，我们可以统一采用\nid<Cart***Protocol>的形式来操作具体的对象，而无需再关心具体的Model类型以及cell类型。\n\n##### Model 、Cell 、View层\n这些层次与MVC类似\n\n##### ViewModel层\nViewModel层是一个基于业务逻辑层面的剥离，主要提供一些增删改查的操作\n\n##### Controller器层次\n控制器主要起到胶水作用，控制器会组织View的与数据的融合。控制器中主要采用两种手段：\n一种是基本的楼层我们采用id<Cart***Protocol>的形式来统一操作，这一点遵循了运行时语言的特性（运行时才决定具体的对象的类型）。\n另一种是针对特定属性的功能，通过分类的形式来完成，尽最大限度的剥离控制器的逻辑。\n备注：（如关于导航上相关的所有逻辑，我们统一将这块的UI、操作、衔接、回调统一放在一个当前控制器的一个分类文件去完成，这样从文件分割上进一步分割原有控制器）。\n\n<<strong>创建分类的时间，最大限度的不要为系统级别的class创建分类，要尽量针对自己的某个自定义class创建分类，这一点尽量避免为系统级class创建分类引入多于的链接类型开销(有兴趣的可以研究下runtime相关东西，category的实现最后也是要讲分类方法加入method_list队列去的，如果分类给NSObject创建了分类，在世纪使用场景下，系统会给每个类都田间对应的方法，产生多于的函数链接、存储开销) </strong>>\n如下：\n\n```\n//#pragma mark - UITableViewDelegate,UITableViewDataSource\n- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView \n{\n    return [self.cartViewModel.list count];\n}\n\n- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section\n{\n    id<CartFloorProtocol> floor = self.cartViewModel.list[section];\n    return [floor numberOfModelInFloor];\n}\n\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    UITableViewCell *cell = nil;\n    id<CartFloorProtocol> floor = self.cartViewModel.list[indexPath.section];\n    cell = [tableView dequeueReusableCellProcessModel:floor indexPath:indexPath];\n    [(id<CartProbeProtocol>)cell setDelegate:self];\n    return cell;\n}\n- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section\n{\n    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, SCREEN_WIDTH, 25)];\n    view.backgroundColor = [UIColor lightGrayColor];\n    return view;\n}\n\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    id<CartFloorProtocol> floor = self.cartViewModel.list[indexPath.section];\n    id<CartRenderProtocol> renderModel = [floor cartModelForRowIndexPath:indexPath];\n    Class<CartProbeProtocol> cellClass = NSClassFromString([renderModel cellIdentifier]);\n    return [cellClass calculateSizeWithData:renderModel];\n}\n\n```\n\n### 四、软件设计开发之展望\n\n软件设计的思路千变万化，终归到底没有具体绝对的好与坏之分，真正的选择还需要根据的具体的业务场景来决定，MVVM脱胎于MVC，如果是展示型的复杂业务类型来讲我个人更偏重于MVP的模式来实现(具体参照[基于面向协议MVP模式下的软件设计－iOS篇\n](http://www.cocoachina.com/ios/20151223/14768.html)，这一点针对模块化进行分割处理，严格的讲不通的逻辑快分割，提高了程序的健壮性)；\n如果是针对具有复杂操作性的业务类型的场景，我个人偏重于MVVM，处理复杂交互逻辑。采用传统业务逻辑抽离的规则来处理客户端的逻辑，这一点绰绰有余。\n\n任何一种软件构思都是在具体的实践中一步步的出的。纵观整个软件的发展，无一不是如此。无论是中文还是外文其实大家都有自己的见解，关于MVVM的文章其实的确有不少外文的，之前我也认真研读过一些。任何一种事务我们最终都是需要有自己独特一面见解的，只有不断的总结学习别人观点，不断的进行融汇升华，最终走出一条自己的路。这一点始终如此，也只有这样在某一点上我们才可能做到超越以往....","source":"_posts/protocol_mvvm.md","raw":"---\ntitle: 一种基于面相协议的MVVM设计思路\nsubtitle: \"一种基于面相协议的MVVM设计思路\"\nkeywords: \"一种基于面相协议的MVVM设计思路 \"\nauthor:     \"Scenery\"\ndate: 2016-01-17\ndescription: \"其实关于iOS设计架构的文章最近已经很多了，我之前也曾经发表过一篇草稿基于面相协议MVP的软件设计。在这之前其实已经有不少的博主对于各种思路进行了大量的阐述，之所以写这遍文章的原因，是因为之前的一篇文章MVVM没你想象的那么的好,这遍文章从侧面描述了MVVM本质，但是不乏也缺少一些针对性的理解，在此我想真正的阐述一下自己的一些看法与见解，希望能与大家多多交流，一谈到MVVM可能好多人都认为又是一片关于架构的文章，也有一些人基本上就不厌其烦了(脱胎与MVC，将控制器剥离，轻量级控制器等)。\"\ntags:\n    - iOS\n    - MVVM\n    - MVV\n    - MVP\n    - iOS开发框架\n    - 电子商务\n---\n\n* 作者: sunnycn\n* 原创: 一种基于面相协议的MVVM设计思路\n* 出处: 风之痕的博客(中文原创精品)\n\n### 导语\n\n> 其实关于iOS设计架构的文章最近已经很多了，我之前也曾经发表过一篇草稿[基于面相协议MVP的软件设计](www.baidu.com)。在这之前其实已经有不少的博主对于各种思路进行了大量的阐述，之所以写这遍文章的原因，是因为之前的一篇文章[MVVM没你想象的那么的好](http://www.cocoachina.com/ios/20160112/14949.html),这遍文章从侧面描述了MVVM本质，但是不乏也缺少一些针对性的理解，在此我想真正的阐述一下自己的一些看法与见解，希望能与大家多多交流。\n\n### 一、绪言\n\n一谈到MVVM可能好多人都认为又是一片关于架构的文章，也有一些人基本上就不厌其烦了(脱胎与MVC，控制器剥离，轻量级控制器等)。在一大片的嘈杂声过后，不少人对于这个名词甚至都觉得危言耸听，至此有了文章说MVVM没你想象中的那么神往，更有甚至对其使用理解也是各有千秋。\n\n一个成熟的设计思维是在提出思想以后，然后在经历不断的使用、操作并最终得到验证后从新升华出的新的思维总结。任何一套理论思维都是如此，不经历生产的实际验证，无法证明其可靠性，人类工业革命每次大规模的进步都是如此。MVVM这个思维其实不算是一个新的构思了，大量资料显示它出自C#,最终被应用到iOS。说到此处，我个人觉得MVVM可能在其他平台中的使用已经渐进成熟，但是在iOS中大家对于MVVM的理解运用确实各有异同。\n\n谈到C#,其实我本人一直很钦佩这个平台的开创者。虽然说现有的service平台技术各有千秋，但是千遍一律，万变不离其宗。在服务端开发平台里，基础的三大平台的一些逻辑思维是值得每一个人去深思的。谈到处理业务逻辑服务端首档其冲。iOS之所以出现越来越多的设计思维方面的争议，究其原因无非是业务逻辑的处理越来越偏向于客户端、前端也需要担当一部分处理业务的责任，在这之前客户端是从不考虑逻辑处理的。我们在设计这一块区域的时间可以去借鉴一下服务端的一些基本的模式。无论是MVVM、MVP这些思维在上述平台中最早都曾出现过，学以致用，刨根揭底、物尽其用、极尽升华...\n\n### 二、百家争鸣中MVVM\n\n#### 2.1 ViewModel究其何物\n\nMVVM新增了一个叫ViewModel的东东，其实最早看到iOS中使用MVVM，我自己也很模糊。ViewModel这个东西看起来很重，但是里面究竟要做什么、怎么做；它到底扮演了一个什么样的角色、到底该如何使用？这一点仍有争议。在不少文章以及使用中，可能最多看到的仍旧是在Bundle文件设计目录上一定要多出一个叫 *ViewModel的东西，然后将Controller中一部分逻辑直接玻璃出来放到这个class中，这样的文件结构决定了这是一种叫MVVM的设计架构。\n\n曾经有一段关于ViewModel的解释：ViewModel是一种介于Model和Controller之间的一个抽象模型，他能帮助控制器起到一个协调Model的作用，从而将一部分逻辑从控制器中剥离进而达到解耦合目的。\n\n可能就是这句解释最终产生了臆想不到的结果，从此以后ViewModel担起了处理数据显示、网络请求获取数据、表单验证更甚之可以放到这里面的任务全部放进来。ViewModel成了万金油，最终MVVM比起MVC只不过是多了一个class文件，然后拖进去一部分代码而已。\n\n#### 2.2 ViewModel承担了更多的责任\n\nViewModel用于存放用户输入的逻辑、视图的表示逻辑、网络请求、以及其他不确定的各种代码逻辑。就是这样的一系列胶浊物，让人不禁对这种新的设计方式产生疑问。这样的结构能否满足并需求并达到彻底解耦合的目的，不同的逻辑分支的胶浊物从新被分配到一个新的类文件中是否真的解决了问题。太过于模糊的ViewModel是否真的可好；如果业务场景在增加一倍ViewModel中的逻辑是否仍旧清晰、是否会混淆等等。\n\nViewModel现有的这种理解并没有真的改变之前的一些问题，单独的从文件结构上来划分原有的逻辑，不禁让人产生深思。[MVVM没你想象的那么的好](http://www.cocoachina.com/ios／20160112/14949.html)中这遍文章的确也谈到了这一点。ViewModel最终的臃肿无法最终解决问题，这一点与Controller臃肿无非是五十步笑百步的问题。\n\n### 三、个人理解的MVVM解耦\n\n#### 3.1 传统业务模型的解决之道\n\n谈到此处，我们暂时先抛开iOS 、抛开前端。让我们从新回到原始的软件设计模型中去...\n\n最初的最初，我们开始使用文件来存储数据，之后慢慢有了数据库，到后来关系型数据库。我们开始存储时代的来临。大量的数据开始存储在数据库中。随着业务的持续增长，我们渐渐的逐步开始将一部分逻辑最终以抽象关系模型数据的方式存储在DB，从此以后渐渐诞生了业务模型这个概念。\n\n随着业务模型的深入，我们不得不开始处理大量的逻辑，同时软件开发的最终的目的都是为了一个所谓的呈递、操作、处理业务的目的。我们将可操作、可使用的一个可执行程序呈递给用户，于是有了软件的使用、商业化软件市场的诞生。\n\n随着业务模型的进一步拓展，业务愈加复杂，我们发现在开发、使用过程中难免遇见一些业务层次的变更，可能是存储层变更，会影响到我们的软件，逻辑层的变更、用户交互层的改变等都会影响到我们的软件的维护、升级。\n\n于是我们在开发的模型中渐渐考虑到了软件的设计思维的剥离、抽取。这一点主要从两个方面来完成入手，一是从业务逻辑模型这条渠道进行分离(最终暂时理解为基本三层架构)；二是从软件操作界面上进行逻辑抽取玻璃(最终诞生了基本的MVC模型)，这些设计思维的前身都是从传统的模型中一步步走过来的。\n\n随着时间的与日增场，为了满足业务对接式的需求。满满诞生了webservice、service这些服务型的应用来满足互联网网络传输过程的各种数据对接。\n\n以上大概就是传统软件进阶之路...\n\n#### 3.2 MVVM究竟该如何安置\n\nMVVM无非是因为原有的MVC无法满足现有的开发以及维护产生的一个临时做法，我们只是想到抽离了这个东西，但是没有具体的定义该如何去使用。为此大量的文章并没有具体的谈到这一点。这一点还要归咎于app这个概念。如果我们暂且仍旧理解app只是一个展示性的界面，压根从不处理各种业务逻辑就不会有上述问题了。关键是事实并非如此，我们面临的关于处理业务逻辑的问题只能说是越来越多。\n\n业务逻辑大量的在客户度中开始追加，我们暂且考虑ViewModel是一个业务处理模块，viewModel只处理业务数据逻辑，视图显示一概不要。ViewModel处理的数据究竟从哪里来；我们需要一个对应的数据获取层。ViewModel只有通过某种工具拿到数据才能对数据进行加工、逻辑处理，反过来如果说客户端要写入什么类型的数据，ViewMode作为数据逻辑处理工具需要提供对应的工具入口，数据有进有出，这才符合业务逻辑处理层次的概念。\n\nViewModel只负责数据处理，数据交付谁来处理。我们想到了数据传输层(DAL),ViewModel不会管理Http Request对象，它需要一个专门的工具来完成这个工作。我们开创了数据传输层，这一点根server端有区别。传统的DAL层负责支持从数据库端的增删改查操作，我们客户端的数据传输层（下文API层）则需要负责与网络service的访问对接，因为网络service才是客户度真正的数据存储源。\n\n传统业务逻辑处理：\n\n```\n三层\n    - Model    －－\n    - DAL         ｜\n    - BLL         ｜\n    -             ｜\nMVC :             ｜\n    - Model    - -\n    - View\n    - Controller\n    \n```\n\n谈到数据Model，此处我们仍旧坚持不会抛弃传统模式下的Model设计，只不过Model层我们做了一点点改动，对应的每个属性Model我们在此追加了协议层这一概念，暂时可以认为楼层中的每一个对象都是一个Model，我们针对这些数据设计了一个协议，Model具体由哪个对应的View显示绘制，由Model自身实现的协议决定。这一点大家可以参照我之前发表的文章[基于面向协议MVP模式下的软件设计－iOS篇\n](http://www.cocoachina.com/ios/20151223/14768.html)\n这样做的好处就是在控制器胶水层面，我们针对处理tableview各种代理的的时候，我们统一认为所有的数据模型都是id<xxxProtocol>类型统一去做粘合处理。此处的设计规范采用抽取公共属性，然后抽象到协议，再由具体的对象实现对应的协议去完成。成功的避开了继承，这一点与最近几天swift开发大会中喵神王巍提到的观念相吻合。\n\n#### 3.3 页面层如何安置\n\n解决了ViewModel的问题，我们来看页面展示层的概念，这一点我们要严格遵守MVC的通知界面、更新数据的策略。View永远不要直接通知Model，Model数据发生变化绝对禁止直接通知View进行显示。\n\n谈到这一点可能ReactiveCocoa做的很好，但是其实一直以来好归好，我们本人不太喜欢整个工程完全抛弃Apple原有的代码编程规范，去采用一种新的编程模式。这一点我个人更青睐于Apple自身。\n\nReactiveCocoa在处理View－>Model，Model－>View已经封装慌的很好了；你可以直接在控制器内将需要通过信号型变量关联的Model和View链接起来，控制器仍旧起到链接Model和View的胶水作用，但是Model和View并没有直接交互，通过发送信号间接的进行交互。\n\n在MVVM中，如有类似需求，我本人更倾向于KVO来完成,具体参照([Let’s discuss MVVM for iOS](https://medium.com/@ramshandilya/lets-discuss-mvvm-for-ios-a7960c2f04c7#.qkjcbjnpr))。在页面级别，仍旧采用控制器持有ViewModel的惯例，这一点根大家一观的做法相同。控制器的交互数据获取都从ViewModel来获取，我们暂时理解ViewModel就是一代工厂，既不拥有数据、也不具体使用数据，只负责加工处理数据。我们在控制器层可以针对数据来源的某些属性采用KVO增加观察者的形式做数据监听，当数据来源的这些属性发生变化时间，控制器能及时的收到通知并更新UI。这个过程中数据变化直接通知控制器然后由控制器直接通知View更新界面，完全符合MVC观念。\n\n当UI界面上通过某个点击事件发生回传，我们仍旧采用事件回调首先传递回到控制器，然后由控制器拿到响应的数据源交付ViewModel去处理加工数据，最终拿到处理结果。此时KVO生效，控制器中直接感应到通知的回调去更新对应的UI界面。整个工作流程完全负责MVC的原始观念。\n\n整个设计思路如下：\n![MVVM](http://7xkmox.com1.z0.glb.clouddn.com/mvvm.png)\n#### 3.4 购物车设计规范\n\n一种基于面相协议的MVVM\n```\n- API                       与serve端API对接工具\t(相当于客户端的数据访问层)\n\t- BaseAPI               提供基础的服务\n\t- CartAPI               基于购物车的API集合，提供相关的API服务\n- Protocol                  基础协议层\n\t- CartProbeProtocol    探针器 主要为所有的cell提供计算cell高度、呈递数据、传入事件处理\n\t- CartRenderProtocol   渲染协议 主要为Model提供渲染目标视图\n\t- CartFloorProtocol    通用Model楼层协议，为大楼层的提供公共属性\n- Model                    实体层 Entity  (数据实体层)\n\t- CartModel            购物车基础实体集合\n\t- CartSkuModel         商品Model\n\t- CartHeaderModel      分类title Model\n- View                     基础UI层 主要提供基础的视图 (基础View层)\n\t- view\t               自定义View\n- Cell                     Cell (cell集合)\n\t- CartTableViewCell    公共集合\n\t- CartHeaderTableCell  头视图cell\n- ViewModel                ViewModel 主要完成针对控制器的拆分 (相当于业务；逻辑层)\n\t- CartViewModel        内部封装了购物车相关的各种业务逻辑（数据拉取、数据更新、数据删除）\n- Controller \t\t       控制器胶水层  (控制器层)\n```\n###### API层\n客户端API层职能类似于传统的数据访问层，这里封装了基本的网络请求对象、service地址以及，回调处理等，等操作。API层主要用于ViewModel层的调用，关于客户端请求交互的模块全部都是由API层来完成，此处完主要成了业务模块针对网络请求层次的剥离抽取。\n\n```\n@class RequestModel;\n@interface BaseAPI : NSObject\n{\n    AFHTTPSessionManager *_manager;\n    RequestModel         *_requestModel;\n}\n\n@property (nonatomic,strong,readonly) RequestModel *requestModel;\n\n- (NSString *)serverURL;\n- (NSString *)functionID;\n- (NSDictionary *)params;\n\n- (void)startWithCompletionBlockWithSuccess:(void (^)(NSDictionary *content))success\n                                    failure:(void (^)(NSError *error))failure;\n- (void)stop;\n\n@end\n\n@interface RequestModel : NSObject\n\n@property (nonatomic,strong) NSString *serverURL;\n@property (nonatomic,strong) NSString *functionID;\n@property (nonatomic,strong) NSDictionary *params;\n\n@end\n\n```\n\n##### 基础协议层\n这个地方主要提供了三个对应的协议，之所以使用抽象协议，此处省略了继承。\n\nCartProbeProtocol   主要交付TableViewCell来实现\nCartRenderProtocol  主要交付具体要绘制的Model来实现\nCartFloorProtocol   主要交付大楼层符合Model来实现\n\n此处使用协议的形式，主要是为了能够完成对象的协作性调用，在粘合剂控制器中，我们可以统一采用\nid<Cart***Protocol>的形式来操作具体的对象，而无需再关心具体的Model类型以及cell类型。\n\n##### Model 、Cell 、View层\n这些层次与MVC类似\n\n##### ViewModel层\nViewModel层是一个基于业务逻辑层面的剥离，主要提供一些增删改查的操作\n\n##### Controller器层次\n控制器主要起到胶水作用，控制器会组织View的与数据的融合。控制器中主要采用两种手段：\n一种是基本的楼层我们采用id<Cart***Protocol>的形式来统一操作，这一点遵循了运行时语言的特性（运行时才决定具体的对象的类型）。\n另一种是针对特定属性的功能，通过分类的形式来完成，尽最大限度的剥离控制器的逻辑。\n备注：（如关于导航上相关的所有逻辑，我们统一将这块的UI、操作、衔接、回调统一放在一个当前控制器的一个分类文件去完成，这样从文件分割上进一步分割原有控制器）。\n\n<<strong>创建分类的时间，最大限度的不要为系统级别的class创建分类，要尽量针对自己的某个自定义class创建分类，这一点尽量避免为系统级class创建分类引入多于的链接类型开销(有兴趣的可以研究下runtime相关东西，category的实现最后也是要讲分类方法加入method_list队列去的，如果分类给NSObject创建了分类，在世纪使用场景下，系统会给每个类都田间对应的方法，产生多于的函数链接、存储开销) </strong>>\n如下：\n\n```\n//#pragma mark - UITableViewDelegate,UITableViewDataSource\n- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView \n{\n    return [self.cartViewModel.list count];\n}\n\n- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section\n{\n    id<CartFloorProtocol> floor = self.cartViewModel.list[section];\n    return [floor numberOfModelInFloor];\n}\n\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    UITableViewCell *cell = nil;\n    id<CartFloorProtocol> floor = self.cartViewModel.list[indexPath.section];\n    cell = [tableView dequeueReusableCellProcessModel:floor indexPath:indexPath];\n    [(id<CartProbeProtocol>)cell setDelegate:self];\n    return cell;\n}\n- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section\n{\n    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, SCREEN_WIDTH, 25)];\n    view.backgroundColor = [UIColor lightGrayColor];\n    return view;\n}\n\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    id<CartFloorProtocol> floor = self.cartViewModel.list[indexPath.section];\n    id<CartRenderProtocol> renderModel = [floor cartModelForRowIndexPath:indexPath];\n    Class<CartProbeProtocol> cellClass = NSClassFromString([renderModel cellIdentifier]);\n    return [cellClass calculateSizeWithData:renderModel];\n}\n\n```\n\n### 四、软件设计开发之展望\n\n软件设计的思路千变万化，终归到底没有具体绝对的好与坏之分，真正的选择还需要根据的具体的业务场景来决定，MVVM脱胎于MVC，如果是展示型的复杂业务类型来讲我个人更偏重于MVP的模式来实现(具体参照[基于面向协议MVP模式下的软件设计－iOS篇\n](http://www.cocoachina.com/ios/20151223/14768.html)，这一点针对模块化进行分割处理，严格的讲不通的逻辑快分割，提高了程序的健壮性)；\n如果是针对具有复杂操作性的业务类型的场景，我个人偏重于MVVM，处理复杂交互逻辑。采用传统业务逻辑抽离的规则来处理客户端的逻辑，这一点绰绰有余。\n\n任何一种软件构思都是在具体的实践中一步步的出的。纵观整个软件的发展，无一不是如此。无论是中文还是外文其实大家都有自己的见解，关于MVVM的文章其实的确有不少外文的，之前我也认真研读过一些。任何一种事务我们最终都是需要有自己独特一面见解的，只有不断的总结学习别人观点，不断的进行融汇升华，最终走出一条自己的路。这一点始终如此，也只有这样在某一点上我们才可能做到超越以往....","slug":"protocol_mvvm","published":1,"updated":"2016-02-01T06:12:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cik7x6pmn000livc3rlsmxm1r"},{"layout":"post","title":"基于面向协议MVP模式下的软件设计－iOS篇 ","subtitle":"基于面向协议MVP模式下的软件设计－iOS篇 ","date":"2015-12-21T16:00:00.000Z","author":"Scenery","keywords":"MVP 面向协议编程 业务分离 MVC＋ 基于面向协议MVP模式下的软件设计 设计模式","description":"第一次听到MVC这个名词是在C#中，相信做对于MVC大家都已经很熟悉了，作为一种软件设计模式，MVC这个概念已经诞生好多年了，模型-视图-控制器（Model-View-Controller，MVC）是Xerox PARC在20世纪80年代为编程语言Smalltalk－80发明的一种软件设计模式，至今已广泛应用于用户交互应用程序中。在iOS开发中MVC的机制被使用的淋漓尽致，充分理解iOS的MVC模式，有助于我们程序的组织合理性","header-img":"img/post-bg-alitrip.jpg","_content":"\n\n\n> * 传统模式下的开发\n> * 基于面向协议MVP的介绍\n> * MVP实战开发\n\n## 软件设计鼻祖MVC\n\n### MVC \n  \n第一次听到MVC这个名词是在C#中，相信做对于MVC大家都已经很熟悉了，作为一种软件设计模式，MVC这个概念已经诞生好多年了，\n\n模型-视图-控制器（Model-View-Controller，MVC）是Xerox PARC在20世纪80年代为编程语言Smalltalk－80发明的一种软件设计模式，至今已广泛应用于用户交互应用程序中。在iOS开发中MVC的机制被使用的淋漓尽致，充分理解iOS的MVC模式，有助于我们程序的组织合理性。\n\nModel-View-Controller\n\n模型对象\n\n模型对象封装了应用程序的数据，并定义操控和处理该数据的逻辑和运算。例如，模型对象可能是表示游戏中的角色或地址簿中的联系人。用户在视图层中所进行的创建或修改数据的操作，通过控制器对象传达出去，最终会创建或更新模型对象。模型对象更改时（例如通过网络连接接收到新数据），它通知控制器对象，控制器对象更新相应的视图对象。\n\n视图对象\n\n视图对象是应用程序中用户可以看见的对象。视图对象知道如何将自己绘制出来，并可能对用户的操作作出响应。视图对象的主要目的，就是显示来自应用程序模型对象的数据，并使该数据可被编辑。尽管如此，在 MVC 应用程序中，视图对象通常与模型对象分离。\n\n在iOS应用程序开发中，所有的控件、窗口等都继承自 UIView，对应MVC中的V。UIView及其子类主要负责UI的实现，而UIView所产生的事件都可以采用委托的方式，交给UIViewController实现。\n\n控制器对象\n\n在应用程序的一个或多个视图对象和一个或多个模型对象之间，控制器对象充当媒介。控制器对象因此是同步管道程序，通过它，视图对象了解模型对象的更改，反之亦然，控制器主要负责数据的传递解耦等工作。控制器对象还可以为应用程序执行设置和协调任务，并管理其他对象的生命周期。\n\n控制器对象解释在视图对象中进行的用户操作，并将新的或更改过的数据传达给模型对象。模型对象更改时，一个控制器对象会将新的模型数据传达给视图对象，以便视图对象可以显示它。\n\nModel和View永远不能相互通信，只能通过Controller传递。\nController可以直接与Model对话（读写调用Model），Model通过Notification和KVO机制与Controller间接通信。\nController可以直接与View对话，通过outlet,直接操作View,outlet直接对应到View中的控件,View通过action向Controller报告事件的发生(如用户Touch我了)。Controller是View的直接数据源（数据很可能是Controller从Model中取得并经过加工了）。Controller是View的代理（delegate),以同步View与Controller。\n\n### 新生儿MVVM\n\n在经历了一大堆吐槽之后，诞生了MVVM(一个高大尚牛逼哄哄的名词，从此又多了一种人，你懂MVVM ？如果你的回答是否，瞬间被鄙视一把)\n\n如果你已经开发一段时间的iOS应用，你一定听说过Model-View-Controller，即MVC。MVC是构建iOS App的标准模式。然而，最近我已经越来越厌倦MVC的一些缺点。在本文，我将重温一下MVC是什么，详述它的缺点，并且告诉你一个新的方式来架构你的App：Model-View-ViewModel。因为我们即将进行一次范式转变。\n \nModel-View-Controller\nModel-View-Controller是一个用来组织代码的权威范式。Apple甚至是这么说的。在MVC下，所有的对象被归类为一个model，一个view，或一个controller。Model持有数据，View显示与用户交互的界面，而View Controller调解Model和View之间的交互。\n\n在上图中，view将用户交互通知给controller。view controller通过更新model来反应状态的改变。model（通常使用Key-Value-Observation）通知controller来更新他们负责的view。大多数iOS应用程序的代码使用这种方式来组织。\n \n模型model的对象通常非常非常的简单。很多时候，他们就是Core Data managed objects，或者避免使用Core Data，就是其他流行的数据模型层。根据Apple的文档，model包括数据和操作数据的业务逻辑。在实践中，model层往往非常薄，不管怎样，model层的业务逻辑被拖入了controller。\n \n视图view通常是UIKit控件（component，这里根据习惯译为控件）或者编码定义的UIKit控件的集合。进入.xib或者Storyboard会发现一个app、Button、Label都是由这些可视化的和可交互的控件组成。你懂的。View不应该直接引用model，并且仅仅通过IBAction事件引用controller。业务逻辑很明显不归入view，视图本身没有任何业务。\n \n还有控制器controller。Controller是app的“胶水代码”：协调模型和视图之间的所有交互。控制器负责管理他们所拥有的视图的视图层次结构，还要响应视图的loading、appearing、disappearing等等，同时往往也会充满我们不愿暴露的model的模型逻辑以及不愿暴露给视图的业务逻辑。这引出了第一个关于MVC的问题...\n \n厚重的View Controller\n由于大量的代码被放进view controller，导致他们变的相当臃肿。在iOS中有的view controller里绵延成千上万行代码的事并不是前所未见的。这些超重app的突出情况包括：厚重的View Controller很难维护（由于其庞大的规模）；包含几十个属性，使他们的状态难以管理；遵循许多协议（protocol），导致协议的响应代码和controller的逻辑代码混淆在一起。\n \n厚重的view controller很难测试，不管是手动测试或是使用单元测试，因为有太多可能的状态。将代码分解成更小的多个模块通常是件好事。\n \n遗失的网络逻辑\n苹果使用的MVC的定义是这么说的：所有的对象都可以被归类为一个model，一个view，或是一个controller。就这些。那么把网络代码放哪里？和一个API通信的代码应该放在哪儿？\n \n你可能试着把它放在model对象里，但是也会很棘手，因为网络调用应该使用异步，这样如果一个网络请求比持有它的model生命周期更长，事情将变的复杂。显然也不应该把网络代码放在view里，因此只剩下controller了。这同样是个坏主意，因为这加剧了厚重View Controller的问题。\n \n那么应该放在那里呢？显然MVC的3大组件根本没有适合放这些代码的地方。\n \n较差的可测试性\nMVC的另一个大问题是,它不鼓励开发人员编写单元测试。由于view controller混合了视图处理逻辑和业务逻辑，分离这些成分的单元测试成了一个艰巨的任务。大多数人选择忽略这个任务，那就是不做任何测试。\n \n定义模糊的“Manage”\n之前我提到了view controller可以管理试图的层次结构；view controller有一个“view”属性，并且可以通过IBOutlet访问视图的任何子视图。当有很多outlet时这样做不易于扩展，在某种意义上，最好不要使用子视图控制器（child view controller）来帮助管理子视图（subview）。\n \n要点在哪？验证用户输入的业务逻辑应归入controller还是model呢？\n \n在这里有多个模糊的标准，似乎没有人能完全达成一致。貌似无论如何，view和对应的controller都紧紧的耦合在一起，总之，还是会把它们当成一个组件来对待。\n \nHey！现在有个点子...\n \nModel-View-ViewModel\n在理想的世界里，MVC也许工作的很好。然而，我们生活在真实的世界。既然我们已经详细说明了MVC在典型场景中的问题，那让我们看一看一个可供替换的选择：Model-View-ViewModel。\n \nMVVM来自微软，不过不要坚持反对它。MVVM和MVC很像。它正式规范了视图和控制器紧耦合的性质，并引入新的组件。\n\n在MVVM里，view和view controller正式联系在一起，我们把它们视为一个组件。视图view仍然不能直接引用模型model，当然controller也不能。相反，他们引用视图模型view model。\n \nview model是一个放置用户输入验证逻辑，视图显示逻辑，发起网络请求和其他各种各样的代码的极好的地方。有一件事情不应归入view model，那就是任何视图本身的引用。view model的概念同时适用于于iOS和OS X。（换句话说，不要在view model中使用 #import UIKit.h）\n \n由于展示逻辑（presentation logic）放在了view model中（比如model的值映射到一个格式化的字符串），视图控制器本身就会不再臃肿。当你开始使用MVVM的最好方式是，可以先将一小部分逻辑放入视图模型，然后当你逐渐习惯于使用这个范式的时候再迁移更多的逻辑到视图模型中。\n \n使用MVVM的iOS app是高度可测试的；因为view model包含了所有的展示逻辑并且不会引用view，所以它可以通过编程方式充分测试。虽然有众多的hack技术参与到测试Core Data模型，但使用MVVM写的app可以进行充分的单元测试。\n \n以我的经验，使用MVVM会轻微的增加代码量，但总体上减少了代码的复杂性。这是一个划算的交易。\n \n回过头再来看MVVM的图示，你会注意到我使用了模糊的动词“notify”和“update”，而没有详细说明该怎么做。你可以使用KVO，就像MVC那样，但这很快就会变得难以管理。事实上，使用ReactiveCocoa会是更好的方式来组织各个部分。\n \n关于怎么结合ReactiveCocoa来使用MVVM的信息，可以阅读Colin Wheeler的excellent write-up或者看看我写的开源app。你也可以阅读我的关于ReactiveCocoa和MVVM的书。\n  \n## 基于面向协议MVP的介绍\n\n曾降有无数个人总喜欢问我你们的iOS采用什么样的架构，其实每次被问到这样的问题，不是瞬间被萌了，就是想自己问自己iOS也有架构？？\n\n上文提到了MVC、MVVM，真实的业务场景中，如果场景的逻辑异常复杂，在反复的迭代中仍会出现各式各样的问题。真对MVVM我个人理解主要是将原来Controller中处理数据逻辑的代码统一归到一个新的class(viewModel)中去，更甚之网络请求等工作全部从Controller移到viewModel。刚一开始总觉的怪怪的。现阶段客户端开发越来越进入一个2.0的阶段，早期的app功能都相对比较简单，无论是从界面还是从业务逻辑上给人的感觉都是简洁实用，这中间包括UI的设计、功能的设计、产品的设计定位等。随着行业的深入，用户的过渡依赖移动端最终导致业各式各样的业务更加依赖客户端，这就导致客户端的开发不得不向PC端靠齐，在版本的反复迭代中业务场景变的愈发不尽人意，仿佛又回到了软件设计的早期。\n\n在传统软件领域，从MVC的诞生主要是为了解决软件界面的行为的分离，在复杂的业务场景内会进一步区分业务逻辑场景的分离，这些手段的最终的目的都是尽最大限度的降低整个场景的藕合度，使其达到分离的目的，模块与模块最终得到独立，将整个场景化整为零，最终使每个模块在一个零上工作，这对于无论是软件的开发还是后续的维护、以及使用普遍遵循这个原则，现有的模式大概产生了相关的类似架构。\n\n传统web架构里面是这样解决的 : \n\n![service](/images/2015-12-16/MVP/service.png) \n\n\nweb段以及其他业务层负责从接口层获取数据 并执行自己的逻辑\nservice层为外部提供接口\nDTO从负责从DB链接并进行数据读写操作\nDB层(物理机器负责数据存储)\n\n现有客户度一度采用下面的模式:\n\n![MVC](/images/2015-12-16/MVP/mvc.png) \n\n客户端通过service拿到json 数据，然后通过MVC的结构展示到UI界面上，在iOS中一直流行MVC的开发模式，通过与传统开发模式对比可以发现，其实\nservice层与客户端无非是两个互逆的过程，service层根据具体的业务场景提供对应的数据服务，service根据不同的业务场景通过DTO层拿到对应\n的数据然后组织好数据提供给外界(service 层负责将原始物理数据转换成对应的逻辑数据提供给外界)。\n\n相反。客户端通过网络层拿到对应的网络数据绘制到对应的View上，但是实际的开发过程中，网络数据与真实客户端使用场景也是有一定的差距，MVVM层将对应的\n一部分逻辑处理移植到了ViewModel中，这并没有从根本上解决问题，无非是将代码做了一份对应的copy转移，并没有从根本上达到逻辑分层的概念。相反MVP模\n式恰好解决了这一难题，MVP模式衍生于传统service架构，针对不同的业务场景图供对应的匹配的抽象service服务，客户端拿到网络数据后未达到指定的目的，\n为满足相同抽象逻辑的业务场景，在客户端网络层与model层之间加一协议层，model层实现整个协议层，之后在基于MVC的结构下将一概相同层次的\n业务场景绘制解释到对应的View上。\n\n![MVP](/images/2015-12-16/MVP/mvp.png) \n\nM : 逻辑model\nV : 视图\nP : protocol协议层\n\nModel层类似于MVVM的ViewModel，主要负责存储抽象逻辑数据，另外Model层主还有部分工作实现对应的协议层协议，提供\n协议对应的各种属性以及服务。Model经过协议层抽象约束，最后model被抽象成具有统一抽象逻辑的业务场景，最终model层在讲数据交付整个MVC结构绘制展示的时间，\n我们可以按照同一套抽象的逻辑标准去执行。\n\n在传统的web层面，为了满足各式各样的业务逻辑场景服务，最红我们实现软件罗杰的层次的分离，诞生了service服务这个概念(service就类似一个标准尺寸的水龙头出口，\n只要对应的水龙头都按照这样的规则来生产，service就能够满足格式各样的业务场景，极大的解决的传统软件服务业务场景层次的一系列难题)；相同的原理在客户端同样可以使用，\n为了满足客户端MVC结构层里面的稳定，避免各式各样的业务场景迭代插入不同的逻辑，避免最终软件危机的产生，我们采用追加协议层的模式来满足这一目的。\n\n遍观整个软件开发，从早期的软件开发，到后来软件生产管理的危机，软件开发模式一步步的确立，软件行业的每个阶段都是一个里程碑。这世间没有相对完美独到的设计法则，但是亘古不变永远只有一个那就是软件的开发更佳面相生产化、规范化、更加的利于可维护化。一直以来我本人并不特别的注重软件的设计一定、必须按照某种规则来做，毕竟不同的人、不同的业务场景、不同的工程师总有不同的实际境况，站在一个开发工程师的角度来说我并不固执于都按照固定的规则来(比如说你必须按照某个模式来做，必须用MVVM来做；必须用ReactCocoa信号型机制来做...)。相反我个人认为太过于固执只不过某些人的一厢情愿的罢了。相反我觉得因地制宜、应运而生岂不更加快哉，设计不拘于模式，更多时间更是不局限于思考。无论是MVVM、MVP哪一个不是脱胎于MVC，这个时间万变不离其宗，就像万千功法最终都离不开一步母经。\n\n\n## MVP实战开发\n\n说了这么多，下面上实战例子。\n大概描述一下业务场景，作为电商app，我们希望在原生的基础上开发一套定制的可控、可配、可维护的通用型原生模版(至于说的这么灵活 有多么的好，为啥不用H5、ReactNative,这个问题不要来问我,产品狗们让做原生，程序员只能执行)。大概是这样一个场景，可以配置的楼层样式多达十几种(至少目前已经有十几种,以后可能会更多)；每种可配置楼层样式是多元的，外观长相不一，数据格式也不尽相同但有部分类同；要求后台CMS配置界面配置法则有共同相似之处；要求每种样式楼层处理事件记忆跳转不尽相同；最可恨的页面已经很长了以后会源源不断加入新的模版。\n考虑到长远，这样的复杂楼层，如果仍旧按照传统的模式来做，问题会很多，数据无法统一、无法统一绘制、无法统一处理。具体场景相信大家应该理解了。\n\n上设计思路\n\n潜在问题\n\n* server段需要针对不同的楼层场景下发不同的数据，数据结构不尽相同\n* 模版楼层样式不尽相同，可能对应多种View\n* 多种View与多种数据结构的解释解耦问题\n* 多种业务场景用户操作逻辑处理问题\n* 楼层过于负责 Controller大爆炸\n\n逻辑建模分析\n\n* 暂时可以将每种模版楼层的整体数据作为一个容器Modle,主要负责该楼层的整体数据调度  \n\n* 将每种楼层公有的属性以及内容抽象出来放入一个容器父类，然后将不同模版特有的属性放在子模版派生Model中，作为派生属性\n\n* 对准一个容器类，我可以将每种容器Model的使用法则抽象总结归纳(1、楼层是否有Header，是否要吸顶；2、楼层是否有分享 ； 3、楼层内容是绘制在单个section单个cell中还是绘制在多行上； 4、每个楼层的元素点击跳转处理等)，我们将容器这块作为一个数据源概念最终抽象出一套可供外界获取数据的Interface(Protocol)\n\n* 最准每一个派生容器，我们都要求它去实现上述Protocol，通过协议我们可以知道具体的绘制的目标，以及要绘制的元素个数等，最终达到一个目的，\n 将每个楼层的数据装配在我们定义好的一个适配器容器内，然后通过协议给外界提供一套统一的操作入口，之后我们才用统一的操作方式操作容器，\n 实现一个容器－一个楼层\n \n* Render 协议，在这个我们对准每个要具体绘制到UI上的Model，我们统一让其实现Render协议，通过适配器容器我们我们拿到具体要绘制的目标，\n 目标绘制题都实现了Render协议，在Render协议我们可以拿到具体当前Model将由哪个具体的Cell去呈递。在每个绘制目标题内由model决定\n 当前内容由什么样式的cell模版去绘制。我们把所有的楼层数据处理逻辑压在适配器容器内，再将model的绘制目标都交由model自己决定。\n\n* 实现上述目标后，在ViewController层面，我们看到的只有一个实现了适配器协议的Model数组，在 table的绘制过程我们通过操作一个\n id<适配器Protocol> 类型的Model对象， 拿到这个具体的索引对应的对象后，通过内部已经实现的协议我们很快的拿到下一个要绘制的目标Model\n 然后再拿到具体的Cell模版的Identifier，然后从tableview中取到当前Identifier对应的cell模版，传入数据最后返回一个cell。\n\n分析场景，下面来分析一个模版的例子来说命一切吧！！\n\n这个地方我们先定义了一个适配容器协议，以及一个父容器类，我们将楼层公有属性放在父类中，并且实现一个抽象协议\n\n### Protocol 设计\n\nrender 协议\n\n* \t－TemplateRenderProtocol   \t\t//任何一个具体绘制到cell上的Model都需要实现该协议\n* \t－TemplateSpecialRenderProtocol  //楼层的header如果要吸顶需要使用该协议替代基本的Render协议\n* \t－TemplateActionProtocol\t\t\t//具有Action 操作的Model需要实现，返回一个通用的Action对象\n* \t－TemplateCellProtocol\t\t\t//整个体系中所有的Cell统一实现该协议\n\nViewController\n*\t- 楼层显示统一交与Model层定制\n*\t- VC中生成ActionModel,跳转逻辑全部应用于Action协议层，ViewController实现ActionManager 代理，作为回调处理\n*\t- 特定属性处理逻辑放在分类内\n*\t- 网络层调用扔保持在ViewController,这一点与传统保持相似，有利于结构分明(优于市面上的所谓MVVM)\n\n\n```\n//TemplateRenderProtocol.h\n@protocol TemplateRenderProtocol <NSObject,TemplateActionProtocol>\n\n- (NSString *)floorIdentifier;\n\n@end\n\n//TemplateSpecialRenderProtocol.h\n@protocol TemplateSpecialRenderProtocol <NSObject>\n\n- (NSString *)headerFloorIdentifier;\n- (id <TemplateSpecialRenderProtocol>)headerFloorModelAtIndex:(NSInteger)index;\n\n@end\n\n\n//TemplateActionProtocol.h\n */\n@protocol TemplateActionProtocol <NSObject>\n\n@optional\n\n- (TemplateJumpModel *)jumpFloorModelAtIndexPath:(NSIndexPath *)indexPath;\n\n@end\n\n\n//TemplateCellProtocol.h\n@protocol TemplateCellProtocol <NSObject>\n\n+ (CGSize)calculateSizeWithData:(id<TemplateRenderProtocol>)data constrainedToSize:(CGSize)size;\n\n- (void)processData:(id <TemplateRenderProtocol>)data;\n\n@end\n\n```\n\n\n\n### Model设计\n\n```\n//  TemplateContainerModel.h\n\n/**\n *  容器概念\n */\n@protocol TemplateContainerProtocol <NSObject>\n\n@required\n\n- (NSInteger)numberOfChildModelsInContainer;\n\n- (id <TemplateRenderProtocol>)childFloorModelAtIndex:(NSInteger)index;\n\n@end\n\n@class TemplateChannelModel;\n@interface TemplateContainerModel : NSObject<TemplateContainerProtocol,TemplateActionProtocol,TemplateRenderProtocol>\n\n//netList\n@property (nonatomic,strong) NSNumber                 *identityId;\n@property (nonatomic,strong) NSString                 *pattern;\n@property (nonatomic,strong) TemplateFHeaderModel     *fheader;\n@property (nonatomic,strong) NSArray                  *itemList;\n@property (nonatomic,strong) TemplateJumpModel        *jump;\n@property (nonatomic,strong) TemplateMarginModel      *margin;\n//other add\n@property (nonatomic,assign) TemplateChannelModel     *channelModel;\n@end\n\n```\n\n下面的就先引用一个具体的业务场景吧，顶部banner楼层，每个大的楼层都是一个容器Model，是继承于父容器，并且会适当重写父类协议以及方法\n\n```\n//TemplateFloorFocusModel.h\n\n//此处，banner是多个对象绘制成轮播的样式，整体是绘制在同一个cell上的，所以TemplateFloorFocusModel首先是一个容器类，是具有数据源的\n功能，但是他又是一个绘制目标model，TemplateFloorFocusModel实现了Render协议，就决定这个接下来会将TemplateFloorFocusModel绘制到UI界面上(如果此处的容器存储的是一个section下的list形式，容器类就无需实现render协议，只需要将list 中的Model实现render协议即可)\n\n@interface TemplateFloorFocusModel : TemplateContainerModel<TemplateRenderProtocol>\n\n@property (nonatomic,assign) NSNumber *width;\n@property (nonatomic,assign) NSNumber *height;\n\n@end\n\n\n//TemplateFloorFocusModel.m\n\n@implementation TemplateFloorFocusModel\n\n+ (NSDictionary *)mj_replacedKeyFromPropertyName\n{\n    return @{\n             @\"itemList\" : @\"picList\"\n             };\n}\n\n+ (NSDictionary *)mj_objectClassInArray\n{\n    return @{\n             @\"itemList\" : @\"TemplatePicModel\"\n             };\n}\n\n//pragma mark - TemplateContainerProtocol\n\n- (NSInteger)numberOfChildModelsInContainer\n{\n    NSUInteger rows = 0;\n    if (self.margin) rows++;\n    if (self.itemList) rows++;\n    return rows;\n}\n\n//(如果此处的容器存储的是一个section下的list形式，此处返回一个实现render协议的model即可)\n- (id <TemplateRenderProtocol>)childFloorModelAtIndex:(NSInteger)index\n{\n    if ((self.margin)&&(index+1) == [self numberOfChildModelsInContainer])\n        return self.margin;  //最后一行\n    return self;\n}\n\n//pragma mark - TemplateJumpProtocol\n\n- (TemplateJumpModel *)jumpFloorModelAtIndexPath:(NSIndexPath *)indexPath\n{\n    return nil;\n}\n\n//pragma mark -  TemplateRenderProtocol\n- (NSString *)floorIdentifier\n{\n    return @\"TemplateFocusCell\";\n}\n\n```\n\n\n### View 设计\n\nView设计此处我们才用方式依旧是将Cell作为模版，将对应的视图逻辑统一放在一个UIViewSubView中， 之后在Cell中将View直接add到cell.ContentView上。\n\n针对焦点图cell TemplateFocusCell我们有一个TemplateFocusView来对应，下面看下代码设计\n\nTemplateFocusCell\n\n```\n// TemplateFocusCell\n@interface TemplateFocusCell : UITableViewCell<TemplateCellProtocol>\n\n@end\n\n@interface TemplateFocusCell (){\n    TemplateFocusView *_focusView;\n}\n\n@property (nonatomic,strong) id <TemplateRenderProtocol> data;\n\n@end\n@implementation TemplateFocusCell\n\n- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier\n{\n    self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];\n    \n    if (self) {\n        _focusView = [[TemplateFocusView alloc] init];\n        _focusView.translatesAutoresizingMaskIntoConstraints = NO;\n        [self.contentView addSubview:_focusView];\n       }\n    return self;\n}\n\n- (void)processData:(id <TemplateRenderProtocol>)data\n{\n    if([data isKindOfClass:[TemplateFloorFocusModel class]])\n    {\n        self.data = data;\n        [_focusView processData:(id <TemplateRenderProtocol>)data];\n    }\n}\n\n+ (CGSize)calculateSizeWithData:(id<NSObject>)data constrainedToSize:(CGSize)size\n{\n//    id<TemplateRenderProtocol> model = data;\n    CGSize curSize = CGSizeMake(ScreenWidth, 110);\n    return curSize;\n}\n\n```\n\nTemplateFocusView \n\n```\n\n@interface TemplateFocusView : UIView<TemplateCellProtocol>\n\n@end\n\n@interface TemplateFocusView ()<iCarouselDataSource,iCarouselDelegate>\n{\n    UIPageControl *_pageControl;\n    iCarousel     *_scrollView;\n}\n\n@property (nonatomic,strong) TemplateFloorFocusModel *focusModel;\n@end\n\n@implementation TemplateFocusView\n\n- (instancetype)init\n{\n    self = [super init];\n    \n    if (self)\n    {\n        _scrollView = [[iCarousel alloc] init];\n        _scrollView.delegate = self;\n        _scrollView.dataSource = self;\n        _scrollView.type = iCarouselTypeLinear;\n        _scrollView.pagingEnabled = YES;\n        _scrollView.bounceDistance = 0.5;\n        _scrollView.decelerationRate = 0.5;\n        _scrollView.clipsToBounds = YES;\n        _scrollView.translatesAutoresizingMaskIntoConstraints = NO;\n        [self addSubview:_scrollView];\n        \n        _pageControl = [[UIPageControl alloc] init];\n        _pageControl.translatesAutoresizingMaskIntoConstraints = NO;\n        [self addSubview:_pageControl];\n            \n        [_scrollView mas_makeConstraints:^(MASConstraintMaker *make){\n            make.edges.equalTo(self).insets(UIEdgeInsetsZero);\n        }];\n        \n        [_pageControl mas_makeConstraints:^(MASConstraintMaker *make){\n            make.bottom.mas_equalTo(@(5));\n            make.centerX.equalTo(self);\n        }];\n    }\n    return self;\n}\n\n+ (CGSize)calculateSizeWithData:(id<TemplateRenderProtocol>)data constrainedToSize:(CGSize)size\n{\n    return size;\n}\n\n- (void)processData:(id <TemplateRenderProtocol>)data\n{\n    self.focusModel = (TemplateFloorFocusModel *)data;\n    _pageControl.numberOfPages = self.focusModel.itemList.count;\n    [_scrollView reloadData];\n    \n    [self layoutIfNeeded];\n}\n\n//pragma mark -\n- (NSInteger)numberOfItemsInCarousel:(iCarousel *)carousel\n{\n    return _focusModel.itemList.count;\n}\n\n- (UIView *)carousel:(iCarousel *)carousel viewForItemAtIndex:(NSInteger)index reusingView:(UIView *)view\n{\n    UIImageView *imageView = nil;\n    if (!view) {\n        imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, ScreenWidth, ScreenWidth/2)];\n        imageView.contentMode = UIViewContentModeScaleAspectFit;\n        }else{\n        imageView = (UIImageView *)view;\n    }\n   \n    TemplatePicModel *model = self.focusModel.itemList[index];\n    [imageView setImageWithURL:[NSURL URLWithString:model.img]];\n    return imageView;\n}\n\n- (CGFloat)carousel:(iCarousel *)carousel valueForOption:(iCarouselOption)option withDefault:(CGFloat)value\n{\n    if (option == iCarouselOptionWrap)\n    {\n        return YES;\n    }\n    return value;\n}\n\n- (void)carouselDidEndScrollingAnimation:(iCarousel *)carousel\n{\n    NSInteger index = _scrollView.scrollOffset;\n    \n    [_pageControl setCurrentPage:index];\n}\n\n```\n\n\n从View层可以看到，我们仍旧遵循以往的模式，将cell高度的计算，最终放在View中来完成(此处我们并没有Model化，而是仍旧遵循大家的习惯，具体的高度根据具体的视图场景来控制)，看到此处的计算高度的方法，接下来的问题就不多说了....\n\n\n###  Controller 设计\n\n在做完以上的一些列的逻辑化抽象工作以后，从新回到控制器层面，此时应该是大松了一口气了，到目前为止，我们一大堆系列的工作都已经做完了，只是还有一点失望的感觉是暂时还没看到是否真的有卵用，这就好比十年铸一剑，继而十年在磨一剑，看不到成效始终觉得心中似有亏欠。\n\n到目前为止，我们在控制器层面能做的仅有的是范型数据的操作，已经安全没有逻辑了，逻辑全部压入了model，下面就看下控制器层面的逻辑：\n\n```\n//注册cell\n\n[self.tableView registerClass:[TemplateFocusCell class] forCellReuseIdentifier:@\"TemplateFocusCell\"];\n\n\n//tableView 代理实现\n\n- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView\n{\n    return [self.floorModel.floors count];\n}\n\n- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section\n{\n    TemplateContainerModel<TemplateContainerProtocol> *list = self.floorModel.floors[section];\n    \n    return [list numberOfChildModelsInContainer];\n}\n\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    id <TemplateRenderProtocol> model = [self.floorModel rowModelAtIndexPath:indexPath];\n    \n    UITableViewCell <TemplateCellProtocol> * cell = [tableView dequeueReusableCellWithIdentifier:[model floorIdentifier]];\n    \n    [cell processData:model];\n    \n    if(!cell){\n        return [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:nil];\n    }else{\n        return (UITableViewCell *)cell;\n    }\n}\n\n- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    WebViewController *webViewController = [[WebViewController alloc] initWithUrl:nil];\n    [NavigateManager pushViewController:webViewController];\n}\n\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{\n    \n    id <TemplateRenderProtocol>  floor = [self.floorModel rowModelAtIndexPath:indexPath];\n    if ([floor respondsToSelector:@selector(floorIdentifier)]) {\n        NSString *cellIdentifier = [floor floorIdentifier];\n        Class<TemplateCellProtocol> viewClass = NSClassFromString(cellIdentifier);\n        CGSize size = [viewClass calculateSizeWithData:floor constrainedToSize:CGSizeMake(tableView.frame.size.width, 0.0)];\n        return size.height;\n    }\n    return 0;\n}\n\n- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section\n{\n    id <TemplateSpecialRenderProtocol,TemplateRenderProtocol> floor = self.floorModel.floors[section];\n    if ([floor conformsToProtocol:@protocol(TemplateSpecialRenderProtocol)]) {\n        NSString *headerIdentifier = [floor headerFloorIdentifier];\n        if (headerIdentifier) {\n            Class<TemplateCellProtocol> viewClass = NSClassFromString(headerIdentifier);\n            CGSize size = [viewClass calculateSizeWithData:floor constrainedToSize:CGSizeMake(tableView.frame.size.width, 0.0)];\n            return size.height;\n        }\n    }\n\n    return 0;\n}\n\n- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section\n{\n    id <TemplateSpecialRenderProtocol,TemplateRenderProtocol> floor = self.floorModel.floors[section];\n    \n    if ([floor conformsToProtocol:@protocol(TemplateSpecialRenderProtocol)]) {\n        id<TemplateSpecialRenderProtocol> headerModel = [floor headerFloorModelAtIndex:section];\n        if (headerModel) {\n            NSString *identifier = [headerModel headerFloorIdentifier];\n            UIView <TemplateCellProtocol> *headerView = (UIView <TemplateCellProtocol> *)[tableView dequeueReusableHeaderFooterViewWithIdentifier:identifier];\n            [headerView processData:floor];\n//            if ([headerView respondsToSelector:@selector(tapOnePlace:)]) {\n//                [headerView tapOnePlace:[self tapBlockForModel:headerModel]];\n//            }\n            \n            return headerView;\n        }\n    }\n    return nil;\n}\n\n```\n\n 至此，控制器只剩下以上操作，相对来说已经最大限度的梳理了逻辑，将所有的逻辑压入Model，如果服务端新增了新型的业务场景的数据，依旧可以通过协议层的适配，将数据最终的组装上述模式，最后直接拿来使用，如果需要修改对应的View，直接可以在Model内修改具体的将要渲染的View的名字即可，这些工作都跟控制器层没有任何关系。\n \n \n 在Action协议中，具有Action操作的Model会在世纪使用过程中实现这一协议，在事件处理的时间会抛出这样一个ActionModel,之后此处我们会直接\n \n Action对象handler操作，此处并没有控制器层面操作，这一点遵循了设计模式中的命令行模式(这一点原理脱胎于于strus框架中XWork框架，将控制器与UI工作无关的内务以命令行的模式跑出来，放在别的一个代理中去完成，这样能够最大的限度的做到对控制器层面的瘦身工作)。\n \n 说到控制器瘦身工作，iOS常用的大概是就是Category了，将部分全局型属性、逻辑放在对应的分类里面，有助于逻辑的抽离、代码的分割。\n\n\n容器模式 适配器模式 命令行模式\n\nMVVM (https://leanpub.com/iosfrp)\n\n\n\nhttp://blog.csdn.net/sqc3375177/article/details/11771823\nhttp://liuzhichao.com/p/1379.html\n\nhttp://www.cocoachina.com/ios/20140716/9152.html\nhttp://www.cocoachina.com/ios/20150122/10987.html\nhttp://www.cnblogs.com/xueduanyang/p/3601471.html\n\n[Model-View-Controller](http://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html#//apple_ref/doc/uid/TP40010810-CH14-SW1)","source":"_posts/mvp-ios.md","raw":"---\nlayout:     post\ntitle:      \"基于面向协议MVP模式下的软件设计－iOS篇 \"\nsubtitle:   \"基于面向协议MVP模式下的软件设计－iOS篇 \"\ndate:       2015-12-22\nauthor:     \"Scenery\"\nkeywords: \"MVP 面向协议编程 业务分离 MVC＋ 基于面向协议MVP模式下的软件设计 设计模式\"\ndescription: \"第一次听到MVC这个名词是在C#中，相信做对于MVC大家都已经很熟悉了，作为一种软件设计模式，MVC这个概念已经诞生好多年了，模型-视图-控制器（Model-View-Controller，MVC）是Xerox PARC在20世纪80年代为编程语言Smalltalk－80发明的一种软件设计模式，至今已广泛应用于用户交互应用程序中。在iOS开发中MVC的机制被使用的淋漓尽致，充分理解iOS的MVC模式，有助于我们程序的组织合理性\"\nheader-img: \"img/post-bg-alitrip.jpg\"\ntags:\n    - iOS\n    - 电子商务\n---\n\n\n\n> * 传统模式下的开发\n> * 基于面向协议MVP的介绍\n> * MVP实战开发\n\n## 软件设计鼻祖MVC\n\n### MVC \n  \n第一次听到MVC这个名词是在C#中，相信做对于MVC大家都已经很熟悉了，作为一种软件设计模式，MVC这个概念已经诞生好多年了，\n\n模型-视图-控制器（Model-View-Controller，MVC）是Xerox PARC在20世纪80年代为编程语言Smalltalk－80发明的一种软件设计模式，至今已广泛应用于用户交互应用程序中。在iOS开发中MVC的机制被使用的淋漓尽致，充分理解iOS的MVC模式，有助于我们程序的组织合理性。\n\nModel-View-Controller\n\n模型对象\n\n模型对象封装了应用程序的数据，并定义操控和处理该数据的逻辑和运算。例如，模型对象可能是表示游戏中的角色或地址簿中的联系人。用户在视图层中所进行的创建或修改数据的操作，通过控制器对象传达出去，最终会创建或更新模型对象。模型对象更改时（例如通过网络连接接收到新数据），它通知控制器对象，控制器对象更新相应的视图对象。\n\n视图对象\n\n视图对象是应用程序中用户可以看见的对象。视图对象知道如何将自己绘制出来，并可能对用户的操作作出响应。视图对象的主要目的，就是显示来自应用程序模型对象的数据，并使该数据可被编辑。尽管如此，在 MVC 应用程序中，视图对象通常与模型对象分离。\n\n在iOS应用程序开发中，所有的控件、窗口等都继承自 UIView，对应MVC中的V。UIView及其子类主要负责UI的实现，而UIView所产生的事件都可以采用委托的方式，交给UIViewController实现。\n\n控制器对象\n\n在应用程序的一个或多个视图对象和一个或多个模型对象之间，控制器对象充当媒介。控制器对象因此是同步管道程序，通过它，视图对象了解模型对象的更改，反之亦然，控制器主要负责数据的传递解耦等工作。控制器对象还可以为应用程序执行设置和协调任务，并管理其他对象的生命周期。\n\n控制器对象解释在视图对象中进行的用户操作，并将新的或更改过的数据传达给模型对象。模型对象更改时，一个控制器对象会将新的模型数据传达给视图对象，以便视图对象可以显示它。\n\nModel和View永远不能相互通信，只能通过Controller传递。\nController可以直接与Model对话（读写调用Model），Model通过Notification和KVO机制与Controller间接通信。\nController可以直接与View对话，通过outlet,直接操作View,outlet直接对应到View中的控件,View通过action向Controller报告事件的发生(如用户Touch我了)。Controller是View的直接数据源（数据很可能是Controller从Model中取得并经过加工了）。Controller是View的代理（delegate),以同步View与Controller。\n\n### 新生儿MVVM\n\n在经历了一大堆吐槽之后，诞生了MVVM(一个高大尚牛逼哄哄的名词，从此又多了一种人，你懂MVVM ？如果你的回答是否，瞬间被鄙视一把)\n\n如果你已经开发一段时间的iOS应用，你一定听说过Model-View-Controller，即MVC。MVC是构建iOS App的标准模式。然而，最近我已经越来越厌倦MVC的一些缺点。在本文，我将重温一下MVC是什么，详述它的缺点，并且告诉你一个新的方式来架构你的App：Model-View-ViewModel。因为我们即将进行一次范式转变。\n \nModel-View-Controller\nModel-View-Controller是一个用来组织代码的权威范式。Apple甚至是这么说的。在MVC下，所有的对象被归类为一个model，一个view，或一个controller。Model持有数据，View显示与用户交互的界面，而View Controller调解Model和View之间的交互。\n\n在上图中，view将用户交互通知给controller。view controller通过更新model来反应状态的改变。model（通常使用Key-Value-Observation）通知controller来更新他们负责的view。大多数iOS应用程序的代码使用这种方式来组织。\n \n模型model的对象通常非常非常的简单。很多时候，他们就是Core Data managed objects，或者避免使用Core Data，就是其他流行的数据模型层。根据Apple的文档，model包括数据和操作数据的业务逻辑。在实践中，model层往往非常薄，不管怎样，model层的业务逻辑被拖入了controller。\n \n视图view通常是UIKit控件（component，这里根据习惯译为控件）或者编码定义的UIKit控件的集合。进入.xib或者Storyboard会发现一个app、Button、Label都是由这些可视化的和可交互的控件组成。你懂的。View不应该直接引用model，并且仅仅通过IBAction事件引用controller。业务逻辑很明显不归入view，视图本身没有任何业务。\n \n还有控制器controller。Controller是app的“胶水代码”：协调模型和视图之间的所有交互。控制器负责管理他们所拥有的视图的视图层次结构，还要响应视图的loading、appearing、disappearing等等，同时往往也会充满我们不愿暴露的model的模型逻辑以及不愿暴露给视图的业务逻辑。这引出了第一个关于MVC的问题...\n \n厚重的View Controller\n由于大量的代码被放进view controller，导致他们变的相当臃肿。在iOS中有的view controller里绵延成千上万行代码的事并不是前所未见的。这些超重app的突出情况包括：厚重的View Controller很难维护（由于其庞大的规模）；包含几十个属性，使他们的状态难以管理；遵循许多协议（protocol），导致协议的响应代码和controller的逻辑代码混淆在一起。\n \n厚重的view controller很难测试，不管是手动测试或是使用单元测试，因为有太多可能的状态。将代码分解成更小的多个模块通常是件好事。\n \n遗失的网络逻辑\n苹果使用的MVC的定义是这么说的：所有的对象都可以被归类为一个model，一个view，或是一个controller。就这些。那么把网络代码放哪里？和一个API通信的代码应该放在哪儿？\n \n你可能试着把它放在model对象里，但是也会很棘手，因为网络调用应该使用异步，这样如果一个网络请求比持有它的model生命周期更长，事情将变的复杂。显然也不应该把网络代码放在view里，因此只剩下controller了。这同样是个坏主意，因为这加剧了厚重View Controller的问题。\n \n那么应该放在那里呢？显然MVC的3大组件根本没有适合放这些代码的地方。\n \n较差的可测试性\nMVC的另一个大问题是,它不鼓励开发人员编写单元测试。由于view controller混合了视图处理逻辑和业务逻辑，分离这些成分的单元测试成了一个艰巨的任务。大多数人选择忽略这个任务，那就是不做任何测试。\n \n定义模糊的“Manage”\n之前我提到了view controller可以管理试图的层次结构；view controller有一个“view”属性，并且可以通过IBOutlet访问视图的任何子视图。当有很多outlet时这样做不易于扩展，在某种意义上，最好不要使用子视图控制器（child view controller）来帮助管理子视图（subview）。\n \n要点在哪？验证用户输入的业务逻辑应归入controller还是model呢？\n \n在这里有多个模糊的标准，似乎没有人能完全达成一致。貌似无论如何，view和对应的controller都紧紧的耦合在一起，总之，还是会把它们当成一个组件来对待。\n \nHey！现在有个点子...\n \nModel-View-ViewModel\n在理想的世界里，MVC也许工作的很好。然而，我们生活在真实的世界。既然我们已经详细说明了MVC在典型场景中的问题，那让我们看一看一个可供替换的选择：Model-View-ViewModel。\n \nMVVM来自微软，不过不要坚持反对它。MVVM和MVC很像。它正式规范了视图和控制器紧耦合的性质，并引入新的组件。\n\n在MVVM里，view和view controller正式联系在一起，我们把它们视为一个组件。视图view仍然不能直接引用模型model，当然controller也不能。相反，他们引用视图模型view model。\n \nview model是一个放置用户输入验证逻辑，视图显示逻辑，发起网络请求和其他各种各样的代码的极好的地方。有一件事情不应归入view model，那就是任何视图本身的引用。view model的概念同时适用于于iOS和OS X。（换句话说，不要在view model中使用 #import UIKit.h）\n \n由于展示逻辑（presentation logic）放在了view model中（比如model的值映射到一个格式化的字符串），视图控制器本身就会不再臃肿。当你开始使用MVVM的最好方式是，可以先将一小部分逻辑放入视图模型，然后当你逐渐习惯于使用这个范式的时候再迁移更多的逻辑到视图模型中。\n \n使用MVVM的iOS app是高度可测试的；因为view model包含了所有的展示逻辑并且不会引用view，所以它可以通过编程方式充分测试。虽然有众多的hack技术参与到测试Core Data模型，但使用MVVM写的app可以进行充分的单元测试。\n \n以我的经验，使用MVVM会轻微的增加代码量，但总体上减少了代码的复杂性。这是一个划算的交易。\n \n回过头再来看MVVM的图示，你会注意到我使用了模糊的动词“notify”和“update”，而没有详细说明该怎么做。你可以使用KVO，就像MVC那样，但这很快就会变得难以管理。事实上，使用ReactiveCocoa会是更好的方式来组织各个部分。\n \n关于怎么结合ReactiveCocoa来使用MVVM的信息，可以阅读Colin Wheeler的excellent write-up或者看看我写的开源app。你也可以阅读我的关于ReactiveCocoa和MVVM的书。\n  \n## 基于面向协议MVP的介绍\n\n曾降有无数个人总喜欢问我你们的iOS采用什么样的架构，其实每次被问到这样的问题，不是瞬间被萌了，就是想自己问自己iOS也有架构？？\n\n上文提到了MVC、MVVM，真实的业务场景中，如果场景的逻辑异常复杂，在反复的迭代中仍会出现各式各样的问题。真对MVVM我个人理解主要是将原来Controller中处理数据逻辑的代码统一归到一个新的class(viewModel)中去，更甚之网络请求等工作全部从Controller移到viewModel。刚一开始总觉的怪怪的。现阶段客户端开发越来越进入一个2.0的阶段，早期的app功能都相对比较简单，无论是从界面还是从业务逻辑上给人的感觉都是简洁实用，这中间包括UI的设计、功能的设计、产品的设计定位等。随着行业的深入，用户的过渡依赖移动端最终导致业各式各样的业务更加依赖客户端，这就导致客户端的开发不得不向PC端靠齐，在版本的反复迭代中业务场景变的愈发不尽人意，仿佛又回到了软件设计的早期。\n\n在传统软件领域，从MVC的诞生主要是为了解决软件界面的行为的分离，在复杂的业务场景内会进一步区分业务逻辑场景的分离，这些手段的最终的目的都是尽最大限度的降低整个场景的藕合度，使其达到分离的目的，模块与模块最终得到独立，将整个场景化整为零，最终使每个模块在一个零上工作，这对于无论是软件的开发还是后续的维护、以及使用普遍遵循这个原则，现有的模式大概产生了相关的类似架构。\n\n传统web架构里面是这样解决的 : \n\n![service](/images/2015-12-16/MVP/service.png) \n\n\nweb段以及其他业务层负责从接口层获取数据 并执行自己的逻辑\nservice层为外部提供接口\nDTO从负责从DB链接并进行数据读写操作\nDB层(物理机器负责数据存储)\n\n现有客户度一度采用下面的模式:\n\n![MVC](/images/2015-12-16/MVP/mvc.png) \n\n客户端通过service拿到json 数据，然后通过MVC的结构展示到UI界面上，在iOS中一直流行MVC的开发模式，通过与传统开发模式对比可以发现，其实\nservice层与客户端无非是两个互逆的过程，service层根据具体的业务场景提供对应的数据服务，service根据不同的业务场景通过DTO层拿到对应\n的数据然后组织好数据提供给外界(service 层负责将原始物理数据转换成对应的逻辑数据提供给外界)。\n\n相反。客户端通过网络层拿到对应的网络数据绘制到对应的View上，但是实际的开发过程中，网络数据与真实客户端使用场景也是有一定的差距，MVVM层将对应的\n一部分逻辑处理移植到了ViewModel中，这并没有从根本上解决问题，无非是将代码做了一份对应的copy转移，并没有从根本上达到逻辑分层的概念。相反MVP模\n式恰好解决了这一难题，MVP模式衍生于传统service架构，针对不同的业务场景图供对应的匹配的抽象service服务，客户端拿到网络数据后未达到指定的目的，\n为满足相同抽象逻辑的业务场景，在客户端网络层与model层之间加一协议层，model层实现整个协议层，之后在基于MVC的结构下将一概相同层次的\n业务场景绘制解释到对应的View上。\n\n![MVP](/images/2015-12-16/MVP/mvp.png) \n\nM : 逻辑model\nV : 视图\nP : protocol协议层\n\nModel层类似于MVVM的ViewModel，主要负责存储抽象逻辑数据，另外Model层主还有部分工作实现对应的协议层协议，提供\n协议对应的各种属性以及服务。Model经过协议层抽象约束，最后model被抽象成具有统一抽象逻辑的业务场景，最终model层在讲数据交付整个MVC结构绘制展示的时间，\n我们可以按照同一套抽象的逻辑标准去执行。\n\n在传统的web层面，为了满足各式各样的业务逻辑场景服务，最红我们实现软件罗杰的层次的分离，诞生了service服务这个概念(service就类似一个标准尺寸的水龙头出口，\n只要对应的水龙头都按照这样的规则来生产，service就能够满足格式各样的业务场景，极大的解决的传统软件服务业务场景层次的一系列难题)；相同的原理在客户端同样可以使用，\n为了满足客户端MVC结构层里面的稳定，避免各式各样的业务场景迭代插入不同的逻辑，避免最终软件危机的产生，我们采用追加协议层的模式来满足这一目的。\n\n遍观整个软件开发，从早期的软件开发，到后来软件生产管理的危机，软件开发模式一步步的确立，软件行业的每个阶段都是一个里程碑。这世间没有相对完美独到的设计法则，但是亘古不变永远只有一个那就是软件的开发更佳面相生产化、规范化、更加的利于可维护化。一直以来我本人并不特别的注重软件的设计一定、必须按照某种规则来做，毕竟不同的人、不同的业务场景、不同的工程师总有不同的实际境况，站在一个开发工程师的角度来说我并不固执于都按照固定的规则来(比如说你必须按照某个模式来做，必须用MVVM来做；必须用ReactCocoa信号型机制来做...)。相反我个人认为太过于固执只不过某些人的一厢情愿的罢了。相反我觉得因地制宜、应运而生岂不更加快哉，设计不拘于模式，更多时间更是不局限于思考。无论是MVVM、MVP哪一个不是脱胎于MVC，这个时间万变不离其宗，就像万千功法最终都离不开一步母经。\n\n\n## MVP实战开发\n\n说了这么多，下面上实战例子。\n大概描述一下业务场景，作为电商app，我们希望在原生的基础上开发一套定制的可控、可配、可维护的通用型原生模版(至于说的这么灵活 有多么的好，为啥不用H5、ReactNative,这个问题不要来问我,产品狗们让做原生，程序员只能执行)。大概是这样一个场景，可以配置的楼层样式多达十几种(至少目前已经有十几种,以后可能会更多)；每种可配置楼层样式是多元的，外观长相不一，数据格式也不尽相同但有部分类同；要求后台CMS配置界面配置法则有共同相似之处；要求每种样式楼层处理事件记忆跳转不尽相同；最可恨的页面已经很长了以后会源源不断加入新的模版。\n考虑到长远，这样的复杂楼层，如果仍旧按照传统的模式来做，问题会很多，数据无法统一、无法统一绘制、无法统一处理。具体场景相信大家应该理解了。\n\n上设计思路\n\n潜在问题\n\n* server段需要针对不同的楼层场景下发不同的数据，数据结构不尽相同\n* 模版楼层样式不尽相同，可能对应多种View\n* 多种View与多种数据结构的解释解耦问题\n* 多种业务场景用户操作逻辑处理问题\n* 楼层过于负责 Controller大爆炸\n\n逻辑建模分析\n\n* 暂时可以将每种模版楼层的整体数据作为一个容器Modle,主要负责该楼层的整体数据调度  \n\n* 将每种楼层公有的属性以及内容抽象出来放入一个容器父类，然后将不同模版特有的属性放在子模版派生Model中，作为派生属性\n\n* 对准一个容器类，我可以将每种容器Model的使用法则抽象总结归纳(1、楼层是否有Header，是否要吸顶；2、楼层是否有分享 ； 3、楼层内容是绘制在单个section单个cell中还是绘制在多行上； 4、每个楼层的元素点击跳转处理等)，我们将容器这块作为一个数据源概念最终抽象出一套可供外界获取数据的Interface(Protocol)\n\n* 最准每一个派生容器，我们都要求它去实现上述Protocol，通过协议我们可以知道具体的绘制的目标，以及要绘制的元素个数等，最终达到一个目的，\n 将每个楼层的数据装配在我们定义好的一个适配器容器内，然后通过协议给外界提供一套统一的操作入口，之后我们才用统一的操作方式操作容器，\n 实现一个容器－一个楼层\n \n* Render 协议，在这个我们对准每个要具体绘制到UI上的Model，我们统一让其实现Render协议，通过适配器容器我们我们拿到具体要绘制的目标，\n 目标绘制题都实现了Render协议，在Render协议我们可以拿到具体当前Model将由哪个具体的Cell去呈递。在每个绘制目标题内由model决定\n 当前内容由什么样式的cell模版去绘制。我们把所有的楼层数据处理逻辑压在适配器容器内，再将model的绘制目标都交由model自己决定。\n\n* 实现上述目标后，在ViewController层面，我们看到的只有一个实现了适配器协议的Model数组，在 table的绘制过程我们通过操作一个\n id<适配器Protocol> 类型的Model对象， 拿到这个具体的索引对应的对象后，通过内部已经实现的协议我们很快的拿到下一个要绘制的目标Model\n 然后再拿到具体的Cell模版的Identifier，然后从tableview中取到当前Identifier对应的cell模版，传入数据最后返回一个cell。\n\n分析场景，下面来分析一个模版的例子来说命一切吧！！\n\n这个地方我们先定义了一个适配容器协议，以及一个父容器类，我们将楼层公有属性放在父类中，并且实现一个抽象协议\n\n### Protocol 设计\n\nrender 协议\n\n* \t－TemplateRenderProtocol   \t\t//任何一个具体绘制到cell上的Model都需要实现该协议\n* \t－TemplateSpecialRenderProtocol  //楼层的header如果要吸顶需要使用该协议替代基本的Render协议\n* \t－TemplateActionProtocol\t\t\t//具有Action 操作的Model需要实现，返回一个通用的Action对象\n* \t－TemplateCellProtocol\t\t\t//整个体系中所有的Cell统一实现该协议\n\nViewController\n*\t- 楼层显示统一交与Model层定制\n*\t- VC中生成ActionModel,跳转逻辑全部应用于Action协议层，ViewController实现ActionManager 代理，作为回调处理\n*\t- 特定属性处理逻辑放在分类内\n*\t- 网络层调用扔保持在ViewController,这一点与传统保持相似，有利于结构分明(优于市面上的所谓MVVM)\n\n\n```\n//TemplateRenderProtocol.h\n@protocol TemplateRenderProtocol <NSObject,TemplateActionProtocol>\n\n- (NSString *)floorIdentifier;\n\n@end\n\n//TemplateSpecialRenderProtocol.h\n@protocol TemplateSpecialRenderProtocol <NSObject>\n\n- (NSString *)headerFloorIdentifier;\n- (id <TemplateSpecialRenderProtocol>)headerFloorModelAtIndex:(NSInteger)index;\n\n@end\n\n\n//TemplateActionProtocol.h\n */\n@protocol TemplateActionProtocol <NSObject>\n\n@optional\n\n- (TemplateJumpModel *)jumpFloorModelAtIndexPath:(NSIndexPath *)indexPath;\n\n@end\n\n\n//TemplateCellProtocol.h\n@protocol TemplateCellProtocol <NSObject>\n\n+ (CGSize)calculateSizeWithData:(id<TemplateRenderProtocol>)data constrainedToSize:(CGSize)size;\n\n- (void)processData:(id <TemplateRenderProtocol>)data;\n\n@end\n\n```\n\n\n\n### Model设计\n\n```\n//  TemplateContainerModel.h\n\n/**\n *  容器概念\n */\n@protocol TemplateContainerProtocol <NSObject>\n\n@required\n\n- (NSInteger)numberOfChildModelsInContainer;\n\n- (id <TemplateRenderProtocol>)childFloorModelAtIndex:(NSInteger)index;\n\n@end\n\n@class TemplateChannelModel;\n@interface TemplateContainerModel : NSObject<TemplateContainerProtocol,TemplateActionProtocol,TemplateRenderProtocol>\n\n//netList\n@property (nonatomic,strong) NSNumber                 *identityId;\n@property (nonatomic,strong) NSString                 *pattern;\n@property (nonatomic,strong) TemplateFHeaderModel     *fheader;\n@property (nonatomic,strong) NSArray                  *itemList;\n@property (nonatomic,strong) TemplateJumpModel        *jump;\n@property (nonatomic,strong) TemplateMarginModel      *margin;\n//other add\n@property (nonatomic,assign) TemplateChannelModel     *channelModel;\n@end\n\n```\n\n下面的就先引用一个具体的业务场景吧，顶部banner楼层，每个大的楼层都是一个容器Model，是继承于父容器，并且会适当重写父类协议以及方法\n\n```\n//TemplateFloorFocusModel.h\n\n//此处，banner是多个对象绘制成轮播的样式，整体是绘制在同一个cell上的，所以TemplateFloorFocusModel首先是一个容器类，是具有数据源的\n功能，但是他又是一个绘制目标model，TemplateFloorFocusModel实现了Render协议，就决定这个接下来会将TemplateFloorFocusModel绘制到UI界面上(如果此处的容器存储的是一个section下的list形式，容器类就无需实现render协议，只需要将list 中的Model实现render协议即可)\n\n@interface TemplateFloorFocusModel : TemplateContainerModel<TemplateRenderProtocol>\n\n@property (nonatomic,assign) NSNumber *width;\n@property (nonatomic,assign) NSNumber *height;\n\n@end\n\n\n//TemplateFloorFocusModel.m\n\n@implementation TemplateFloorFocusModel\n\n+ (NSDictionary *)mj_replacedKeyFromPropertyName\n{\n    return @{\n             @\"itemList\" : @\"picList\"\n             };\n}\n\n+ (NSDictionary *)mj_objectClassInArray\n{\n    return @{\n             @\"itemList\" : @\"TemplatePicModel\"\n             };\n}\n\n//pragma mark - TemplateContainerProtocol\n\n- (NSInteger)numberOfChildModelsInContainer\n{\n    NSUInteger rows = 0;\n    if (self.margin) rows++;\n    if (self.itemList) rows++;\n    return rows;\n}\n\n//(如果此处的容器存储的是一个section下的list形式，此处返回一个实现render协议的model即可)\n- (id <TemplateRenderProtocol>)childFloorModelAtIndex:(NSInteger)index\n{\n    if ((self.margin)&&(index+1) == [self numberOfChildModelsInContainer])\n        return self.margin;  //最后一行\n    return self;\n}\n\n//pragma mark - TemplateJumpProtocol\n\n- (TemplateJumpModel *)jumpFloorModelAtIndexPath:(NSIndexPath *)indexPath\n{\n    return nil;\n}\n\n//pragma mark -  TemplateRenderProtocol\n- (NSString *)floorIdentifier\n{\n    return @\"TemplateFocusCell\";\n}\n\n```\n\n\n### View 设计\n\nView设计此处我们才用方式依旧是将Cell作为模版，将对应的视图逻辑统一放在一个UIViewSubView中， 之后在Cell中将View直接add到cell.ContentView上。\n\n针对焦点图cell TemplateFocusCell我们有一个TemplateFocusView来对应，下面看下代码设计\n\nTemplateFocusCell\n\n```\n// TemplateFocusCell\n@interface TemplateFocusCell : UITableViewCell<TemplateCellProtocol>\n\n@end\n\n@interface TemplateFocusCell (){\n    TemplateFocusView *_focusView;\n}\n\n@property (nonatomic,strong) id <TemplateRenderProtocol> data;\n\n@end\n@implementation TemplateFocusCell\n\n- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier\n{\n    self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];\n    \n    if (self) {\n        _focusView = [[TemplateFocusView alloc] init];\n        _focusView.translatesAutoresizingMaskIntoConstraints = NO;\n        [self.contentView addSubview:_focusView];\n       }\n    return self;\n}\n\n- (void)processData:(id <TemplateRenderProtocol>)data\n{\n    if([data isKindOfClass:[TemplateFloorFocusModel class]])\n    {\n        self.data = data;\n        [_focusView processData:(id <TemplateRenderProtocol>)data];\n    }\n}\n\n+ (CGSize)calculateSizeWithData:(id<NSObject>)data constrainedToSize:(CGSize)size\n{\n//    id<TemplateRenderProtocol> model = data;\n    CGSize curSize = CGSizeMake(ScreenWidth, 110);\n    return curSize;\n}\n\n```\n\nTemplateFocusView \n\n```\n\n@interface TemplateFocusView : UIView<TemplateCellProtocol>\n\n@end\n\n@interface TemplateFocusView ()<iCarouselDataSource,iCarouselDelegate>\n{\n    UIPageControl *_pageControl;\n    iCarousel     *_scrollView;\n}\n\n@property (nonatomic,strong) TemplateFloorFocusModel *focusModel;\n@end\n\n@implementation TemplateFocusView\n\n- (instancetype)init\n{\n    self = [super init];\n    \n    if (self)\n    {\n        _scrollView = [[iCarousel alloc] init];\n        _scrollView.delegate = self;\n        _scrollView.dataSource = self;\n        _scrollView.type = iCarouselTypeLinear;\n        _scrollView.pagingEnabled = YES;\n        _scrollView.bounceDistance = 0.5;\n        _scrollView.decelerationRate = 0.5;\n        _scrollView.clipsToBounds = YES;\n        _scrollView.translatesAutoresizingMaskIntoConstraints = NO;\n        [self addSubview:_scrollView];\n        \n        _pageControl = [[UIPageControl alloc] init];\n        _pageControl.translatesAutoresizingMaskIntoConstraints = NO;\n        [self addSubview:_pageControl];\n            \n        [_scrollView mas_makeConstraints:^(MASConstraintMaker *make){\n            make.edges.equalTo(self).insets(UIEdgeInsetsZero);\n        }];\n        \n        [_pageControl mas_makeConstraints:^(MASConstraintMaker *make){\n            make.bottom.mas_equalTo(@(5));\n            make.centerX.equalTo(self);\n        }];\n    }\n    return self;\n}\n\n+ (CGSize)calculateSizeWithData:(id<TemplateRenderProtocol>)data constrainedToSize:(CGSize)size\n{\n    return size;\n}\n\n- (void)processData:(id <TemplateRenderProtocol>)data\n{\n    self.focusModel = (TemplateFloorFocusModel *)data;\n    _pageControl.numberOfPages = self.focusModel.itemList.count;\n    [_scrollView reloadData];\n    \n    [self layoutIfNeeded];\n}\n\n//pragma mark -\n- (NSInteger)numberOfItemsInCarousel:(iCarousel *)carousel\n{\n    return _focusModel.itemList.count;\n}\n\n- (UIView *)carousel:(iCarousel *)carousel viewForItemAtIndex:(NSInteger)index reusingView:(UIView *)view\n{\n    UIImageView *imageView = nil;\n    if (!view) {\n        imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, ScreenWidth, ScreenWidth/2)];\n        imageView.contentMode = UIViewContentModeScaleAspectFit;\n        }else{\n        imageView = (UIImageView *)view;\n    }\n   \n    TemplatePicModel *model = self.focusModel.itemList[index];\n    [imageView setImageWithURL:[NSURL URLWithString:model.img]];\n    return imageView;\n}\n\n- (CGFloat)carousel:(iCarousel *)carousel valueForOption:(iCarouselOption)option withDefault:(CGFloat)value\n{\n    if (option == iCarouselOptionWrap)\n    {\n        return YES;\n    }\n    return value;\n}\n\n- (void)carouselDidEndScrollingAnimation:(iCarousel *)carousel\n{\n    NSInteger index = _scrollView.scrollOffset;\n    \n    [_pageControl setCurrentPage:index];\n}\n\n```\n\n\n从View层可以看到，我们仍旧遵循以往的模式，将cell高度的计算，最终放在View中来完成(此处我们并没有Model化，而是仍旧遵循大家的习惯，具体的高度根据具体的视图场景来控制)，看到此处的计算高度的方法，接下来的问题就不多说了....\n\n\n###  Controller 设计\n\n在做完以上的一些列的逻辑化抽象工作以后，从新回到控制器层面，此时应该是大松了一口气了，到目前为止，我们一大堆系列的工作都已经做完了，只是还有一点失望的感觉是暂时还没看到是否真的有卵用，这就好比十年铸一剑，继而十年在磨一剑，看不到成效始终觉得心中似有亏欠。\n\n到目前为止，我们在控制器层面能做的仅有的是范型数据的操作，已经安全没有逻辑了，逻辑全部压入了model，下面就看下控制器层面的逻辑：\n\n```\n//注册cell\n\n[self.tableView registerClass:[TemplateFocusCell class] forCellReuseIdentifier:@\"TemplateFocusCell\"];\n\n\n//tableView 代理实现\n\n- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView\n{\n    return [self.floorModel.floors count];\n}\n\n- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section\n{\n    TemplateContainerModel<TemplateContainerProtocol> *list = self.floorModel.floors[section];\n    \n    return [list numberOfChildModelsInContainer];\n}\n\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    id <TemplateRenderProtocol> model = [self.floorModel rowModelAtIndexPath:indexPath];\n    \n    UITableViewCell <TemplateCellProtocol> * cell = [tableView dequeueReusableCellWithIdentifier:[model floorIdentifier]];\n    \n    [cell processData:model];\n    \n    if(!cell){\n        return [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:nil];\n    }else{\n        return (UITableViewCell *)cell;\n    }\n}\n\n- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    WebViewController *webViewController = [[WebViewController alloc] initWithUrl:nil];\n    [NavigateManager pushViewController:webViewController];\n}\n\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{\n    \n    id <TemplateRenderProtocol>  floor = [self.floorModel rowModelAtIndexPath:indexPath];\n    if ([floor respondsToSelector:@selector(floorIdentifier)]) {\n        NSString *cellIdentifier = [floor floorIdentifier];\n        Class<TemplateCellProtocol> viewClass = NSClassFromString(cellIdentifier);\n        CGSize size = [viewClass calculateSizeWithData:floor constrainedToSize:CGSizeMake(tableView.frame.size.width, 0.0)];\n        return size.height;\n    }\n    return 0;\n}\n\n- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section\n{\n    id <TemplateSpecialRenderProtocol,TemplateRenderProtocol> floor = self.floorModel.floors[section];\n    if ([floor conformsToProtocol:@protocol(TemplateSpecialRenderProtocol)]) {\n        NSString *headerIdentifier = [floor headerFloorIdentifier];\n        if (headerIdentifier) {\n            Class<TemplateCellProtocol> viewClass = NSClassFromString(headerIdentifier);\n            CGSize size = [viewClass calculateSizeWithData:floor constrainedToSize:CGSizeMake(tableView.frame.size.width, 0.0)];\n            return size.height;\n        }\n    }\n\n    return 0;\n}\n\n- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section\n{\n    id <TemplateSpecialRenderProtocol,TemplateRenderProtocol> floor = self.floorModel.floors[section];\n    \n    if ([floor conformsToProtocol:@protocol(TemplateSpecialRenderProtocol)]) {\n        id<TemplateSpecialRenderProtocol> headerModel = [floor headerFloorModelAtIndex:section];\n        if (headerModel) {\n            NSString *identifier = [headerModel headerFloorIdentifier];\n            UIView <TemplateCellProtocol> *headerView = (UIView <TemplateCellProtocol> *)[tableView dequeueReusableHeaderFooterViewWithIdentifier:identifier];\n            [headerView processData:floor];\n//            if ([headerView respondsToSelector:@selector(tapOnePlace:)]) {\n//                [headerView tapOnePlace:[self tapBlockForModel:headerModel]];\n//            }\n            \n            return headerView;\n        }\n    }\n    return nil;\n}\n\n```\n\n 至此，控制器只剩下以上操作，相对来说已经最大限度的梳理了逻辑，将所有的逻辑压入Model，如果服务端新增了新型的业务场景的数据，依旧可以通过协议层的适配，将数据最终的组装上述模式，最后直接拿来使用，如果需要修改对应的View，直接可以在Model内修改具体的将要渲染的View的名字即可，这些工作都跟控制器层没有任何关系。\n \n \n 在Action协议中，具有Action操作的Model会在世纪使用过程中实现这一协议，在事件处理的时间会抛出这样一个ActionModel,之后此处我们会直接\n \n Action对象handler操作，此处并没有控制器层面操作，这一点遵循了设计模式中的命令行模式(这一点原理脱胎于于strus框架中XWork框架，将控制器与UI工作无关的内务以命令行的模式跑出来，放在别的一个代理中去完成，这样能够最大的限度的做到对控制器层面的瘦身工作)。\n \n 说到控制器瘦身工作，iOS常用的大概是就是Category了，将部分全局型属性、逻辑放在对应的分类里面，有助于逻辑的抽离、代码的分割。\n\n\n容器模式 适配器模式 命令行模式\n\nMVVM (https://leanpub.com/iosfrp)\n\n\n\nhttp://blog.csdn.net/sqc3375177/article/details/11771823\nhttp://liuzhichao.com/p/1379.html\n\nhttp://www.cocoachina.com/ios/20140716/9152.html\nhttp://www.cocoachina.com/ios/20150122/10987.html\nhttp://www.cnblogs.com/xueduanyang/p/3601471.html\n\n[Model-View-Controller](http://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html#//apple_ref/doc/uid/TP40010810-CH14-SW1)","slug":"mvp-ios","published":1,"updated":"2016-02-01T06:12:35.000Z","comments":1,"photos":[],"link":"","_id":"cik7x6pmr000wivc3a6plphc6"},{"title":"Hexo教程GitCafe部署搭建博客","subtitle":"GitCafe下使用Hexo搭建博客","keywords":"Hexo教程 GitCafe下搭建博客 ","author":"Scenery","date":"2016-01-09T16:00:00.000Z","description":"GitCafe下使用Hexo搭建博客,一直以来都是喜欢在CSDN、cnblogs上分享一些自己的想法，渐渐的发觉其实这些平台有时间并不能满足自己的某些需求。对于从事技术行业以来，有自己的博客相信意义就不再多说了。不说好多大牛们都有自己的站点，作为一个大牛路上的前行者，心动不如行动，动起手来...一开始的时间选择了wordexpress、EMlog这些模版(基于PHP)，在某宝上买了基础版的主机，部署后总觉得怪怪的。说真的选用第三方的虚拟主机，出了每年要对应的开销外，经常到了期需要从心付费，如果忘记了可能会被释放掉。平时做完代码每次需要部署都的必须上传挺麻烦的。更让人受不了的是公司的网络禁止一切FTP上传工具.","_content":"\n\n## 一、绪言 \n一直以来都是喜欢在CSDN、cnblogs上分享一些自己的想法，渐渐的发觉其实这些平台有时间并不能满足自己的某些需求。对于从事技术行业以来，有自己的博客相信意义就不再多说了。不说好多大牛们都有自己的站点，作为一个大牛路上的前行者，心动不如行动，动起手来...\n\n一开始的时间选择了wordexpress、EMlog这些模版(基于PHP)，在某宝上买了基础版的主机，部署后总觉得怪怪的。说真的选用第三方的虚拟主机，出了每年要对应的开销外，经常到了期需要从心付费，如果忘记了可能会被释放掉。平时做完代码每次需要部署都的必须上传挺麻烦的。更让人受不了的是公司的网络禁止一切FTP上传工具。\n\n后来想到了阿里云，基础版的云主机一年大概500大洋的样子，配置足够用了(如果想用学生证买的话一年100大洋)，中间曾经买过一小段的时间，在自己的机器上部署了node、mysql、nginx，同时部署了git，每次做完修改直接push到远端的目录。这样坚持了一段时间，慢慢的又不习惯了，可能好长时间不远程连接一次。并且云主机也有到期后忘记续费被释放的危险，随着在主机上放的东西越来越多，越发的觉得不是那么安全。\n\n偶然的事件看到了Jekyll这个东西，可以在本地进行开发然后部署在在Github上。Jekyll也是一个基于node的框架，他的优势在于可以在本地完成自己的开发，然后直接push到Github，Github自身是支持Jekyll部署的，只需要设置好自己的page页面就可以了。但是问题又来了，生活在天朝一切总是那么不尽人意，Github这个东西大多时间访问速率极慢，甚至有时间经常打不开。更可杯具的是，Github自身屏蔽了百度爬虫的抓取，对于生活在天朝不能google的人来说这的确是一场的最大的无奈了。\n\nGitCafe是个好东西啊，这个东西就是中国版的Github，无论是访问还是爬虫抓取都是不受任何限制的。废话少说 直接迁移。就这样blog从此之后就迁移到了新家。之所以没有选择Jekyll而选择Hexo,Hexo 可以暂时理解为Jekyll＋,Hexo 是一个台湾的大学生在Jekyll的基础上脱胎而来的，我本人更喜欢后者。\n\n相对前者而言部署时间包过大，每次clone、上传都需要下载很大的一个工程包。Hexo就不同了，他的配置是在本地的，需要发布的时间配置好发布地址，hexo会自动将本地的网页全部生成对应的静态网页，之后将生成的网页存储在public文件夹下，最终hexo只会讲public文件下的内容上传到对应的部署地址，并且public文件下的内容是由deploy_git来管理的，换句话说就是每次修改发布都只是上传发生改变的文件，这一点本人特别喜欢。\n\n## 二、Hexo环境搭建\nhexo 是一个基于node的框架工具，首先我们需要在本地安装nodejs的环境，还需要安装git.有了node的环境我可以在本地进行hexo的开发调试，然后通过git直接发布并且部署到Github上。\n\n### Node 安装\n到Node.js[官网](https://nodejs.org/)下载相应平台的最新版本，一路安装即可。我用的是node-v4.2.4.pkg(Mac平台),下载以后直接安装就可以了.安装好以后,打开Terminal 输入: node -v\n\n```\nccguodeMacBook-Pro:sunny-blog ccguo$ node -v\nv5.3.0\nccguodeMacBook-Pro:sunny-blog ccguo$ npm -v\n3.3.12\nccguodeMacBook-Pro:sunny-blog ccguo$ \n\n```\n\n出现版本号以后，node安装成功。\n\nMac平台下面的git此处就略过了，不在一一解释了(mac平台自带的git工具)；\n\n关于window平台Git的客户端很多，我用的是[msysgit](http://code.google.com/p/msysgit)，喜欢用绿色版本[Portable application for official Git for Windows 1.8.4](http://code.google.com/p/msysgit/downloads/detail?name=PortableGit-1.8.4-preview20130916.7z)，下载下来设置一下环境变量即可，Git_HOME，%Git_HOME%\\bin之类的，不多说。\n\n 安装sublime工具，Mac下面我个人还是比较喜欢[sublime3](http://www.sublimetext.com), 小巧轻便不说，插件一大堆，想怎么用怎么用就。在这里仅仅作为一个文本编辑器使用，支持各种编程语言和文件格式，当然也支持Markdown语法，实在是个不可多得的练码奇才。\n\n### hexo安装\nnode 安装好以后，我们看到npm也被安装好了，npm可以暂时理解成nodejs的一个包管理工具，\n有了它我们可以通过它来将我们需要使用的node包安装到本地(例如hexo就是一个node的包)，如下\n使用npm 安装hexo，打开终端输入: npm install -g hexo\n\n```\nnpm install -g hexo\n\n```\n紧接着终端会进入下载模式，一大堆进度下载完毕以后，hexo安装成功，在终端输入: hexo -v\n\n```\nccguodeMacBook-Pro:sunny-blog ccguo$ hexo -v\nhexo: 3.1.1\nos: Darwin 14.5.0 darwin x64\nhttp_parser: 2.6.0\nnode: 5.3.0\nv8: 4.6.85.31\nuv: 1.8.0\nzlib: 1.2.8\nares: 1.10.1-DEV\nicu: 56.1\nmodules: 47\nopenssl: 1.0.2e\nccguodeMacBook-Pro:sunny-blog ccguo$ \n```\nOK ,此时hexo已经成功安装，到此本地开发环境部署安装完毕，接下来进行开发...\n\n## 三、Hexo开发\nhexo只是一个node下的框架，通过它我们可以创建自己的应用程序，然后运行自己的程序。hexo工程的源码也是基于node的，我们可以对此进行二次开发，根据自己的需求，可以改变博客的主题，也可以修改node的源码。\n\n整体来说hexo就是一个可以帮助你搭建一个不需要数据库的网站，我们可以随心所欲的修改他的源码，hexo是支持markdown 的，我们所有的内容都是以.md文件的形式存储在工程里面。hexo发布工程的时间，hexo会将所有的内容打包成一个对应的静态html页面，然后生成到一个public的文件下，之后将这个public文件发布到线上。\n\n### hexo 创建工程\ncd到当前硬盘的某个目录下，在终端中输入: hexo init myblog\n\n ```\n    hexo init myblog\n ```\n\n成初始化成功以后，我们可以在对应的文件夹下看到一恶果工程目录:\n\n```\n - Desktop\n    - myblog\n        - _config.yml\n        - package.json\n        - scaffolds\n        - source\n        - theme\n```\n\ncd到myblog目录，在该目录下面输入指令: npm install\n\n```\n    //安装依赖包\n    npm install\n    //安装成功以后发现myblog下面多出了几个文件\n    - myblog\n        - node_modules\n        - db.json\n```\n\n此时，如果没有异常，我们的blog工程就已经创建完毕了，在终端输入 : hexo s\n```\nccguodeMacBook-Pro:myblog ccguo$ hexo s\n[Error: Module version mismatch. Expected 47, got 14.]\nINFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.\n\n```\n\n此时在浏览器中输入 http://0.0.0.0:4000 ，就能看到我们的博客了.\n\n在终端中输入 hexo g z 则会进行博客的生成工作，工程目录下会多出一个public的文件夹，里面是整个博客网站的所有静态页面。\n在终端中输入hexo d 则可以进行blog的发布，具体发布流程如下...\n\n### hexo二次开发\n工程创建完毕以后，通过hexo s已经将博客运行起来了，相信看到这一面心里面已经感受到hexo的魅力了。\n将myblog文件夹拖进sublime，此时我们看到如下的工程目录：\n```\n- myblog\n    - .deploy_git    //git发布管理目录，每次发布新的内容由git进行版本管理\n    - node_modules   //node 所有的依赖包\n    - public         //发布目录\n    - scaffolds\n    - source         //博文内容文件目录\n        - _post\n    - themes         //主题文件目录\n    - .gitignore     \n    - _config.yml    //博客的配置文件\n    - db.json\n    - npm-debug.log  //日志文件\n    - package.json   //包依赖文件\n```\n\n到了这一步，我们需要做的首先是如何使用hexo,如何自己手动来完成并创建自己的博文。一般情况下，无论是我们创建自己的博文，还是针对hexo进行二次开发，我们需要关心的目录只有source目录和theme目录，source->_post目录下面是存放.md文件的，我们的每一篇博客都是以markdown文件的形式存放在_post目录下的，之后hexo s发布的时间，hexo会将所有的.md文件都生成一个静态html页面，之后发布到public目录，最终hexo d 发布到目标地址去。\n\n### 创建第一篇博文\n在source -> _post目录下，我们创建一个新的文件hello-world.md，然后编辑文件内容如下:\n```\n Hello World , This is my Hexo Blog Sunnycn..\n Welcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n```\n\n编辑完成后保存，在终端下从新执行hexo s,然后在浏览器中访问：http://0.0.0.0:4000/，就能看到刚才我们创建的博客了，hexo就是折磨简单...\n\n### 替换自己喜欢的主题\ntheme文件夹，主要是主题文件，你可以去Github上挑选自己的喜欢的主题，然后放进theme目录，之后修改配置文件_config.yml 的theme选项，就能看到对应的效果了。\n\n```\n# Extensions\n## Plugins: http://hexo.io/plugins/\n## Themes: http://hexo.io/themes/\ntheme: huno //使用主题\n```\n\n#### 发布博客\nhexo发布博客，主要是将本地已经开发好，并且已经生成的静态网页发布到一个对应的远端。例如Github，我们可以将这一系列静态文件发布到Github的某个responsity下，之后我们就可以通过一个链接去真正的访问我们的博客。\n首先，我们需要在自己的Github下面创建一个和用户名一模一样的一个工程([具体教程](http://ibruce.info/2013/11/22/hexo-your-blog/)), 创建完毕，验证ssh公钥以后，我们需要的是修改博客的本地配置文件，如下：\n\n修改配置文件 _config.yml \n```\n\n# Deployment\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type: git  //hexo 3.0以后此处填写git\n  repository: https://gitcafe.com/sunnycn/sunnycn.git  //刚才创建的与Github账户名相同的工程的远端地址\n  branch: master //gitcafe-pages  //所在的分支\n\n```\n\n在博客的配置文件中，我们配置好要发布到远端的路径、版本工具类型、分支名，然后在终端下依次执行\nhexo g , hexo d \n之后看到如下：\n```\nccguodeMacBook-Pro:sunny-blog ccguo$ hexo d\n[Error: Module version mismatch. Expected 47, got 14.]\nINFO  Deploying: git\nINFO  Clearing .deploy folder...\nINFO  Copying files from public folder...\n[master a06e618] Site updated: 2016-01-17 22:35:19\n 44 files changed, 752 insertions(+), 174 deletions(-)\n create mode 100644 2016/01/17/protocol_mvvm/index.html\n rewrite fonts/foundation-icons/foundation-icons.woff (98%)\n create mode 100644 images/2015-12-16/hexo/hexo.png\n^CINFO  Catch you later\nINFO  Deploy done: git\n\n```\n OK 博客发布成功，之后在浏览器中输入Github下的对应的地址就能访问我们的博客了...\n 至此，hexo的教程完毕....","source":"_posts/hexo-course.md","raw":"---\ntitle: Hexo教程GitCafe部署搭建博客\nsubtitle: \"GitCafe下使用Hexo搭建博客\"\nkeywords: \"Hexo教程 GitCafe下搭建博客 \"\nauthor:     \"Scenery\"\ndate: 2016-01-10\ndescription: \"GitCafe下使用Hexo搭建博客,一直以来都是喜欢在CSDN、cnblogs上分享一些自己的想法，渐渐的发觉其实这些平台有时间并不能满足自己的某些需求。对于从事技术行业以来，有自己的博客相信意义就不再多说了。不说好多大牛们都有自己的站点，作为一个大牛路上的前行者，心动不如行动，动起手来...一开始的时间选择了wordexpress、EMlog这些模版(基于PHP)，在某宝上买了基础版的主机，部署后总觉得怪怪的。说真的选用第三方的虚拟主机，出了每年要对应的开销外，经常到了期需要从心付费，如果忘记了可能会被释放掉。平时做完代码每次需要部署都的必须上传挺麻烦的。更让人受不了的是公司的网络禁止一切FTP上传工具.\"\ntags:\n\t- iOS\n\t- Hexo教程\n\t- GitCafe下搭建博客\n\t- 电子商务\n---\n\n\n## 一、绪言 \n一直以来都是喜欢在CSDN、cnblogs上分享一些自己的想法，渐渐的发觉其实这些平台有时间并不能满足自己的某些需求。对于从事技术行业以来，有自己的博客相信意义就不再多说了。不说好多大牛们都有自己的站点，作为一个大牛路上的前行者，心动不如行动，动起手来...\n\n一开始的时间选择了wordexpress、EMlog这些模版(基于PHP)，在某宝上买了基础版的主机，部署后总觉得怪怪的。说真的选用第三方的虚拟主机，出了每年要对应的开销外，经常到了期需要从心付费，如果忘记了可能会被释放掉。平时做完代码每次需要部署都的必须上传挺麻烦的。更让人受不了的是公司的网络禁止一切FTP上传工具。\n\n后来想到了阿里云，基础版的云主机一年大概500大洋的样子，配置足够用了(如果想用学生证买的话一年100大洋)，中间曾经买过一小段的时间，在自己的机器上部署了node、mysql、nginx，同时部署了git，每次做完修改直接push到远端的目录。这样坚持了一段时间，慢慢的又不习惯了，可能好长时间不远程连接一次。并且云主机也有到期后忘记续费被释放的危险，随着在主机上放的东西越来越多，越发的觉得不是那么安全。\n\n偶然的事件看到了Jekyll这个东西，可以在本地进行开发然后部署在在Github上。Jekyll也是一个基于node的框架，他的优势在于可以在本地完成自己的开发，然后直接push到Github，Github自身是支持Jekyll部署的，只需要设置好自己的page页面就可以了。但是问题又来了，生活在天朝一切总是那么不尽人意，Github这个东西大多时间访问速率极慢，甚至有时间经常打不开。更可杯具的是，Github自身屏蔽了百度爬虫的抓取，对于生活在天朝不能google的人来说这的确是一场的最大的无奈了。\n\nGitCafe是个好东西啊，这个东西就是中国版的Github，无论是访问还是爬虫抓取都是不受任何限制的。废话少说 直接迁移。就这样blog从此之后就迁移到了新家。之所以没有选择Jekyll而选择Hexo,Hexo 可以暂时理解为Jekyll＋,Hexo 是一个台湾的大学生在Jekyll的基础上脱胎而来的，我本人更喜欢后者。\n\n相对前者而言部署时间包过大，每次clone、上传都需要下载很大的一个工程包。Hexo就不同了，他的配置是在本地的，需要发布的时间配置好发布地址，hexo会自动将本地的网页全部生成对应的静态网页，之后将生成的网页存储在public文件夹下，最终hexo只会讲public文件下的内容上传到对应的部署地址，并且public文件下的内容是由deploy_git来管理的，换句话说就是每次修改发布都只是上传发生改变的文件，这一点本人特别喜欢。\n\n## 二、Hexo环境搭建\nhexo 是一个基于node的框架工具，首先我们需要在本地安装nodejs的环境，还需要安装git.有了node的环境我可以在本地进行hexo的开发调试，然后通过git直接发布并且部署到Github上。\n\n### Node 安装\n到Node.js[官网](https://nodejs.org/)下载相应平台的最新版本，一路安装即可。我用的是node-v4.2.4.pkg(Mac平台),下载以后直接安装就可以了.安装好以后,打开Terminal 输入: node -v\n\n```\nccguodeMacBook-Pro:sunny-blog ccguo$ node -v\nv5.3.0\nccguodeMacBook-Pro:sunny-blog ccguo$ npm -v\n3.3.12\nccguodeMacBook-Pro:sunny-blog ccguo$ \n\n```\n\n出现版本号以后，node安装成功。\n\nMac平台下面的git此处就略过了，不在一一解释了(mac平台自带的git工具)；\n\n关于window平台Git的客户端很多，我用的是[msysgit](http://code.google.com/p/msysgit)，喜欢用绿色版本[Portable application for official Git for Windows 1.8.4](http://code.google.com/p/msysgit/downloads/detail?name=PortableGit-1.8.4-preview20130916.7z)，下载下来设置一下环境变量即可，Git_HOME，%Git_HOME%\\bin之类的，不多说。\n\n 安装sublime工具，Mac下面我个人还是比较喜欢[sublime3](http://www.sublimetext.com), 小巧轻便不说，插件一大堆，想怎么用怎么用就。在这里仅仅作为一个文本编辑器使用，支持各种编程语言和文件格式，当然也支持Markdown语法，实在是个不可多得的练码奇才。\n\n### hexo安装\nnode 安装好以后，我们看到npm也被安装好了，npm可以暂时理解成nodejs的一个包管理工具，\n有了它我们可以通过它来将我们需要使用的node包安装到本地(例如hexo就是一个node的包)，如下\n使用npm 安装hexo，打开终端输入: npm install -g hexo\n\n```\nnpm install -g hexo\n\n```\n紧接着终端会进入下载模式，一大堆进度下载完毕以后，hexo安装成功，在终端输入: hexo -v\n\n```\nccguodeMacBook-Pro:sunny-blog ccguo$ hexo -v\nhexo: 3.1.1\nos: Darwin 14.5.0 darwin x64\nhttp_parser: 2.6.0\nnode: 5.3.0\nv8: 4.6.85.31\nuv: 1.8.0\nzlib: 1.2.8\nares: 1.10.1-DEV\nicu: 56.1\nmodules: 47\nopenssl: 1.0.2e\nccguodeMacBook-Pro:sunny-blog ccguo$ \n```\nOK ,此时hexo已经成功安装，到此本地开发环境部署安装完毕，接下来进行开发...\n\n## 三、Hexo开发\nhexo只是一个node下的框架，通过它我们可以创建自己的应用程序，然后运行自己的程序。hexo工程的源码也是基于node的，我们可以对此进行二次开发，根据自己的需求，可以改变博客的主题，也可以修改node的源码。\n\n整体来说hexo就是一个可以帮助你搭建一个不需要数据库的网站，我们可以随心所欲的修改他的源码，hexo是支持markdown 的，我们所有的内容都是以.md文件的形式存储在工程里面。hexo发布工程的时间，hexo会将所有的内容打包成一个对应的静态html页面，然后生成到一个public的文件下，之后将这个public文件发布到线上。\n\n### hexo 创建工程\ncd到当前硬盘的某个目录下，在终端中输入: hexo init myblog\n\n ```\n    hexo init myblog\n ```\n\n成初始化成功以后，我们可以在对应的文件夹下看到一恶果工程目录:\n\n```\n - Desktop\n    - myblog\n        - _config.yml\n        - package.json\n        - scaffolds\n        - source\n        - theme\n```\n\ncd到myblog目录，在该目录下面输入指令: npm install\n\n```\n    //安装依赖包\n    npm install\n    //安装成功以后发现myblog下面多出了几个文件\n    - myblog\n        - node_modules\n        - db.json\n```\n\n此时，如果没有异常，我们的blog工程就已经创建完毕了，在终端输入 : hexo s\n```\nccguodeMacBook-Pro:myblog ccguo$ hexo s\n[Error: Module version mismatch. Expected 47, got 14.]\nINFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.\n\n```\n\n此时在浏览器中输入 http://0.0.0.0:4000 ，就能看到我们的博客了.\n\n在终端中输入 hexo g z 则会进行博客的生成工作，工程目录下会多出一个public的文件夹，里面是整个博客网站的所有静态页面。\n在终端中输入hexo d 则可以进行blog的发布，具体发布流程如下...\n\n### hexo二次开发\n工程创建完毕以后，通过hexo s已经将博客运行起来了，相信看到这一面心里面已经感受到hexo的魅力了。\n将myblog文件夹拖进sublime，此时我们看到如下的工程目录：\n```\n- myblog\n    - .deploy_git    //git发布管理目录，每次发布新的内容由git进行版本管理\n    - node_modules   //node 所有的依赖包\n    - public         //发布目录\n    - scaffolds\n    - source         //博文内容文件目录\n        - _post\n    - themes         //主题文件目录\n    - .gitignore     \n    - _config.yml    //博客的配置文件\n    - db.json\n    - npm-debug.log  //日志文件\n    - package.json   //包依赖文件\n```\n\n到了这一步，我们需要做的首先是如何使用hexo,如何自己手动来完成并创建自己的博文。一般情况下，无论是我们创建自己的博文，还是针对hexo进行二次开发，我们需要关心的目录只有source目录和theme目录，source->_post目录下面是存放.md文件的，我们的每一篇博客都是以markdown文件的形式存放在_post目录下的，之后hexo s发布的时间，hexo会将所有的.md文件都生成一个静态html页面，之后发布到public目录，最终hexo d 发布到目标地址去。\n\n### 创建第一篇博文\n在source -> _post目录下，我们创建一个新的文件hello-world.md，然后编辑文件内容如下:\n```\n Hello World , This is my Hexo Blog Sunnycn..\n Welcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n```\n\n编辑完成后保存，在终端下从新执行hexo s,然后在浏览器中访问：http://0.0.0.0:4000/，就能看到刚才我们创建的博客了，hexo就是折磨简单...\n\n### 替换自己喜欢的主题\ntheme文件夹，主要是主题文件，你可以去Github上挑选自己的喜欢的主题，然后放进theme目录，之后修改配置文件_config.yml 的theme选项，就能看到对应的效果了。\n\n```\n# Extensions\n## Plugins: http://hexo.io/plugins/\n## Themes: http://hexo.io/themes/\ntheme: huno //使用主题\n```\n\n#### 发布博客\nhexo发布博客，主要是将本地已经开发好，并且已经生成的静态网页发布到一个对应的远端。例如Github，我们可以将这一系列静态文件发布到Github的某个responsity下，之后我们就可以通过一个链接去真正的访问我们的博客。\n首先，我们需要在自己的Github下面创建一个和用户名一模一样的一个工程([具体教程](http://ibruce.info/2013/11/22/hexo-your-blog/)), 创建完毕，验证ssh公钥以后，我们需要的是修改博客的本地配置文件，如下：\n\n修改配置文件 _config.yml \n```\n\n# Deployment\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type: git  //hexo 3.0以后此处填写git\n  repository: https://gitcafe.com/sunnycn/sunnycn.git  //刚才创建的与Github账户名相同的工程的远端地址\n  branch: master //gitcafe-pages  //所在的分支\n\n```\n\n在博客的配置文件中，我们配置好要发布到远端的路径、版本工具类型、分支名，然后在终端下依次执行\nhexo g , hexo d \n之后看到如下：\n```\nccguodeMacBook-Pro:sunny-blog ccguo$ hexo d\n[Error: Module version mismatch. Expected 47, got 14.]\nINFO  Deploying: git\nINFO  Clearing .deploy folder...\nINFO  Copying files from public folder...\n[master a06e618] Site updated: 2016-01-17 22:35:19\n 44 files changed, 752 insertions(+), 174 deletions(-)\n create mode 100644 2016/01/17/protocol_mvvm/index.html\n rewrite fonts/foundation-icons/foundation-icons.woff (98%)\n create mode 100644 images/2015-12-16/hexo/hexo.png\n^CINFO  Catch you later\nINFO  Deploy done: git\n\n```\n OK 博客发布成功，之后在浏览器中输入Github下的对应的地址就能访问我们的博客了...\n 至此，hexo的教程完毕....","slug":"hexo-course","published":1,"updated":"2016-02-01T06:12:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cik7x6pmv000zivc3igll0lrw"},{"title":"UITableViewCell 高度计算从混沌初始到天地交泰 ","keywords":"UITableViewCell高度计算 AutoLayout tableView高度自适应 FDTemplateLayoutCell源码分析 ","description":"UITableViewCell 高度计算从混沌初始到天地交泰,本文主要基予iOS UITableViewCell 高度自适应计算问题展开陈述。UITableView控件可能是iOS中大家最常用的控件了滚动视图、cell重用、卡顿优化。今天要讨论的不是这些高大上的话题，今天的话题只是cell高度的计算。如下: frame布局下UITableViewCell 高度计算;AutoLayout下UITableViewCell高度计算;UITableViewCell高度计算之iOS8抽风之旅;UITableViewCell高度计算之大一统;第三方库UITableView-FDTemplateLayoutCell源码抛析","date":"2015-09-30T16:00:00.000Z","author":"风之痕的博客","_content":"\n\n本文主要基予iOS UITableViewCell 高度自适应计算问题展开陈述，废话少说直入正题：\n\nUITableView控件可能是iOS中大家最常用的控件了(滚动视图、cell重用、卡顿优化),今天要讨论的不是这些高大上的话题，今天的话题只是cell高度的计算。\n\n* 传统frame布局下UITableViewCell 高度计算\n\n* AutoLayout下UITableViewCell高度计算（iOS6、7）\n\n* UITableViewCell高度计算之iOS8抽风之旅\n\n* UITableViewCell高度计算之大一统\n\n* 第三方库UITableView-FDTemplateLayoutCell源码抛析\n\n以下demo都是在cell高度可变的基础上进行的\n\n## 一、传统frame布局下UITableViewCell 高度计算\n        1、史上最传统的UITableViewCell使用方法(号称又笨又老)，相信大家都用过这种，纯frame布局，cell定制，手动传入数据通过手动计算每一行cell的高度，代码都不好意思上了。\n\n还是上下之前的demo吧！\n\n01-UITableViewCell-frame\n\n主要是在UITableViewCell(subCell)中使用一个静态方法传入数据并手动计算内容的高度\n\n说到手动计算内容的高度，其实在cell里面大多是计算一些UILabel具体的宽高，根据内容计算UILabel对应的宽高，看下具体的API：\n\n```\n\n@interface NSString(UIStringDrawing)\n\n// Single line, no wrapping. Truncation based on the NSLineBreakMode.\n\n- (CGSize)sizeWithFont:(UIFont*)fontNS_DEPRECATED_IOS(2_0,7_0,\"Use -sizeWithAttributes:\");\n\n- (CGSize)sizeWithFont:(UIFont*)font forWidth:(CGFloat)width lineBreakMode:(NSLineBreakMode)lineBreakModeNS_DEPRECATED_IOS(2_0,7_0,\"Use -boundingRectWithSize:options:attributes:context:\");\n\n// Wrapping to fit horizontal and vertical size. Text will be wrapped and truncated using the NSLineBreakMode. If the height is less than a line of text, it may return\n\n// a vertical size that is bigger than the one passed in.\n\n// If you size your text using the constrainedToSize: methods below, you should draw the text using the drawInRect: methods using the same line break mode for consistency\n\n- (CGSize)sizeWithFont:(UIFont*)font constrainedToSize:(CGSize)sizeNS_DEPRECATED_IOS(2_0,7_0,\"Use -boundingRectWithSize:options:attributes:context:\");// Uses NSLineBreakModeWordWrap\n\n- (CGSize)sizeWithFont:(UIFont*)font constrainedToSize:(CGSize)size lineBreakMode:(NSLineBreakMode)lineBreakModeNS_DEPRECATED_IOS(2_0,7_0,\"Use -boundingRectWithSize:options:attributes:context:\");// NSTextAlignment is not needed to determine size\n这个地方Apple提供了一个NSString的分类，我们可以通过传入对应的string 计算出label的自适应宽高，说到底就是使用sizeWithFont：系列重载函数根据字符串计算label的content大小。\n\n```\n\n\n代码中使用：\n\n（NSString一个传统的方法sizeWithFont：）来计算label新的frame，然后更新布局，之后返回一个预计算的高度值\n\n```\n+ (CGFloat)calulateHeightWithtTitle:(NSString*)title\n\n{\nCGFloatheight =20;\n\nCGSizelabelSize = [titlesizeWithFont:[UIFont   systemFontOfSize:17] constrainedToSize:CGSizeMake(300,500)];\nheight = height + labelSize.height;\n\nreturnheight;\n}\n\n```\n\n最终方法的调用在：\n\n```\n- (CGFloat)tableView:(UITableView*)tableView heightForRowAtIndexPath:(NSIndexPath*)indexPath\n\n{\n   return [HomeCell  calulateHeightWithtTitle:self.dataArray[indexPath.row]];\n}\n\n```\n\n来完成，并且return该float值作为cell的高度。\n\n## 二、AutoLayout下UITableViewCell高度计算（iOS6、7）\n1、下面介绍第二种方法，使用自动布局下的cell高度计算，总体来讲，自动布局下 的cell高度计算归功于UILabel的布局，自动布局下默认无需要再指定view的frame，设置完对应的约束，label会自动根据内容的多少来完成布局。废话少说先上体验版demo。\n\n08-AutoLayoutCellHeight_ios7\n\n上面描述到，传统frame布局时间，主要是通过一些列手手动计算cell中label的宽高，然后在针对cell中的subView进行重新布局，最后得出一个整体的高度作为cell真实的高度，那么在自动布局中又该如何实现呢？首先自动布局一改了之前frame的概念，自动布局中不存在所谓的坐标 宽高，只有对应的约束。针对UILabel来说，自动布局下label会根据内容的多少自适应的调整label的大小，显示对应的内容。这一点先看下UILabel在iOS6以后发生的变化：\n\n```\n// Support for constraint-based layout (auto layout)\n\n// If nonzero, this is used when determining -intrinsicContentSize for multiline labels\n\n@property(nonatomic)CGFloat  preferredMaxLayoutWidthNS_AVAILABLE_IOS(6_0);\n看到官方的注视，基本也大概有差不多的意思了，这东西实在autolayout下使用的，大概意思是给多行label设置一个布局时间优先使用的一个宽度。\n\n在看下UIView的变化\n\n@interfaceUIView (UIConstraintBasedLayoutFittingSize)\n\n/* The size fitting most closely to targetSize in which the receiver's subtree can be laid out while optimally satisfying the constraints. If you want the smallest possible size, pass UILayoutFittingCompressedSize; for the largest possible size, pass UILayoutFittingExpandedSize.\n\nAlso see the comment for UILayoutPriorityFittingSizeLevel.\n\n*/\n\n- (CGSize)systemLayoutSizeFittingSize:(CGSize)targetSizeNS_AVAILABLE_IOS(6_0);\n\n// Equivalent to sending -systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority: with UILayoutPriorityFittingSizeLevel for both priorities.\n\n意思大概就是说 当前的这个这个尺寸关系能够最佳的适应接收器的子树在满足自适应约束的同时，如果想要一个最下的尺寸就设置为：UILayoutFittingCompressedSize；反之设置：UILayoutFittingExpandedSize。\n\n```\n\n实战应用：\n\n自动布局下的自适应cell高度玩转，本教程完全依赖storybord ,依旧在代码UI领域的媛猿们，需要转变一下思维了。\n\n### (1)、创建故事板、初始化好tableview、cell的输出口等，准备cell的约束，如图：\n\ncell上只有一个label，label的约束如下，大体就是具体上下左右各加上一个约束，将来在label中放在对应的内容文字，自适应高度（不要忘了设置cell的identifier）。\n\n<img src=\"http://upload-images.jianshu.io/upload_images/664426-19cc93a143eb90a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" />\n\n<img src=\"http://upload-images.jianshu.io/upload_images/664426-aa044ce23390fbd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" />\n\n### (2)、部分实现处理代码\n\nViewController中部分代理方法\n\n```\n\n- (NSInteger)numberOfSectionsInTableView:(UITableView*)tableView\n{\n\treturn 1;\n}\n- (NSInteger)tableView:(UITableView*)tableView numberOfRowsInSection:(NSInteger)section\n\n{\n   return [self.dataArraycount];\n}\n- (UITableViewCell*)tableView:(UITableView*)tableView cellForRowAtIndexPath:(NSIndexPath*)indexPath\n{\nstatic NSString *cellIdentifier = @\"HomeCell\";\n\nHomeCell *cell = [tableView  dequeueReusableCellWithIdentifier:cellIdentifier];\n\ncell.content.text= [self.dataArray  objectAtIndex:indexPath.row];\n\nCGFloat  preMaxWaith =[UIScreen  mainScreen].bounds.size.width-108;\n\n[cell.contentset  PreferredMaxLayoutWidth:preMaxWaith];\n\n[cell.contentlayout  IfNeeded];\n\nreturncell;\n\n}\n-(CGFloat)tableView:(UITableView*)tableView heightForRowAtIndexPath:(NSIndexPath*)indexPath\n\n{\nstaticHomeCell*cell =nil;\nstatic dispatch_once_  tonceToken;\n\n//只会走一次\n\ndispatch_once(&onceToken, ^{\n\ncell = (HomeCell*)[tableView  dequeueReusableCellWithIdentifier:@\"HomeCell\"];\n\n});\n\n//calculate\nCGFloatheight = [cell  calulateHeightWithtTitle:[self.dataArray objectAtIndex:indexPath.row]desrip:[self.dataArray objectAtIndex:indexPath.row]];\n\nreturnheight;\n\n}\n\nHomeCell.m\n\n-(CGFloat)calulateHeightWithtTitle:(NSString*)title desrip:(NSString*)descrip\n\n{\n//这里非常重要\n\nCGFloat preMaxWaith =[UIScreen mainScreen].bounds.size.width-108;\n\n[self.contentset PreferredMaxLayoutWidth:preMaxWaith];\n\n//[self.titleLabel setText:title];\n\n//这也很重要\n\n[self.content  layoutIfNeeded];\n\n[self.content  setText:descrip];\n[self.contentView  layoutIfNeeded];\n\nCGSizesize = [self.contentView  systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];\n\n//加1是关键\n\nreturnsize.height+1.0f;\n}\n\n自动布局版cell高度计算OK！！\n\n```\n\n## 三、UITableViewCell高度计算之iOS8抽风之旅\n1、说到iOS8，在iOS8下如果要计算cell的高度，代码越来越少，工作越来越轻松，殊不知表面看起来特别人性的iOS8背地里面也有太多坑的勾当（具体原因见后面解释）。\n\n先上iOS的计算cell高度的体验demo：\n\n02-AutoLayout-iOS8-\n\niOS8下计算cell高度的工作比起之前的版本更加轻松\n\n### (1)、故事版拖好对应的VC、cell，接下来上约束，约束如下：\n\n<img src=\"http://upload-images.jianshu.io/upload_images/664426-ee5070c8bda9fde3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" />\n\n整体来说与2中的约束差不多，分别设置label距离四周的约束情况。（本篇文章要实现的本来就是相同的效果，在不同版本下的的实现方式以及优劣的对比与优化。）\n\n设置好约束后\n\n### (2). iOS8的cell高度计算代码\n\n设置tableview的属性\n\n```\nself.tableView.estimatedRowHeight=44.0;\n\nself.tableView.rowHeight=UITableViewAutomaticDimension;\n```\n\n至此，iOS8cell高度自适应计算OK！！ 就是这么简单...\n\n## 四、UITableViewCell高度计算之大一统\n\n\n在介绍本栏目之前先上一张表：\n\nheightForRowAtIndexPath：cell高度计算次数\n<img src=\"http://upload-images.jianshu.io/upload_images/664426-ccb02f28ef3d4049.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" />\n\nheightForRowAtIndexPath：cell计算对比\n由于iOS7之后，tableview 提供了estimatedHeightForRowAtIndexPathCount的API，这就对cell高度计算的方法调用次数产生了影响。\n\n下面首先说下estimatedHeightForRowAtIndexPathCount ：\n\n```\n// Use the estimatedHeight methods to quickly calcuate guessed values which will allow for fast load times of the table.\n\n// If these methods are implemented, the above -tableView:heightForXXX calls will be deferred until views are ready to be displayed, so more expensive logic can be placed there.\n\n- (CGFloat)tableView:(UITableView*)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath*)indexPathNS_AVAILABLE_IOS(7_0);\n```\napple的文档里面说大概意思是estimatedHeight可以快速的预估一个cell的高度值，从而让table的加载速度更快。整体来说就是tableview在渲染的时间，他会首先根据内容计算每个cell的高度，从而计算出tableview的的一个contentsize（tableview继承于scrollview），但是如果有一万行数据，那么这个计算的过程会非常的卡顿，从而影响table的load的速度，我们可以给cell（除了当前需要显示在屏幕上的cell）设置一个预估的高度值，这样就大大节省了计算高度的损耗与开销。\n\n有上图可以看出，iOS7 的tableview对于cell的高度是有缓存功能的，当划到底部，从底部再往顶部滑动时间，heightForRowAtIndexPath：cell的调用次数为0，这说话cell的高度已经换存在了内存。iOS8、iOS9坑爹的一面在于当关闭高度预估方法时间（estimatedHeightForRowAtIndexPathCount），heightForRowAtIndexPath：cell的调用次数非常多(我们一般会在这个地方计算根据内容手动计算cell的高度，或者更新cell内不各种view的约束)，这个过程如果频繁的调用是非常耗损性能的，更悲剧的事造成tableview的卡顿，这个是最容忍不了的。当开启高度预估时间，高度预估之时返回了一个定值，此时heightForRowAtIndexPath：cell的调用次数大大减少，高度计算的工作也就大大减少，此时就是我们想要的效果。\n\n此外，这个地方有一个可能忽略的问题，当我们的工程从原来的iOS7迁移到8再到9的时间，如果这个地方不做进一步的优化，之前的代码在新的系统下跑起来结果就不想而之了，为了能够兼容到所有系统下的cell高度计算，推荐一个新的工具\n\nUITableView-FDTemplateLayoutCell\n\n参考博客：具体教程如\n\n### (1)、FDTemplateLayoutCell 使用教程\n\n* 1、下载FDTemplateLayoutCell第三方库，导入工程\n<img src=\"http://upload-images.jianshu.io/upload_images/664426-e302c24c910f4c52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" />\n\n* 2、导入头文件 \n<img src=\"http://upload-images.jianshu.io/upload_images/664426-fc9ece7dca1b35f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" />\n\n* 3、使用FD实现heightForRowAtIndexPath方法\n\n如下：\n<img src=\"http://upload-images.jianshu.io/upload_images/664426-8cf78621a8e76fca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" />\n\n* 4、大功告成，使用fd一次性解决的iOS 6、7、8、9中的cell高度计算问题，FD采用自带的缓存的机制，无需多次调用heightForRowAtIndexPath时间的cell高度计算开销.\n<img src=\"http://upload-images.jianshu.io/upload_images/664426-e53b7982696e9c56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" />\n\n#### 1、FDTemplateLayoutCell之所以能够做到兼容到所有的系统版本下的tableview，主要在于它维护了一套自己的cell高度缓存，同时有效的利用了tableview的高度预估的功能。从新定义新的cell高度缓存策略，这一点解决了只有iOS7下系统才会主动缓存cell高度的这一难点，有了ＦＤiOS8、9下也能使用缓存高度\n\n#### 2、开启UITableView高度预估功能，优化heightForRowAtIndexPath的调用累计次数\n\n（tableView:estimatedHeightForRowAtIndexPath: NS_AVAILABLE_IOS(7_0);）\n\n由上可以看出estimatedHeightForRowAtIndexPath是iOS7才有的，iOS6是没有这个代理的，这个时间不仅要问，难道要iOS必须支持iOS7+以上才能使用，答案当然不是，系统的API早已做了优化，estimatedHeightForRowAtIndexPath在iOS6下面默认是可以被忽略的，不会因为版本的问题引起异常。在iOS6下高度计算的策略会跟iOS8、9下有点类似，使用FD自己提供的缓存，也能达到有效的减少计算cell高度带来的开销。\n\n## 五、FDTemplateLayoutCell源码抛析\n谈到FD，首先熟悉下之前的一个知识点, iOS知识点整理-RunLoop。可能有些老生常谈了，也有可能部分童鞋看到直接晕掉了，其实大多iOS里面大多第三方库的手段无外乎就是runtime(这个东西在java中叫reflact,java里面有AOP , iOS 其实跟这个差不多)、CF这些黑魔法之类的东西来进行偷天换日、移花接木。\n\n小结：iOS 中的runloop\n\n* 1、NSRunLoop提供了面向对象的API，但这些API不是线程安全的\n\n* 2、CFRunLoopRef提供了纯C函数的API，所有这些API都是线程安全的\n\nNSRunLoop是cocoa提供的，这个东西可能大多人还是经常使用的，cell里面更新异步下载成功的图片、启用一个timer追加到当前的应用循环中、启用一个常驻线程等；\n\nCFRunLoopRef可能就相对陌生些，CF开头跟定就是CoreFoundation中定义的，可以暂时理解为每个线程都有一个对应的runloop， 在一个runloop中可以有多种Model(模式),每个Mode又包含若干个source/Timer/Observe .\n\n程序执行的时间当前runloop 只能存在一种Model，如果发生场景切换需要退出当前Model，进入下一个Model\n\n系统一共提供了五种model：\n\n* NSDefaultRunLoopMode:    App默认Mode,当没有接收到ScrollView滚动是，主线程通常使用这个Mode\n* NSTrackingRunLoopMode:  到接收到ScroolView或其子类的时候，主线程就会切换到这个模式下运行。\n* UIInitializationRunLoopMode：当App启动时使用的第一个Mode,当启动完成后不再使用。\n* NSRunLoopCommonModes，是一个tag,本质上不是一个Mode,默认                    NSDefaultRunLoopMode和NSTrackingRunLoopMode都绑定这个tag。(应用场景：有时候我们需要添加一个NSTimer在RunLoop,在这时需要制定一个Modes，现在的需求是:我们既要在默认模式下要监听，在滚动模式下也要监听，但只能制定一个模式，这是可以制定这个CommonMode)\n* GSEventReceiveRunLoopMode：接受系统内部的Mode,通常做不到。\n\n处理不同事件使用不同的Mode，可以最大限度的把性能的最大化处理不同分类的事件，提高性能。\n知道了这些，我们可以在此处做文章，我们发现UITableView(继承UIScrollView)不滚动时间是NSDefaultRunLoopMode 模式，滚动时间是NSTrackingRunLoopMode模式，我们可以 通过注册观察者来实现让tableview不滚动的时间再去计算所有的cell的高度，一旦当tableview开始滚动我们再去取得时间着时间缓存池里面已经计算 的差不多了，也就是说尽最大可能让tableview不滚动的时间处理好所有的cell高度，缓存下来，等到滑动tableview的时间优先从缓存取，这个地方尽最大避免了边滑动边计算cell高度卡顿问题。\n\n完成了这个知识点，接下来就是处理好缓存逻辑的事情了。\n\n### 1、FD缓存池\n首先对于FD来说，维护cell的高度需要将计算过的cell的高度放进一个二维数组里面(section row)\n\nFD中存在一个可维护的NSMutableArray sections; 可以先理解为一个嵌套起来的数组是一个二位的数组，接下来的时间会把tableview 某个section下的row对应的行对应的高度存在这个位置。\n\n### 2、渲染的频率\ntableView渲染的时间，统一还是会走 heightForRowAtIndexPath方法的，我们只需要在此处直接获取到cache里面的已经存储的高度就行了，在此处避开cell的高度逻辑计算过程就到达了我们的目的。\n\n<img src=\"http://upload-images.jianshu.io/upload_images/664426-f66e121d86e311fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" />\n\nFD组件已经作了很好的封装，在heightForRowAtIndexPath中调用fd计算高度的方法，\n\n```\n- (CGFloat)fd_heightForCellWithIdentifier:(NSString*)identifier cacheByIndexPath:(NSIndexPath*)indexPath configuration:(void(^)(id))configuration\n{\n\tif(!identifier || !indexPath) {\n\treturn0;\n}\n\n// Enable auto cache invalidation if you use this \"cacheByIndexPath\" API.\n\nif(!self.fd_autoCacheInvalidationEnabled) {\n\n\tself.fd_autoCacheInvalidationEnabled=YES;\n\n}\n\n// Enable precache if you use this \"cacheByIndexPath\" API.\n\nif(!self.fd_precacheEnabled) {\n\tself.fd_precacheEnabled=YES;\n\t// Manually trigger precache only for the first time.\n\t[selffd_precacheIfNeeded];\n\n}\n\n// Hit the cache\n\nif([self.fd_cellHeightCachehasCachedHeightAtIndexPath:indexPath]) {\n\n\t[self fd_debugLog:[NSStringstringWithFormat:\n\t@\"hit cache - [%@:%@] %@\",\n\t@(indexPath.section),\n\t@(indexPath.row),\n\t@([self.fd_cellHeightCachecachedHeightAtIndexPath:indexPath])]];\n\t\n\treturn[self.fd_cellHeightCachecachedHeightAtIndexPath:indexPath];\n}\n\n// Call basic height calculation method.\n\nCGFloatheight =[selffd_heightForCellWithIdentifier:identifierconfiguration:configuration];\n\n[self fd_debugLog:[NSStringstringWithFormat:\n\t@\"cached - [%@:%@] %@\",\n\t@(indexPath.section),\n\t@(indexPath.row),\n\t@(height)]];\n\n// Cache it\n\n[self.fd_cellHeightCachecacheHeight:heightbyIndexPath:indexPath];\nreturnheight;\n}\n```\n\n这个步骤中，基本可以看出FD的使用策略，首先开启一个[selffd_precacheIfNeeded]的操作（这个过程是做了一个预计算cell高度的操作，稍后详解），接下来的过程就是从缓存池中根据IndexPath(cell高度预存储在一个模拟的二维数组中)去读取cell的高度，如果cache命中就直接返回cell高度，否则执行：\n\n// Call basic height calculation method.\n\nCGFloatheight = [self fd_heightForCellWithIdentifier:identifierconfiguration:configuration];\n去手动计算一次cell的高度，计算获得后存入缓存池\n\n```\n// Cache it\n[self.fd_cellHeightCachecacheHeight:heightbyIndexPath:indexPath];\n```\n\n最后返回高度。\n\n### 3、介绍FD的缓存池\n\nFD在这个地方利用了runloop的黑魔法，通过注册一个观察者，当tableview停止滑动的他会主动去计算当前数据源中的剩余的cell的高度，计算完以后存储在缓存池中，这个调用就是（2）中的\n\n```\n// Enable precache if you use this \"cacheByIndexPath\" API.\n\nif(!self.fd_precacheEnabled) {\n\tself.fd_precacheEnabled=YES;\n\t// Manually trigger precache only for the first time.\n\t[selffd_precacheIfNeeded];\n}\n```\n\n在这个开启调用中，通过一些列手段将tableview不滚动时间去计算cell的高度（具体原理此处省略），计算后存入缓存池sections,sections是一个可变数组，笔者显示把这个理解成一个内存存储元素是可变数组的数组(模拟一个二维数组)，FD先是给自己增加了一个属性sections作为缓存池，通过objc_setAssociatedObject给分类增加属性的此处就不介绍了，\n\n```\n[selfbuildHeightCachesAtIndexPathsIfNeeded:@[indexPath]];\n\nself.sections[indexPath.section][indexPath.row] =@(height);\n\n\n// Build every section array or row array which is smaller than given index path.\n\n[indexPaths enumerateObjectsUsingBlock:^(NSIndexPath*indexPath,NSUIntegeridx,BOOL*stop) {\n\nNSAssert(indexPath.section>=0,@\"Expect a positive section rather than '%@'.\",@(indexPath.section));\n\n\tfor(NSIntegersection =0; section <= indexPath.section; ++section) {\n\n\tif(section >=self.sections.count) {\n\n\t\tself.sections[section] =@[].mutableCopy;\n\n\t}\n}\n\nNSMutableArray*rows =self.sections[indexPath.section];\n\nfor(NSIntegerrow =0; row <= indexPath.row; ++row) {\n\nif(row >= rows.count) {\n\nrows[row] =@(_FDTemplateLayoutCellHeightCacheAbsentValue);\n\n}\n\n}\n\n}];\n```\n\n此处主要是构造一个缓存池，通过在sections中存储一个NSMutableArray,模拟一个二维的数组\n\n通过indexPath的section 和 row作为下标，构造完成直接将高度存进去：\n\nself.sections[indexPath.section][indexPath.row] =@(height);\n\n至此缓存池结束\n\n### 4、FD小结\n至此FD的核心手段大题已经讲完，接下来就是考虑到tableview的增删改插的时间的处理问题，这一系列的动作都会对缓存池的更新有一定的影响，FD已经做了最大的限度的优化，依旧runtime, swizzling的魔法就不多解释了。\n\n```\ndispatch_once(&onceToken, ^{\n\nSELselectors[] = {\n\n@selector(reloadData),\n\n@selector(insertSections:withRowAnimation:),\n\n@selector(deleteSections:withRowAnimation:),\n\n@selector(reloadSections:withRowAnimation:),\n\n@selector(moveSection:toSection:),\n\n@selector(insertRowsAtIndexPaths:withRowAnimation:),\n\n@selector(deleteRowsAtIndexPaths:withRowAnimation:),\n\n@selector(reloadRowsAtIndexPaths:withRowAnimation:),\n\n@selector(moveRowAtIndexPath:toIndexPath:)\n\n};\n\nfor(NSUIntegerindex =0; index\n\nSELoriginalSelector = selectors[index];\n\nSELswizzledSelector =NSSelectorFromString([@\"fd_\"stringByAppendingString:NSStringFromSelector(originalSelector)]);\n\nMethodoriginalMethod =class_getInstanceMethod(self, originalSelector);\n\nMethodswizzledMethod =class_getInstanceMethod(self, swizzledSelector);\n\nmethod_exchangeImplementations(originalMethod, swizzledMethod);\n\n}\n\n});\n```\n\n## 小结：\n\nFD是一个封装的很完美的库，其实从一开始使用这个库就喜欢上了，作者是百度的sunnyxy,另一方面iOS中runtime仍旧是一个很强大的东西，大多的第三方库无非都是基本objc runtime做的一些便捷优化，但是一个优秀的第三方库需要作者不断的完善和大家的共同努力。","source":"_posts/cell_height_calulate.md","raw":"---\n\ntitle:      \"UITableViewCell 高度计算从混沌初始到天地交泰 \"\nkeywords :  \"UITableViewCell高度计算 AutoLayout tableView高度自适应 FDTemplateLayoutCell源码分析 \"\ndescription: \"UITableViewCell 高度计算从混沌初始到天地交泰,本文主要基予iOS UITableViewCell 高度自适应计算问题展开陈述。UITableView控件可能是iOS中大家最常用的控件了滚动视图、cell重用、卡顿优化。今天要讨论的不是这些高大上的话题，今天的话题只是cell高度的计算。如下: frame布局下UITableViewCell 高度计算;AutoLayout下UITableViewCell高度计算;UITableViewCell高度计算之iOS8抽风之旅;UITableViewCell高度计算之大一统;第三方库UITableView-FDTemplateLayoutCell源码抛析\"\ndate:       2015-10-1\nauthor:     \"风之痕的博客\"\n\ntags:\n    - iOS\n    - TableViewCell\n    - AutoLayout\n    - FDTemplateLayoutCell\n    - 电子商务\n  \n---\n\n\n本文主要基予iOS UITableViewCell 高度自适应计算问题展开陈述，废话少说直入正题：\n\nUITableView控件可能是iOS中大家最常用的控件了(滚动视图、cell重用、卡顿优化),今天要讨论的不是这些高大上的话题，今天的话题只是cell高度的计算。\n\n* 传统frame布局下UITableViewCell 高度计算\n\n* AutoLayout下UITableViewCell高度计算（iOS6、7）\n\n* UITableViewCell高度计算之iOS8抽风之旅\n\n* UITableViewCell高度计算之大一统\n\n* 第三方库UITableView-FDTemplateLayoutCell源码抛析\n\n以下demo都是在cell高度可变的基础上进行的\n\n## 一、传统frame布局下UITableViewCell 高度计算\n        1、史上最传统的UITableViewCell使用方法(号称又笨又老)，相信大家都用过这种，纯frame布局，cell定制，手动传入数据通过手动计算每一行cell的高度，代码都不好意思上了。\n\n还是上下之前的demo吧！\n\n01-UITableViewCell-frame\n\n主要是在UITableViewCell(subCell)中使用一个静态方法传入数据并手动计算内容的高度\n\n说到手动计算内容的高度，其实在cell里面大多是计算一些UILabel具体的宽高，根据内容计算UILabel对应的宽高，看下具体的API：\n\n```\n\n@interface NSString(UIStringDrawing)\n\n// Single line, no wrapping. Truncation based on the NSLineBreakMode.\n\n- (CGSize)sizeWithFont:(UIFont*)fontNS_DEPRECATED_IOS(2_0,7_0,\"Use -sizeWithAttributes:\");\n\n- (CGSize)sizeWithFont:(UIFont*)font forWidth:(CGFloat)width lineBreakMode:(NSLineBreakMode)lineBreakModeNS_DEPRECATED_IOS(2_0,7_0,\"Use -boundingRectWithSize:options:attributes:context:\");\n\n// Wrapping to fit horizontal and vertical size. Text will be wrapped and truncated using the NSLineBreakMode. If the height is less than a line of text, it may return\n\n// a vertical size that is bigger than the one passed in.\n\n// If you size your text using the constrainedToSize: methods below, you should draw the text using the drawInRect: methods using the same line break mode for consistency\n\n- (CGSize)sizeWithFont:(UIFont*)font constrainedToSize:(CGSize)sizeNS_DEPRECATED_IOS(2_0,7_0,\"Use -boundingRectWithSize:options:attributes:context:\");// Uses NSLineBreakModeWordWrap\n\n- (CGSize)sizeWithFont:(UIFont*)font constrainedToSize:(CGSize)size lineBreakMode:(NSLineBreakMode)lineBreakModeNS_DEPRECATED_IOS(2_0,7_0,\"Use -boundingRectWithSize:options:attributes:context:\");// NSTextAlignment is not needed to determine size\n这个地方Apple提供了一个NSString的分类，我们可以通过传入对应的string 计算出label的自适应宽高，说到底就是使用sizeWithFont：系列重载函数根据字符串计算label的content大小。\n\n```\n\n\n代码中使用：\n\n（NSString一个传统的方法sizeWithFont：）来计算label新的frame，然后更新布局，之后返回一个预计算的高度值\n\n```\n+ (CGFloat)calulateHeightWithtTitle:(NSString*)title\n\n{\nCGFloatheight =20;\n\nCGSizelabelSize = [titlesizeWithFont:[UIFont   systemFontOfSize:17] constrainedToSize:CGSizeMake(300,500)];\nheight = height + labelSize.height;\n\nreturnheight;\n}\n\n```\n\n最终方法的调用在：\n\n```\n- (CGFloat)tableView:(UITableView*)tableView heightForRowAtIndexPath:(NSIndexPath*)indexPath\n\n{\n   return [HomeCell  calulateHeightWithtTitle:self.dataArray[indexPath.row]];\n}\n\n```\n\n来完成，并且return该float值作为cell的高度。\n\n## 二、AutoLayout下UITableViewCell高度计算（iOS6、7）\n1、下面介绍第二种方法，使用自动布局下的cell高度计算，总体来讲，自动布局下 的cell高度计算归功于UILabel的布局，自动布局下默认无需要再指定view的frame，设置完对应的约束，label会自动根据内容的多少来完成布局。废话少说先上体验版demo。\n\n08-AutoLayoutCellHeight_ios7\n\n上面描述到，传统frame布局时间，主要是通过一些列手手动计算cell中label的宽高，然后在针对cell中的subView进行重新布局，最后得出一个整体的高度作为cell真实的高度，那么在自动布局中又该如何实现呢？首先自动布局一改了之前frame的概念，自动布局中不存在所谓的坐标 宽高，只有对应的约束。针对UILabel来说，自动布局下label会根据内容的多少自适应的调整label的大小，显示对应的内容。这一点先看下UILabel在iOS6以后发生的变化：\n\n```\n// Support for constraint-based layout (auto layout)\n\n// If nonzero, this is used when determining -intrinsicContentSize for multiline labels\n\n@property(nonatomic)CGFloat  preferredMaxLayoutWidthNS_AVAILABLE_IOS(6_0);\n看到官方的注视，基本也大概有差不多的意思了，这东西实在autolayout下使用的，大概意思是给多行label设置一个布局时间优先使用的一个宽度。\n\n在看下UIView的变化\n\n@interfaceUIView (UIConstraintBasedLayoutFittingSize)\n\n/* The size fitting most closely to targetSize in which the receiver's subtree can be laid out while optimally satisfying the constraints. If you want the smallest possible size, pass UILayoutFittingCompressedSize; for the largest possible size, pass UILayoutFittingExpandedSize.\n\nAlso see the comment for UILayoutPriorityFittingSizeLevel.\n\n*/\n\n- (CGSize)systemLayoutSizeFittingSize:(CGSize)targetSizeNS_AVAILABLE_IOS(6_0);\n\n// Equivalent to sending -systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority: with UILayoutPriorityFittingSizeLevel for both priorities.\n\n意思大概就是说 当前的这个这个尺寸关系能够最佳的适应接收器的子树在满足自适应约束的同时，如果想要一个最下的尺寸就设置为：UILayoutFittingCompressedSize；反之设置：UILayoutFittingExpandedSize。\n\n```\n\n实战应用：\n\n自动布局下的自适应cell高度玩转，本教程完全依赖storybord ,依旧在代码UI领域的媛猿们，需要转变一下思维了。\n\n### (1)、创建故事板、初始化好tableview、cell的输出口等，准备cell的约束，如图：\n\ncell上只有一个label，label的约束如下，大体就是具体上下左右各加上一个约束，将来在label中放在对应的内容文字，自适应高度（不要忘了设置cell的identifier）。\n\n<img src=\"http://upload-images.jianshu.io/upload_images/664426-19cc93a143eb90a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" />\n\n<img src=\"http://upload-images.jianshu.io/upload_images/664426-aa044ce23390fbd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" />\n\n### (2)、部分实现处理代码\n\nViewController中部分代理方法\n\n```\n\n- (NSInteger)numberOfSectionsInTableView:(UITableView*)tableView\n{\n\treturn 1;\n}\n- (NSInteger)tableView:(UITableView*)tableView numberOfRowsInSection:(NSInteger)section\n\n{\n   return [self.dataArraycount];\n}\n- (UITableViewCell*)tableView:(UITableView*)tableView cellForRowAtIndexPath:(NSIndexPath*)indexPath\n{\nstatic NSString *cellIdentifier = @\"HomeCell\";\n\nHomeCell *cell = [tableView  dequeueReusableCellWithIdentifier:cellIdentifier];\n\ncell.content.text= [self.dataArray  objectAtIndex:indexPath.row];\n\nCGFloat  preMaxWaith =[UIScreen  mainScreen].bounds.size.width-108;\n\n[cell.contentset  PreferredMaxLayoutWidth:preMaxWaith];\n\n[cell.contentlayout  IfNeeded];\n\nreturncell;\n\n}\n-(CGFloat)tableView:(UITableView*)tableView heightForRowAtIndexPath:(NSIndexPath*)indexPath\n\n{\nstaticHomeCell*cell =nil;\nstatic dispatch_once_  tonceToken;\n\n//只会走一次\n\ndispatch_once(&onceToken, ^{\n\ncell = (HomeCell*)[tableView  dequeueReusableCellWithIdentifier:@\"HomeCell\"];\n\n});\n\n//calculate\nCGFloatheight = [cell  calulateHeightWithtTitle:[self.dataArray objectAtIndex:indexPath.row]desrip:[self.dataArray objectAtIndex:indexPath.row]];\n\nreturnheight;\n\n}\n\nHomeCell.m\n\n-(CGFloat)calulateHeightWithtTitle:(NSString*)title desrip:(NSString*)descrip\n\n{\n//这里非常重要\n\nCGFloat preMaxWaith =[UIScreen mainScreen].bounds.size.width-108;\n\n[self.contentset PreferredMaxLayoutWidth:preMaxWaith];\n\n//[self.titleLabel setText:title];\n\n//这也很重要\n\n[self.content  layoutIfNeeded];\n\n[self.content  setText:descrip];\n[self.contentView  layoutIfNeeded];\n\nCGSizesize = [self.contentView  systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];\n\n//加1是关键\n\nreturnsize.height+1.0f;\n}\n\n自动布局版cell高度计算OK！！\n\n```\n\n## 三、UITableViewCell高度计算之iOS8抽风之旅\n1、说到iOS8，在iOS8下如果要计算cell的高度，代码越来越少，工作越来越轻松，殊不知表面看起来特别人性的iOS8背地里面也有太多坑的勾当（具体原因见后面解释）。\n\n先上iOS的计算cell高度的体验demo：\n\n02-AutoLayout-iOS8-\n\niOS8下计算cell高度的工作比起之前的版本更加轻松\n\n### (1)、故事版拖好对应的VC、cell，接下来上约束，约束如下：\n\n<img src=\"http://upload-images.jianshu.io/upload_images/664426-ee5070c8bda9fde3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" />\n\n整体来说与2中的约束差不多，分别设置label距离四周的约束情况。（本篇文章要实现的本来就是相同的效果，在不同版本下的的实现方式以及优劣的对比与优化。）\n\n设置好约束后\n\n### (2). iOS8的cell高度计算代码\n\n设置tableview的属性\n\n```\nself.tableView.estimatedRowHeight=44.0;\n\nself.tableView.rowHeight=UITableViewAutomaticDimension;\n```\n\n至此，iOS8cell高度自适应计算OK！！ 就是这么简单...\n\n## 四、UITableViewCell高度计算之大一统\n\n\n在介绍本栏目之前先上一张表：\n\nheightForRowAtIndexPath：cell高度计算次数\n<img src=\"http://upload-images.jianshu.io/upload_images/664426-ccb02f28ef3d4049.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" />\n\nheightForRowAtIndexPath：cell计算对比\n由于iOS7之后，tableview 提供了estimatedHeightForRowAtIndexPathCount的API，这就对cell高度计算的方法调用次数产生了影响。\n\n下面首先说下estimatedHeightForRowAtIndexPathCount ：\n\n```\n// Use the estimatedHeight methods to quickly calcuate guessed values which will allow for fast load times of the table.\n\n// If these methods are implemented, the above -tableView:heightForXXX calls will be deferred until views are ready to be displayed, so more expensive logic can be placed there.\n\n- (CGFloat)tableView:(UITableView*)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath*)indexPathNS_AVAILABLE_IOS(7_0);\n```\napple的文档里面说大概意思是estimatedHeight可以快速的预估一个cell的高度值，从而让table的加载速度更快。整体来说就是tableview在渲染的时间，他会首先根据内容计算每个cell的高度，从而计算出tableview的的一个contentsize（tableview继承于scrollview），但是如果有一万行数据，那么这个计算的过程会非常的卡顿，从而影响table的load的速度，我们可以给cell（除了当前需要显示在屏幕上的cell）设置一个预估的高度值，这样就大大节省了计算高度的损耗与开销。\n\n有上图可以看出，iOS7 的tableview对于cell的高度是有缓存功能的，当划到底部，从底部再往顶部滑动时间，heightForRowAtIndexPath：cell的调用次数为0，这说话cell的高度已经换存在了内存。iOS8、iOS9坑爹的一面在于当关闭高度预估方法时间（estimatedHeightForRowAtIndexPathCount），heightForRowAtIndexPath：cell的调用次数非常多(我们一般会在这个地方计算根据内容手动计算cell的高度，或者更新cell内不各种view的约束)，这个过程如果频繁的调用是非常耗损性能的，更悲剧的事造成tableview的卡顿，这个是最容忍不了的。当开启高度预估时间，高度预估之时返回了一个定值，此时heightForRowAtIndexPath：cell的调用次数大大减少，高度计算的工作也就大大减少，此时就是我们想要的效果。\n\n此外，这个地方有一个可能忽略的问题，当我们的工程从原来的iOS7迁移到8再到9的时间，如果这个地方不做进一步的优化，之前的代码在新的系统下跑起来结果就不想而之了，为了能够兼容到所有系统下的cell高度计算，推荐一个新的工具\n\nUITableView-FDTemplateLayoutCell\n\n参考博客：具体教程如\n\n### (1)、FDTemplateLayoutCell 使用教程\n\n* 1、下载FDTemplateLayoutCell第三方库，导入工程\n<img src=\"http://upload-images.jianshu.io/upload_images/664426-e302c24c910f4c52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" />\n\n* 2、导入头文件 \n<img src=\"http://upload-images.jianshu.io/upload_images/664426-fc9ece7dca1b35f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" />\n\n* 3、使用FD实现heightForRowAtIndexPath方法\n\n如下：\n<img src=\"http://upload-images.jianshu.io/upload_images/664426-8cf78621a8e76fca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" />\n\n* 4、大功告成，使用fd一次性解决的iOS 6、7、8、9中的cell高度计算问题，FD采用自带的缓存的机制，无需多次调用heightForRowAtIndexPath时间的cell高度计算开销.\n<img src=\"http://upload-images.jianshu.io/upload_images/664426-e53b7982696e9c56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" />\n\n#### 1、FDTemplateLayoutCell之所以能够做到兼容到所有的系统版本下的tableview，主要在于它维护了一套自己的cell高度缓存，同时有效的利用了tableview的高度预估的功能。从新定义新的cell高度缓存策略，这一点解决了只有iOS7下系统才会主动缓存cell高度的这一难点，有了ＦＤiOS8、9下也能使用缓存高度\n\n#### 2、开启UITableView高度预估功能，优化heightForRowAtIndexPath的调用累计次数\n\n（tableView:estimatedHeightForRowAtIndexPath: NS_AVAILABLE_IOS(7_0);）\n\n由上可以看出estimatedHeightForRowAtIndexPath是iOS7才有的，iOS6是没有这个代理的，这个时间不仅要问，难道要iOS必须支持iOS7+以上才能使用，答案当然不是，系统的API早已做了优化，estimatedHeightForRowAtIndexPath在iOS6下面默认是可以被忽略的，不会因为版本的问题引起异常。在iOS6下高度计算的策略会跟iOS8、9下有点类似，使用FD自己提供的缓存，也能达到有效的减少计算cell高度带来的开销。\n\n## 五、FDTemplateLayoutCell源码抛析\n谈到FD，首先熟悉下之前的一个知识点, iOS知识点整理-RunLoop。可能有些老生常谈了，也有可能部分童鞋看到直接晕掉了，其实大多iOS里面大多第三方库的手段无外乎就是runtime(这个东西在java中叫reflact,java里面有AOP , iOS 其实跟这个差不多)、CF这些黑魔法之类的东西来进行偷天换日、移花接木。\n\n小结：iOS 中的runloop\n\n* 1、NSRunLoop提供了面向对象的API，但这些API不是线程安全的\n\n* 2、CFRunLoopRef提供了纯C函数的API，所有这些API都是线程安全的\n\nNSRunLoop是cocoa提供的，这个东西可能大多人还是经常使用的，cell里面更新异步下载成功的图片、启用一个timer追加到当前的应用循环中、启用一个常驻线程等；\n\nCFRunLoopRef可能就相对陌生些，CF开头跟定就是CoreFoundation中定义的，可以暂时理解为每个线程都有一个对应的runloop， 在一个runloop中可以有多种Model(模式),每个Mode又包含若干个source/Timer/Observe .\n\n程序执行的时间当前runloop 只能存在一种Model，如果发生场景切换需要退出当前Model，进入下一个Model\n\n系统一共提供了五种model：\n\n* NSDefaultRunLoopMode:    App默认Mode,当没有接收到ScrollView滚动是，主线程通常使用这个Mode\n* NSTrackingRunLoopMode:  到接收到ScroolView或其子类的时候，主线程就会切换到这个模式下运行。\n* UIInitializationRunLoopMode：当App启动时使用的第一个Mode,当启动完成后不再使用。\n* NSRunLoopCommonModes，是一个tag,本质上不是一个Mode,默认                    NSDefaultRunLoopMode和NSTrackingRunLoopMode都绑定这个tag。(应用场景：有时候我们需要添加一个NSTimer在RunLoop,在这时需要制定一个Modes，现在的需求是:我们既要在默认模式下要监听，在滚动模式下也要监听，但只能制定一个模式，这是可以制定这个CommonMode)\n* GSEventReceiveRunLoopMode：接受系统内部的Mode,通常做不到。\n\n处理不同事件使用不同的Mode，可以最大限度的把性能的最大化处理不同分类的事件，提高性能。\n知道了这些，我们可以在此处做文章，我们发现UITableView(继承UIScrollView)不滚动时间是NSDefaultRunLoopMode 模式，滚动时间是NSTrackingRunLoopMode模式，我们可以 通过注册观察者来实现让tableview不滚动的时间再去计算所有的cell的高度，一旦当tableview开始滚动我们再去取得时间着时间缓存池里面已经计算 的差不多了，也就是说尽最大可能让tableview不滚动的时间处理好所有的cell高度，缓存下来，等到滑动tableview的时间优先从缓存取，这个地方尽最大避免了边滑动边计算cell高度卡顿问题。\n\n完成了这个知识点，接下来就是处理好缓存逻辑的事情了。\n\n### 1、FD缓存池\n首先对于FD来说，维护cell的高度需要将计算过的cell的高度放进一个二维数组里面(section row)\n\nFD中存在一个可维护的NSMutableArray sections; 可以先理解为一个嵌套起来的数组是一个二位的数组，接下来的时间会把tableview 某个section下的row对应的行对应的高度存在这个位置。\n\n### 2、渲染的频率\ntableView渲染的时间，统一还是会走 heightForRowAtIndexPath方法的，我们只需要在此处直接获取到cache里面的已经存储的高度就行了，在此处避开cell的高度逻辑计算过程就到达了我们的目的。\n\n<img src=\"http://upload-images.jianshu.io/upload_images/664426-f66e121d86e311fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" />\n\nFD组件已经作了很好的封装，在heightForRowAtIndexPath中调用fd计算高度的方法，\n\n```\n- (CGFloat)fd_heightForCellWithIdentifier:(NSString*)identifier cacheByIndexPath:(NSIndexPath*)indexPath configuration:(void(^)(id))configuration\n{\n\tif(!identifier || !indexPath) {\n\treturn0;\n}\n\n// Enable auto cache invalidation if you use this \"cacheByIndexPath\" API.\n\nif(!self.fd_autoCacheInvalidationEnabled) {\n\n\tself.fd_autoCacheInvalidationEnabled=YES;\n\n}\n\n// Enable precache if you use this \"cacheByIndexPath\" API.\n\nif(!self.fd_precacheEnabled) {\n\tself.fd_precacheEnabled=YES;\n\t// Manually trigger precache only for the first time.\n\t[selffd_precacheIfNeeded];\n\n}\n\n// Hit the cache\n\nif([self.fd_cellHeightCachehasCachedHeightAtIndexPath:indexPath]) {\n\n\t[self fd_debugLog:[NSStringstringWithFormat:\n\t@\"hit cache - [%@:%@] %@\",\n\t@(indexPath.section),\n\t@(indexPath.row),\n\t@([self.fd_cellHeightCachecachedHeightAtIndexPath:indexPath])]];\n\t\n\treturn[self.fd_cellHeightCachecachedHeightAtIndexPath:indexPath];\n}\n\n// Call basic height calculation method.\n\nCGFloatheight =[selffd_heightForCellWithIdentifier:identifierconfiguration:configuration];\n\n[self fd_debugLog:[NSStringstringWithFormat:\n\t@\"cached - [%@:%@] %@\",\n\t@(indexPath.section),\n\t@(indexPath.row),\n\t@(height)]];\n\n// Cache it\n\n[self.fd_cellHeightCachecacheHeight:heightbyIndexPath:indexPath];\nreturnheight;\n}\n```\n\n这个步骤中，基本可以看出FD的使用策略，首先开启一个[selffd_precacheIfNeeded]的操作（这个过程是做了一个预计算cell高度的操作，稍后详解），接下来的过程就是从缓存池中根据IndexPath(cell高度预存储在一个模拟的二维数组中)去读取cell的高度，如果cache命中就直接返回cell高度，否则执行：\n\n// Call basic height calculation method.\n\nCGFloatheight = [self fd_heightForCellWithIdentifier:identifierconfiguration:configuration];\n去手动计算一次cell的高度，计算获得后存入缓存池\n\n```\n// Cache it\n[self.fd_cellHeightCachecacheHeight:heightbyIndexPath:indexPath];\n```\n\n最后返回高度。\n\n### 3、介绍FD的缓存池\n\nFD在这个地方利用了runloop的黑魔法，通过注册一个观察者，当tableview停止滑动的他会主动去计算当前数据源中的剩余的cell的高度，计算完以后存储在缓存池中，这个调用就是（2）中的\n\n```\n// Enable precache if you use this \"cacheByIndexPath\" API.\n\nif(!self.fd_precacheEnabled) {\n\tself.fd_precacheEnabled=YES;\n\t// Manually trigger precache only for the first time.\n\t[selffd_precacheIfNeeded];\n}\n```\n\n在这个开启调用中，通过一些列手段将tableview不滚动时间去计算cell的高度（具体原理此处省略），计算后存入缓存池sections,sections是一个可变数组，笔者显示把这个理解成一个内存存储元素是可变数组的数组(模拟一个二维数组)，FD先是给自己增加了一个属性sections作为缓存池，通过objc_setAssociatedObject给分类增加属性的此处就不介绍了，\n\n```\n[selfbuildHeightCachesAtIndexPathsIfNeeded:@[indexPath]];\n\nself.sections[indexPath.section][indexPath.row] =@(height);\n\n\n// Build every section array or row array which is smaller than given index path.\n\n[indexPaths enumerateObjectsUsingBlock:^(NSIndexPath*indexPath,NSUIntegeridx,BOOL*stop) {\n\nNSAssert(indexPath.section>=0,@\"Expect a positive section rather than '%@'.\",@(indexPath.section));\n\n\tfor(NSIntegersection =0; section <= indexPath.section; ++section) {\n\n\tif(section >=self.sections.count) {\n\n\t\tself.sections[section] =@[].mutableCopy;\n\n\t}\n}\n\nNSMutableArray*rows =self.sections[indexPath.section];\n\nfor(NSIntegerrow =0; row <= indexPath.row; ++row) {\n\nif(row >= rows.count) {\n\nrows[row] =@(_FDTemplateLayoutCellHeightCacheAbsentValue);\n\n}\n\n}\n\n}];\n```\n\n此处主要是构造一个缓存池，通过在sections中存储一个NSMutableArray,模拟一个二维的数组\n\n通过indexPath的section 和 row作为下标，构造完成直接将高度存进去：\n\nself.sections[indexPath.section][indexPath.row] =@(height);\n\n至此缓存池结束\n\n### 4、FD小结\n至此FD的核心手段大题已经讲完，接下来就是考虑到tableview的增删改插的时间的处理问题，这一系列的动作都会对缓存池的更新有一定的影响，FD已经做了最大的限度的优化，依旧runtime, swizzling的魔法就不多解释了。\n\n```\ndispatch_once(&onceToken, ^{\n\nSELselectors[] = {\n\n@selector(reloadData),\n\n@selector(insertSections:withRowAnimation:),\n\n@selector(deleteSections:withRowAnimation:),\n\n@selector(reloadSections:withRowAnimation:),\n\n@selector(moveSection:toSection:),\n\n@selector(insertRowsAtIndexPaths:withRowAnimation:),\n\n@selector(deleteRowsAtIndexPaths:withRowAnimation:),\n\n@selector(reloadRowsAtIndexPaths:withRowAnimation:),\n\n@selector(moveRowAtIndexPath:toIndexPath:)\n\n};\n\nfor(NSUIntegerindex =0; index\n\nSELoriginalSelector = selectors[index];\n\nSELswizzledSelector =NSSelectorFromString([@\"fd_\"stringByAppendingString:NSStringFromSelector(originalSelector)]);\n\nMethodoriginalMethod =class_getInstanceMethod(self, originalSelector);\n\nMethodswizzledMethod =class_getInstanceMethod(self, swizzledSelector);\n\nmethod_exchangeImplementations(originalMethod, swizzledMethod);\n\n}\n\n});\n```\n\n## 小结：\n\nFD是一个封装的很完美的库，其实从一开始使用这个库就喜欢上了，作者是百度的sunnyxy,另一方面iOS中runtime仍旧是一个很强大的东西，大多的第三方库无非都是基本objc runtime做的一些便捷优化，但是一个优秀的第三方库需要作者不断的完善和大家的共同努力。","slug":"cell_height_calulate","published":1,"updated":"2016-02-01T06:12:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cik7x6pnc0016ivc3you4vraq"},{"layout":"post","title":"漫谈iOS AOP编程之路 ","subtitle":"漫谈iOS AOP编程之路","date":"2015-10-23T16:00:00.000Z","author":"Scenery","logo":"avatar.png","keywords":"iOS AOP iOS切面编程 spect Oriented Programming 反射 runtime reflact ","description":"面向切面编程(也叫面向方面)：Aspect Oriented Programming(AOP),是目前软件开发中的一个热点。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。　　AOP是OOP的延续，是（Aspect Oriented Programming）的缩写，意思是面向切面（方面）编程。　　主要的功能是：日志记录，性能统计，安全控制，事务处理，异常处理等等。　　主要的意图是：将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改  变这些行为的时候不影响业务逻辑的代码。","_content":"\n\n\n## 1. AOP简介\n\nAOP: Aspect Oriented Programming 面向切面编程。\n\n面向切面编程(也叫面向方面)：Aspect Oriented Programming(AOP),是目前软件开发中的一个热点。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n\nAOP是OOP的延续，是（Aspect Oriented Programming）的缩写，意思是面向切面（方面）编程。\n\n主要的功能是：日志记录，性能统计，安全控制，事务处理，异常处理等等。\n\n主要的意图是：将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改  变这些行为的时候不影响业务逻辑的代码。\n\n可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。AOP实际是GoF设计模式的延续，设计模式孜孜不倦追求的是调用者和被调用者之间的解耦，AOP可以说也是这种目标的一种实现。\n\n假设把应用程序想成一个立体结构的话，OOP的利刃是纵向切入系统，把系统划分为很多个模块（如：用户模块，文章模块等等），而AOP的利刃是横向切入系统，提取各个模块可能都要重复操作的部分（如：权限检查，日志记录等等）。由此可见，AOP是OOP的一个有效补充。\n\n注意：AOP不是一种技术，实际上是编程思想。凡是符合AOP思想的技术，都可以看成是AOP的实现\n\n## 2. iOS中的AOP\n\n利用 Objective-C 的 Runtime 特性，我们可以给语言做扩展，帮助解决项目开发中的一些设计和技术问题。这一篇，我们来探索一些利用 Objective-C Runtime 的黑色技巧。这些技巧中最具争议的或许就是 Method Swizzling 。\n\n其次，用不用就看项目规模和团队规模。有些业务确实非常适合使用AOP,比如log，AOP还可以用来debug\n\n**AOP的优势：**\n\n1. 减少切面业务的开发量，“一次开发终生使用”，比如日志\n2. 减少代码耦合，方便复用。切面业务的代码可以独立出来，方便其他应用使用\n3. 提高代码review的质量，比如我可以规定某些类的某些方法才用特定的命名规范，这样review的时候就可以发现一些问题\n\n**AOP的弊端：**\n1. 它破坏了代码的干净整洁。\n（因为 Logging 的代码本身并不属于 ViewController 里的主要逻辑。随着项目扩大、代码量增加，你的 ViewController 里会到处散布着 Logging 的代码。这时，要找到一段事件记录的代码会变得困难，也很容易忘记添加事件记录的代码）\n\n## 3. iOS AOP实战\n\n**玩转 Method Swizzling**\n\n#### 1.事务拦截，安全可变容器\n iOS中有各类容器的概念，容器分可变容器和非可变容器，可变容器一般内部在实现上是一个链表，在进行各类（insert 、remove、 delete、 update ）难免有空操作、指针越界的问题。\n最粗暴的方式就是在使用可变容器的时间，每次操作都必须手动做空判断、索引比较这些操作:\n```\n\n NSMutableDictionary *dic = [[NSMutableDictionary alloc] init];\n    if (obj) {\n        [dic setObject:obj forKey:@\"key\"];\n    }\n\n NSMutableArray *array = [[NSMutableArray alloc] init];\n    if (index < array.count) {\n        NSLog(@\"%@\",[array objectAtIndex:index]);\n    }\n```\n\n在代码中大量的使用这鞋操作实在是太过于繁琐了，试想如果可变容器自身如何能做这些兼容岂不是更好。可能会想到继承的方法来解决，但是项目中尽可能的避免过多的派生（至于派生的弊端这里就不多说了）；或者想到分类，这里也不尽人意。\n\nMethod Swizzling 移花接木\n\nruntime 这里就不多多说了（swift里面已经对这个概念的说法从心转变成了 Reflection<反射>），objective c中每个方法的名字(SEL)跟函数的实现(IMP)是一一对应的，Swizzle的原理只是在这个地方做下手脚，将原来方法名与实现的指向交叉处理，就能达到一个新的效果。\n\n废话少说，直接上代码：\n\n这里使用NSMutableArray 做实例，为NSMutableArray追加一个新的方法\n\n```\n@implementation NSMutableArray (safe)\n\n+ (void)load\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        id obj = [[self alloc] init];\n        [obj swizzleMethod:@selector(addObject:) withMethod:@selector(safeAddObject:)];\n        [obj swizzleMethod:@selector(objectAtIndex:) withMethod:@selector(safeObjectAtIndex:)];\n        [obj swizzleMethod:@selector(insertObject:atIndex:) withMethod:@selector(safeInsertObject:atIndex:)];\n        [obj swizzleMethod:@selector(removeObjectAtIndex:) withMethod:@selector(safeRemoveObjectAtIndex:)];\n        [obj swizzleMethod:@selector(replaceObjectAtIndex:withObject:) withMethod:@selector(safeReplaceObjectAtIndex:withObject:)];\n    });\n}\n\n- (void)safeAddObject:(id)anObject\n{\n    if (anObject) {\n        [self safeAddObject:anObject];\n    }else{\n        NSLog(@\"obj is nil\");\n        \n    }\n}\n\n- (id)safeObjectAtIndex:(NSInteger)index\n{\n    if(index<[self count]){\n        return [self safeObjectAtIndex:index];\n    }else{\n        NSLog(@\"index is beyond bounds \");\n    }\n    return nil;\n}\n\n```\n\n```\n- (void)swizzleMethod:(SEL)origSelector withMethod:(SEL)newSelector\n{\n    Class class = [self class];\n    \n    Method originalMethod = class_getInstanceMethod(class, origSelector);\n    Method swizzledMethod = class_getInstanceMethod(class, newSelector);\n    \n    BOOL didAddMethod = class_addMethod(class,\n                                        origSelector,\n                                        method_getImplementation(swizzledMethod),\n                                        method_getTypeEncoding(swizzledMethod));\n    if (didAddMethod) {\n        class_replaceMethod(class,\n                            newSelector,\n                            method_getImplementation(originalMethod),\n                            method_getTypeEncoding(originalMethod));\n    } else {\n        method_exchangeImplementations(originalMethod, swizzledMethod);\n    }\n}\n```\n\n这里唯一可能需要解释的是 class_addMethod 。要先尝试添加原 selector 是为了做一层保护，因为如果这个类没有实现 originalSelector ，但其父类实现了，那 class_getInstanceMethod 会返回父类的方法。这样 method_exchangeImplementations 替换的是父类的那个方法，这当然不是你想要的。所以我们先尝试添加 orginalSelector ，如果已经存在，再用 method_exchangeImplementations 把原方法的实现跟新的方法实现给交换掉。\n\nsafeAddObject 代码看起来可能有点奇怪，像递归不是么。当然不会是递归，因为在 runtime 的时候，函数实现已经被交换了。调用 objectAtIndex: 会调用你实现的 safeObjectAtIndex:，而在 NSMutableArray: 里调用 safeObjectAtIndex: 实际上调用的是原来的 objectAtIndex: 。\n\n如此以来，一直担心的问题就迎刃而解了，不仅在可变数组、可变字典等容器内都可以做自己想做的事情。\n\n[Demo](http://https://github.com/ccguo/1-SwizzlingMethod-.git)\n#### 2. Aspects 一个基于Objective-c的AOP开发框架\n###### 业务埋点、日志打印分离\n\n相信大多童鞋们在重构代码的时间经常会从一些问题入手，例如轻量级controller、MVVM等，这些无非是对原有逻辑进一步抽象、区分、分离，重新抽象数据模型、viewmodel；相关代码放入分类；考虑业务层次抽取剥离父类；mananger、factory等。经历一大翻工作controller 中代码终于减少了，但是仍旧留下一堆的埋点、日志log的相关代码。\n\nAspects是一个很不错的 AOP 库，封装了 Runtime ， Method Swizzling 这些黑色技巧，只提供两个简单的API：\n\n```\n+ (id<aspecttoken>)aspect_hookSelector:(SEL)selector\n                         withOptions:(AspectOptions)options\n                      usingBlock:(id)block\n                           error:(NSError **)error;\n- (id<aspecttoken>)aspect_hookSelector:(SEL)selector\n                     withOptions:(AspectOptions)options\n                      usingBlock:(id)block\n                           error:(NSError **)error;\n\n//使用 Aspects 提供的 API，我们之前的例子会进化成这个样子\n\n@implementation UIViewController (Logging)+ (void)load\n{\n   [UIViewController aspect_hookSelector:@selector(viewDidAppear:)\n                             withOptions:AspectPositionAfter\n                              usingBlock:^(id<aspectinfo> aspectInfo) {        NSString *className = NSStringFromClass([[aspectInfo instance] class]);\n       [Logging logWithEventName:className];\n                              } error:NULL];\n}\n```\n相对来说如果想要捕捉到viewDidAppear 的log打印，或者是页面PV的统计上报，我们从原有的业务中将这部分代码剥离出来，掉换IMP指向以后我们可以在usingBlock 内做自己想做的事情， 这样就能达到上述想要的目的了。\n\nAspects扩展使用：\n\n页面的PV统计，事件点击统计，可以事先写在配置文件里面：\n\n```\n{        @\"MainViewController\": @{\n           GLLoggingPageImpression: @\"page imp - main page\",\n           GLLoggingTrackedEvents: @[\n               @{\n                   GLLoggingEventName: @\"button one clicked\",\n                   GLLoggingEventSelectorName: @\"buttonOneClicked:\",\n                   GLLoggingEventHandlerBlock: ^(id<aspectinfo> aspectInfo) {\n                       [Logging logWithEventName:@\"button one clicked\"];\n                   },\n               },\n               @{\n                   GLLoggingEventName: @\"button two clicked\",\n                   GLLoggingEventSelectorName: @\"buttonTwoClicked:\",\n                   GLLoggingEventHandlerBlock: ^(id<aspectinfo> aspectInfo) {\n                       [Logging logWithEventName:@\"button two clicked\"];\n                   },\n               },\n          ],\n       },        @\"DetailViewController\": @{\n           GLLoggingPageImpression: @\"page imp - detail page\",\n       }\n\n```\n\n```\n@implementation AppDelegate (Logging)\n+ (void)setupLogging{\n     [AppDelegate setupWithConfiguration:config];\n}\n\n+ (void)setupWithConfiguration:(NSDictionary *)configs\n{    // Hook Page Impression\n   [UIViewController aspect_hookSelector:@selector(viewDidAppear:)\n                             withOptions:AspectPositionAfter\n                              usingBlock:^(id<aspectinfo> aspectInfo) {                                       NSString *className = NSStringFromClass([[aspectInfo instance] class]);\n                                   [Logging logWithEventName:className];\n                              } error:NULL];    // Hook Events\n   for (NSString *className in configs) {\n       Class clazz = NSClassFromString(className);        NSDictionary *config = configs[className];        if (config[GLLoggingTrackedEvents]) {            for (NSDictionary *event in config[GLLoggingTrackedEvents]) {\n               SEL selekor = NSSelectorFromString(event[GLLoggingEventSelectorName]);\n               AspectHandlerBlock block = event[GLLoggingEventHandlerBlock];\n               [clazz aspect_hookSelector:selekor\n                              withOptions:AspectPositionAfter\n                               usingBlock:^(id<aspectinfo> aspectInfo) {\n                                   block(aspectInfo);\n                               } error:NULL];\n           }\n       }\n   }\n}\n\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {    // Override point for customization after application launch.\n   [self setupLogging];    return YES;\n}\n\n```\n\n[Demo](https://github.com/okcomp/AspectsDemo)\n#### 3. NSProxy 实现技术\n\n\n\n[method-swizzling](http://nshipster.com/method-swizzling/)\n\n[method replacement for fun and profit](https://www.mikeash.com/pyblog/friday-qa-2010-01-29-method-replacement-for-fun-and-profit.html)\n\n[Aspects](https://github.com/steipete/Aspects)","source":"_posts/aop-ios.md","raw":"---\nlayout:     post\ntitle:      \"漫谈iOS AOP编程之路 \"\nsubtitle:   \"漫谈iOS AOP编程之路\"\ndate:       2015-10-24\nauthor:     \"Scenery\"\nlogo: \"avatar.png\"\nkeywords: \"iOS AOP iOS切面编程 spect Oriented Programming 反射 runtime reflact \"\ndescription: \"面向切面编程(也叫面向方面)：Aspect Oriented Programming(AOP),是目前软件开发中的一个热点。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。　　AOP是OOP的延续，是（Aspect Oriented Programming）的缩写，意思是面向切面（方面）编程。　　主要的功能是：日志记录，性能统计，安全控制，事务处理，异常处理等等。　　主要的意图是：将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改  变这些行为的时候不影响业务逻辑的代码。\"\ntags:\n    - iOS\n    - AOP\n    - 电子商务\n---\n\n\n\n## 1. AOP简介\n\nAOP: Aspect Oriented Programming 面向切面编程。\n\n面向切面编程(也叫面向方面)：Aspect Oriented Programming(AOP),是目前软件开发中的一个热点。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n\nAOP是OOP的延续，是（Aspect Oriented Programming）的缩写，意思是面向切面（方面）编程。\n\n主要的功能是：日志记录，性能统计，安全控制，事务处理，异常处理等等。\n\n主要的意图是：将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改  变这些行为的时候不影响业务逻辑的代码。\n\n可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。AOP实际是GoF设计模式的延续，设计模式孜孜不倦追求的是调用者和被调用者之间的解耦，AOP可以说也是这种目标的一种实现。\n\n假设把应用程序想成一个立体结构的话，OOP的利刃是纵向切入系统，把系统划分为很多个模块（如：用户模块，文章模块等等），而AOP的利刃是横向切入系统，提取各个模块可能都要重复操作的部分（如：权限检查，日志记录等等）。由此可见，AOP是OOP的一个有效补充。\n\n注意：AOP不是一种技术，实际上是编程思想。凡是符合AOP思想的技术，都可以看成是AOP的实现\n\n## 2. iOS中的AOP\n\n利用 Objective-C 的 Runtime 特性，我们可以给语言做扩展，帮助解决项目开发中的一些设计和技术问题。这一篇，我们来探索一些利用 Objective-C Runtime 的黑色技巧。这些技巧中最具争议的或许就是 Method Swizzling 。\n\n其次，用不用就看项目规模和团队规模。有些业务确实非常适合使用AOP,比如log，AOP还可以用来debug\n\n**AOP的优势：**\n\n1. 减少切面业务的开发量，“一次开发终生使用”，比如日志\n2. 减少代码耦合，方便复用。切面业务的代码可以独立出来，方便其他应用使用\n3. 提高代码review的质量，比如我可以规定某些类的某些方法才用特定的命名规范，这样review的时候就可以发现一些问题\n\n**AOP的弊端：**\n1. 它破坏了代码的干净整洁。\n（因为 Logging 的代码本身并不属于 ViewController 里的主要逻辑。随着项目扩大、代码量增加，你的 ViewController 里会到处散布着 Logging 的代码。这时，要找到一段事件记录的代码会变得困难，也很容易忘记添加事件记录的代码）\n\n## 3. iOS AOP实战\n\n**玩转 Method Swizzling**\n\n#### 1.事务拦截，安全可变容器\n iOS中有各类容器的概念，容器分可变容器和非可变容器，可变容器一般内部在实现上是一个链表，在进行各类（insert 、remove、 delete、 update ）难免有空操作、指针越界的问题。\n最粗暴的方式就是在使用可变容器的时间，每次操作都必须手动做空判断、索引比较这些操作:\n```\n\n NSMutableDictionary *dic = [[NSMutableDictionary alloc] init];\n    if (obj) {\n        [dic setObject:obj forKey:@\"key\"];\n    }\n\n NSMutableArray *array = [[NSMutableArray alloc] init];\n    if (index < array.count) {\n        NSLog(@\"%@\",[array objectAtIndex:index]);\n    }\n```\n\n在代码中大量的使用这鞋操作实在是太过于繁琐了，试想如果可变容器自身如何能做这些兼容岂不是更好。可能会想到继承的方法来解决，但是项目中尽可能的避免过多的派生（至于派生的弊端这里就不多说了）；或者想到分类，这里也不尽人意。\n\nMethod Swizzling 移花接木\n\nruntime 这里就不多多说了（swift里面已经对这个概念的说法从心转变成了 Reflection<反射>），objective c中每个方法的名字(SEL)跟函数的实现(IMP)是一一对应的，Swizzle的原理只是在这个地方做下手脚，将原来方法名与实现的指向交叉处理，就能达到一个新的效果。\n\n废话少说，直接上代码：\n\n这里使用NSMutableArray 做实例，为NSMutableArray追加一个新的方法\n\n```\n@implementation NSMutableArray (safe)\n\n+ (void)load\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        id obj = [[self alloc] init];\n        [obj swizzleMethod:@selector(addObject:) withMethod:@selector(safeAddObject:)];\n        [obj swizzleMethod:@selector(objectAtIndex:) withMethod:@selector(safeObjectAtIndex:)];\n        [obj swizzleMethod:@selector(insertObject:atIndex:) withMethod:@selector(safeInsertObject:atIndex:)];\n        [obj swizzleMethod:@selector(removeObjectAtIndex:) withMethod:@selector(safeRemoveObjectAtIndex:)];\n        [obj swizzleMethod:@selector(replaceObjectAtIndex:withObject:) withMethod:@selector(safeReplaceObjectAtIndex:withObject:)];\n    });\n}\n\n- (void)safeAddObject:(id)anObject\n{\n    if (anObject) {\n        [self safeAddObject:anObject];\n    }else{\n        NSLog(@\"obj is nil\");\n        \n    }\n}\n\n- (id)safeObjectAtIndex:(NSInteger)index\n{\n    if(index<[self count]){\n        return [self safeObjectAtIndex:index];\n    }else{\n        NSLog(@\"index is beyond bounds \");\n    }\n    return nil;\n}\n\n```\n\n```\n- (void)swizzleMethod:(SEL)origSelector withMethod:(SEL)newSelector\n{\n    Class class = [self class];\n    \n    Method originalMethod = class_getInstanceMethod(class, origSelector);\n    Method swizzledMethod = class_getInstanceMethod(class, newSelector);\n    \n    BOOL didAddMethod = class_addMethod(class,\n                                        origSelector,\n                                        method_getImplementation(swizzledMethod),\n                                        method_getTypeEncoding(swizzledMethod));\n    if (didAddMethod) {\n        class_replaceMethod(class,\n                            newSelector,\n                            method_getImplementation(originalMethod),\n                            method_getTypeEncoding(originalMethod));\n    } else {\n        method_exchangeImplementations(originalMethod, swizzledMethod);\n    }\n}\n```\n\n这里唯一可能需要解释的是 class_addMethod 。要先尝试添加原 selector 是为了做一层保护，因为如果这个类没有实现 originalSelector ，但其父类实现了，那 class_getInstanceMethod 会返回父类的方法。这样 method_exchangeImplementations 替换的是父类的那个方法，这当然不是你想要的。所以我们先尝试添加 orginalSelector ，如果已经存在，再用 method_exchangeImplementations 把原方法的实现跟新的方法实现给交换掉。\n\nsafeAddObject 代码看起来可能有点奇怪，像递归不是么。当然不会是递归，因为在 runtime 的时候，函数实现已经被交换了。调用 objectAtIndex: 会调用你实现的 safeObjectAtIndex:，而在 NSMutableArray: 里调用 safeObjectAtIndex: 实际上调用的是原来的 objectAtIndex: 。\n\n如此以来，一直担心的问题就迎刃而解了，不仅在可变数组、可变字典等容器内都可以做自己想做的事情。\n\n[Demo](http://https://github.com/ccguo/1-SwizzlingMethod-.git)\n#### 2. Aspects 一个基于Objective-c的AOP开发框架\n###### 业务埋点、日志打印分离\n\n相信大多童鞋们在重构代码的时间经常会从一些问题入手，例如轻量级controller、MVVM等，这些无非是对原有逻辑进一步抽象、区分、分离，重新抽象数据模型、viewmodel；相关代码放入分类；考虑业务层次抽取剥离父类；mananger、factory等。经历一大翻工作controller 中代码终于减少了，但是仍旧留下一堆的埋点、日志log的相关代码。\n\nAspects是一个很不错的 AOP 库，封装了 Runtime ， Method Swizzling 这些黑色技巧，只提供两个简单的API：\n\n```\n+ (id<aspecttoken>)aspect_hookSelector:(SEL)selector\n                         withOptions:(AspectOptions)options\n                      usingBlock:(id)block\n                           error:(NSError **)error;\n- (id<aspecttoken>)aspect_hookSelector:(SEL)selector\n                     withOptions:(AspectOptions)options\n                      usingBlock:(id)block\n                           error:(NSError **)error;\n\n//使用 Aspects 提供的 API，我们之前的例子会进化成这个样子\n\n@implementation UIViewController (Logging)+ (void)load\n{\n   [UIViewController aspect_hookSelector:@selector(viewDidAppear:)\n                             withOptions:AspectPositionAfter\n                              usingBlock:^(id<aspectinfo> aspectInfo) {        NSString *className = NSStringFromClass([[aspectInfo instance] class]);\n       [Logging logWithEventName:className];\n                              } error:NULL];\n}\n```\n相对来说如果想要捕捉到viewDidAppear 的log打印，或者是页面PV的统计上报，我们从原有的业务中将这部分代码剥离出来，掉换IMP指向以后我们可以在usingBlock 内做自己想做的事情， 这样就能达到上述想要的目的了。\n\nAspects扩展使用：\n\n页面的PV统计，事件点击统计，可以事先写在配置文件里面：\n\n```\n{        @\"MainViewController\": @{\n           GLLoggingPageImpression: @\"page imp - main page\",\n           GLLoggingTrackedEvents: @[\n               @{\n                   GLLoggingEventName: @\"button one clicked\",\n                   GLLoggingEventSelectorName: @\"buttonOneClicked:\",\n                   GLLoggingEventHandlerBlock: ^(id<aspectinfo> aspectInfo) {\n                       [Logging logWithEventName:@\"button one clicked\"];\n                   },\n               },\n               @{\n                   GLLoggingEventName: @\"button two clicked\",\n                   GLLoggingEventSelectorName: @\"buttonTwoClicked:\",\n                   GLLoggingEventHandlerBlock: ^(id<aspectinfo> aspectInfo) {\n                       [Logging logWithEventName:@\"button two clicked\"];\n                   },\n               },\n          ],\n       },        @\"DetailViewController\": @{\n           GLLoggingPageImpression: @\"page imp - detail page\",\n       }\n\n```\n\n```\n@implementation AppDelegate (Logging)\n+ (void)setupLogging{\n     [AppDelegate setupWithConfiguration:config];\n}\n\n+ (void)setupWithConfiguration:(NSDictionary *)configs\n{    // Hook Page Impression\n   [UIViewController aspect_hookSelector:@selector(viewDidAppear:)\n                             withOptions:AspectPositionAfter\n                              usingBlock:^(id<aspectinfo> aspectInfo) {                                       NSString *className = NSStringFromClass([[aspectInfo instance] class]);\n                                   [Logging logWithEventName:className];\n                              } error:NULL];    // Hook Events\n   for (NSString *className in configs) {\n       Class clazz = NSClassFromString(className);        NSDictionary *config = configs[className];        if (config[GLLoggingTrackedEvents]) {            for (NSDictionary *event in config[GLLoggingTrackedEvents]) {\n               SEL selekor = NSSelectorFromString(event[GLLoggingEventSelectorName]);\n               AspectHandlerBlock block = event[GLLoggingEventHandlerBlock];\n               [clazz aspect_hookSelector:selekor\n                              withOptions:AspectPositionAfter\n                               usingBlock:^(id<aspectinfo> aspectInfo) {\n                                   block(aspectInfo);\n                               } error:NULL];\n           }\n       }\n   }\n}\n\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {    // Override point for customization after application launch.\n   [self setupLogging];    return YES;\n}\n\n```\n\n[Demo](https://github.com/okcomp/AspectsDemo)\n#### 3. NSProxy 实现技术\n\n\n\n[method-swizzling](http://nshipster.com/method-swizzling/)\n\n[method replacement for fun and profit](https://www.mikeash.com/pyblog/friday-qa-2010-01-29-method-replacement-for-fun-and-profit.html)\n\n[Aspects](https://github.com/steipete/Aspects)","slug":"aop-ios","published":1,"updated":"2016-02-01T06:12:35.000Z","comments":1,"photos":[],"link":"","_id":"cik7x6pnj001fivc3ewcvskh3"},{"title":"大家好，我是sunny，博客迁移至Github ，多多关照","subtitle":"大家好，我是sunny，博客迁移至Github ，多多关照","keywords":"大家好，我是sunny，博客迁移至Github ，多多关照 ","author":"Scenery","date":"2016-01-02T11:37:30.000Z","description":"大家好，我是sunnycn,博客新搬家，请大家多多关照。在经历了种种以后，博客最终还是尘埃落定了，展望这么多年，从csdn到cnblogs,再到简书最终到hexo。一路走来，真的感慨颇多。说真的，作为一个开发人员，我一度有写博客的习惯，中间也曾有间断。如今采用了hexo,真心有了家的感觉，以后的时间再接再厉...","_content":"\n### 大家好，我是sunny，博客迁移至Github ，多多关照\n\n大家好，我是sunnycn,博客新搬家，请大家多多关照。在经历了种种以后，博客最终还是尘埃落定了，展望这么多年，从csdn到cnblogs,再到简书最终到hexo。一路走来，真的感慨颇多。说真的，作为一个开发人员，我一度有写博客的习惯，中间也曾有间断。如今采用了hexo,真心有了家的感觉，以后的时间再接再厉...\n\n","source":"_posts/abouts.md","raw":"---\ntitle: 大家好，我是sunny，博客迁移至Github ，多多关照\nsubtitle: \"大家好，我是sunny，博客迁移至Github ，多多关照\"\nkeywords: \"大家好，我是sunny，博客迁移至Github ，多多关照 \"\nauthor: \"Scenery\"\ndate: 2016-01-02 19:37:30\ndescription: \"大家好，我是sunnycn,博客新搬家，请大家多多关照。在经历了种种以后，博客最终还是尘埃落定了，展望这么多年，从csdn到cnblogs,再到简书最终到hexo。一路走来，真的感慨颇多。说真的，作为一个开发人员，我一度有写博客的习惯，中间也曾有间断。如今采用了hexo,真心有了家的感觉，以后的时间再接再厉...\"\ntags:\n    - iOS\n    - 风之痕的博客教程\n    - sunnycn的博客\n    - 电子商务\n---\n\n### 大家好，我是sunny，博客迁移至Github ，多多关照\n\n大家好，我是sunnycn,博客新搬家，请大家多多关照。在经历了种种以后，博客最终还是尘埃落定了，展望这么多年，从csdn到cnblogs,再到简书最终到hexo。一路走来，真的感慨颇多。说真的，作为一个开发人员，我一度有写博客的习惯，中间也曾有间断。如今采用了hexo,真心有了家的感觉，以后的时间再接再厉...\n\n","slug":"abouts","published":1,"updated":"2016-02-01T06:12:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cik7x6pnn001kivc303jfb08e"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cik7x6pm10002ivc3yw4248l5","tag_id":"cik7x6pm50003ivc327nkxa10","_id":"cik7x6pm70006ivc3pjv718cd"},{"post_id":"cik7x6pm10002ivc3yw4248l5","tag_id":"cik7x6pm60004ivc3tf7dqnu0","_id":"cik7x6pm70007ivc306ubxa27"},{"post_id":"cik7x6pm10002ivc3yw4248l5","tag_id":"cik7x6pm70005ivc394f91ys5","_id":"cik7x6pm70008ivc3co9jq9yh"},{"post_id":"cik7x6pmd0009ivc39osif5ry","tag_id":"cik7x6pm50003ivc327nkxa10","_id":"cik7x6pmf000bivc3xc9e258m"},{"post_id":"cik7x6pmd0009ivc39osif5ry","tag_id":"cik7x6pme000aivc3q2xsme27","_id":"cik7x6pmf000civc3kz4c1lml"},{"post_id":"cik7x6pmd0009ivc39osif5ry","tag_id":"cik7x6pm60004ivc3tf7dqnu0","_id":"cik7x6pmf000divc3ujanfm2z"},{"post_id":"cik7x6pmj000eivc3urf5c6hp","tag_id":"cik7x6pml000fivc3dqbcw3rs","_id":"cik7x6pml000iivc384vnhomt"},{"post_id":"cik7x6pmj000eivc3urf5c6hp","tag_id":"cik7x6pml000givc3zdbaeu7p","_id":"cik7x6pml000jivc3vc5my89b"},{"post_id":"cik7x6pmj000eivc3urf5c6hp","tag_id":"cik7x6pml000hivc393wy33xt","_id":"cik7x6pml000kivc39k7oxhfb"},{"post_id":"cik7x6pmn000livc3rlsmxm1r","tag_id":"cik7x6pm50003ivc327nkxa10","_id":"cik7x6pmp000qivc3uizsac5b"},{"post_id":"cik7x6pmn000livc3rlsmxm1r","tag_id":"cik7x6pmo000mivc3a59ux9d5","_id":"cik7x6pmp000rivc3d5rc15rh"},{"post_id":"cik7x6pmn000livc3rlsmxm1r","tag_id":"cik7x6pmo000nivc3srmtsvp9","_id":"cik7x6pmp000sivc3vc0hwcqj"},{"post_id":"cik7x6pmn000livc3rlsmxm1r","tag_id":"cik7x6pmo000oivc3fwkpniok","_id":"cik7x6pmq000tivc30ph6lh7v"},{"post_id":"cik7x6pmn000livc3rlsmxm1r","tag_id":"cik7x6pmp000pivc3xpr6z08v","_id":"cik7x6pmq000uivc31fgn0klc"},{"post_id":"cik7x6pmn000livc3rlsmxm1r","tag_id":"cik7x6pm60004ivc3tf7dqnu0","_id":"cik7x6pmq000vivc3en0ruezd"},{"post_id":"cik7x6pmr000wivc3a6plphc6","tag_id":"cik7x6pm50003ivc327nkxa10","_id":"cik7x6pmt000xivc3vrbz0vjm"},{"post_id":"cik7x6pmr000wivc3a6plphc6","tag_id":"cik7x6pm60004ivc3tf7dqnu0","_id":"cik7x6pmt000yivc31w9xpgb4"},{"post_id":"cik7x6pmv000zivc3igll0lrw","tag_id":"cik7x6pm50003ivc327nkxa10","_id":"cik7x6pmx0012ivc3rykijbb7"},{"post_id":"cik7x6pmv000zivc3igll0lrw","tag_id":"cik7x6pmw0010ivc31kq81c8p","_id":"cik7x6pmy0013ivc3ah87zg4q"},{"post_id":"cik7x6pmv000zivc3igll0lrw","tag_id":"cik7x6pmx0011ivc30ps2hiba","_id":"cik7x6pmy0014ivc3l6q07vc5"},{"post_id":"cik7x6pmv000zivc3igll0lrw","tag_id":"cik7x6pm60004ivc3tf7dqnu0","_id":"cik7x6pmy0015ivc3qxw24f1x"},{"post_id":"cik7x6pnc0016ivc3you4vraq","tag_id":"cik7x6pm50003ivc327nkxa10","_id":"cik7x6png001aivc31xzage08"},{"post_id":"cik7x6pnc0016ivc3you4vraq","tag_id":"cik7x6pne0017ivc3ti79jofh","_id":"cik7x6pnh001bivc33l8j0ahz"},{"post_id":"cik7x6pnc0016ivc3you4vraq","tag_id":"cik7x6pne0018ivc3pddexja9","_id":"cik7x6pnh001civc3u77pbsw1"},{"post_id":"cik7x6pnc0016ivc3you4vraq","tag_id":"cik7x6pne0019ivc3qy3scfb1","_id":"cik7x6pnh001divc33i5b1z7t"},{"post_id":"cik7x6pnc0016ivc3you4vraq","tag_id":"cik7x6pm60004ivc3tf7dqnu0","_id":"cik7x6pnh001eivc3pwbtcv5c"},{"post_id":"cik7x6pnj001fivc3ewcvskh3","tag_id":"cik7x6pm50003ivc327nkxa10","_id":"cik7x6pnl001hivc3myhnxx2h"},{"post_id":"cik7x6pnj001fivc3ewcvskh3","tag_id":"cik7x6pnk001givc32in62oxy","_id":"cik7x6pnl001iivc3hhrgbs09"},{"post_id":"cik7x6pnj001fivc3ewcvskh3","tag_id":"cik7x6pm60004ivc3tf7dqnu0","_id":"cik7x6pnl001jivc3w83n7uh4"},{"post_id":"cik7x6pnn001kivc303jfb08e","tag_id":"cik7x6pm50003ivc327nkxa10","_id":"cik7x6pnp001nivc31g0pngkw"},{"post_id":"cik7x6pnn001kivc303jfb08e","tag_id":"cik7x6pno001livc382n9goo9","_id":"cik7x6pnp001oivc3nw87g5jq"},{"post_id":"cik7x6pnn001kivc303jfb08e","tag_id":"cik7x6pnp001mivc3fmk4cnfe","_id":"cik7x6pnq001pivc3in4bqfaa"},{"post_id":"cik7x6pnn001kivc303jfb08e","tag_id":"cik7x6pm60004ivc3tf7dqnu0","_id":"cik7x6pnq001qivc3bjxnfvhj"}],"Tag":[{"name":"iOS","_id":"cik7x6pm50003ivc327nkxa10"},{"name":"电子商务","_id":"cik7x6pm60004ivc3tf7dqnu0"},{"name":"XCTestCase","_id":"cik7x6pm70005ivc394f91ys5"},{"name":"React-Native","_id":"cik7x6pme000aivc3q2xsme27"},{"name":"前端","_id":"cik7x6pml000fivc3dqbcw3rs"},{"name":"js","_id":"cik7x6pml000givc3zdbaeu7p"},{"name":"做一个不可替代的架构师","_id":"cik7x6pml000hivc393wy33xt"},{"name":"MVVM","_id":"cik7x6pmo000mivc3a59ux9d5"},{"name":"MVV","_id":"cik7x6pmo000nivc3srmtsvp9"},{"name":"MVP","_id":"cik7x6pmo000oivc3fwkpniok"},{"name":"iOS开发框架","_id":"cik7x6pmp000pivc3xpr6z08v"},{"name":"Hexo教程","_id":"cik7x6pmw0010ivc31kq81c8p"},{"name":"GitCafe下搭建博客","_id":"cik7x6pmx0011ivc30ps2hiba"},{"name":"TableViewCell","_id":"cik7x6pne0017ivc3ti79jofh"},{"name":"AutoLayout","_id":"cik7x6pne0018ivc3pddexja9"},{"name":"FDTemplateLayoutCell","_id":"cik7x6pne0019ivc3qy3scfb1"},{"name":"AOP","_id":"cik7x6pnk001givc32in62oxy"},{"name":"风之痕的博客教程","_id":"cik7x6pno001livc382n9goo9"},{"name":"sunnycn的博客","_id":"cik7x6pnp001mivc3fmk4cnfe"}]}}